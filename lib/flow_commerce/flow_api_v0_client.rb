# Generated by apidoc - http://www.apidoc.me
# Service version: 0.0.53
# apidoc:0.11.32 http://www.apidoc.me/flow/api/0.0.53/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# The Flow Commerce REST API provides full access to the global ecommerce
# platform.
module Io
  module Flow
    module V0

      class Client

        module Constants

          BASE_URL = 'https://api.flow.io' unless defined?(Constants::BASE_URL)
          NAMESPACE = 'io.flow.v0' unless defined?(Constants::NAMESPACE)
          USER_AGENT = 'apidoc:0.11.32 http://www.apidoc.me/flow/api/0.0.53/ruby_client' unless defined?(Constants::USER_AGENT)
          VERSION = '0.0.53' unless defined?(Constants::VERSION)
          VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

        end

        attr_reader :url

        def initialize(url, opts={})
          @url = HttpClient::Preconditions.assert_class('url', url, String)
          @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
          @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
          HttpClient::Preconditions.assert_empty_opts(opts)
          HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
        end

        # Creates an instance of the client using the base url specified in the API spec.
        def Client.at_base_url(opts={})
          Client.new(Constants::BASE_URL, opts)
        end

        def request(path=nil)
          HttpClient::Preconditions.assert_class_or_nil('path', path, String)
          request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

          @default_headers.each do |key, value|
            request = request.with_header(key, value)
          end

          if @authorization
            request = request.with_auth(@authorization)
          end

          request
        end

        def attributes
          @attributes ||= ::Io::Flow::V0::Clients::Attributes.new(self)
        end

        def catalogs
          @catalogs ||= ::Io::Flow::V0::Clients::Catalogs.new(self)
        end

        def experiences
          @experiences ||= ::Io::Flow::V0::Clients::Experiences.new(self)
        end

        def items
          @items ||= ::Io::Flow::V0::Clients::Items.new(self)
        end

        def orders
          @orders ||= ::Io::Flow::V0::Clients::Orders.new(self)
        end

        def subcatalogs
          @subcatalogs ||= ::Io::Flow::V0::Clients::Subcatalogs.new(self)
        end

        def subcatalog_items
          @subcatalog_items ||= ::Io::Flow::V0::Clients::SubcatalogItems.new(self)
        end

        def functions
          @functions ||= ::Io::Flow::V0::Clients::Functions.new(self)
        end

        def duties
          @duties ||= ::Io::Flow::V0::Clients::Duties.new(self)
        end

        def harmonization_settings
          @harmonization_settings ||= ::Io::Flow::V0::Clients::HarmonizationSettings.new(self)
        end

        def harmonized_items
          @harmonized_items ||= ::Io::Flow::V0::Clients::HarmonizedItems.new(self)
        end

        def harmonized_item_duties
          @harmonized_item_duties ||= ::Io::Flow::V0::Clients::HarmonizedItemDuties.new(self)
        end

        def hs10
          @hs10 ||= ::Io::Flow::V0::Clients::Hs10.new(self)
        end

        def hs6
          @hs6 ||= ::Io::Flow::V0::Clients::Hs6.new(self)
        end

        def taxes
          @taxes ||= ::Io::Flow::V0::Clients::Taxes.new(self)
        end

        def authorizations
          @authorizations ||= ::Io::Flow::V0::Clients::Authorizations.new(self)
        end

        def captures
          @captures ||= ::Io::Flow::V0::Clients::Captures.new(self)
        end

        def cards
          @cards ||= ::Io::Flow::V0::Clients::Cards.new(self)
        end

        def refunds
          @refunds ||= ::Io::Flow::V0::Clients::Refunds.new(self)
        end

        def bookings
          @bookings ||= ::Io::Flow::V0::Clients::Bookings.new(self)
        end

        def carriers
          @carriers ||= ::Io::Flow::V0::Clients::Carriers.new(self)
        end

        def carrier_accounts
          @carrier_accounts ||= ::Io::Flow::V0::Clients::CarrierAccounts.new(self)
        end

        def centers
          @centers ||= ::Io::Flow::V0::Clients::Centers.new(self)
        end

        def delivery_windows
          @delivery_windows ||= ::Io::Flow::V0::Clients::DeliveryWindows.new(self)
        end

        def inventory_rules
          @inventory_rules ||= ::Io::Flow::V0::Clients::InventoryRules.new(self)
        end

        def inventory_snapshots
          @inventory_snapshots ||= ::Io::Flow::V0::Clients::InventorySnapshots.new(self)
        end

        def inventory_updates
          @inventory_updates ||= ::Io::Flow::V0::Clients::InventoryUpdates.new(self)
        end

        def labels
          @labels ||= ::Io::Flow::V0::Clients::Labels.new(self)
        end

        def label_events
          @label_events ||= ::Io::Flow::V0::Clients::LabelEvents.new(self)
        end

        def lanes
          @lanes ||= ::Io::Flow::V0::Clients::Lanes.new(self)
        end

        def quotes
          @quotes ||= ::Io::Flow::V0::Clients::Quotes.new(self)
        end

        def services
          @services ||= ::Io::Flow::V0::Clients::Services.new(self)
        end

        def shipments
          @shipments ||= ::Io::Flow::V0::Clients::Shipments.new(self)
        end

        def shipment_labels
          @shipment_labels ||= ::Io::Flow::V0::Clients::ShipmentLabels.new(self)
        end

        def tiers
          @tiers ||= ::Io::Flow::V0::Clients::Tiers.new(self)
        end

        def trackings
          @trackings ||= ::Io::Flow::V0::Clients::Trackings.new(self)
        end

        def countries
          @countries ||= ::Io::Flow::V0::Clients::Countries.new(self)
        end

        def currencies
          @currencies ||= ::Io::Flow::V0::Clients::Currencies.new(self)
        end

        def languages
          @languages ||= ::Io::Flow::V0::Clients::Languages.new(self)
        end

        def regions
          @regions ||= ::Io::Flow::V0::Clients::Regions.new(self)
        end

        def timezones
          @timezones ||= ::Io::Flow::V0::Clients::Timezones.new(self)
        end

        def documents
          @documents ||= ::Io::Flow::V0::Clients::Documents.new(self)
        end

        def email_verifications
          @email_verifications ||= ::Io::Flow::V0::Clients::EmailVerifications.new(self)
        end

        def healthchecks
          @healthchecks ||= ::Io::Flow::V0::Clients::Healthchecks.new(self)
        end

        def invitations
          @invitations ||= ::Io::Flow::V0::Clients::Invitations.new(self)
        end

        def locations
          @locations ||= ::Io::Flow::V0::Clients::Locations.new(self)
        end

        def memberships
          @memberships ||= ::Io::Flow::V0::Clients::Memberships.new(self)
        end

        def organizations
          @organizations ||= ::Io::Flow::V0::Clients::Organizations.new(self)
        end

        def organization_authorizations
          @organization_authorizations ||= ::Io::Flow::V0::Clients::OrganizationAuthorizations.new(self)
        end

        def password_reset_forms
          @password_reset_forms ||= ::Io::Flow::V0::Clients::PasswordResetForms.new(self)
        end

        def suggestions
          @suggestions ||= ::Io::Flow::V0::Clients::Suggestions.new(self)
        end

        def tokens
          @tokens ||= ::Io::Flow::V0::Clients::Tokens.new(self)
        end

        def users
          @users ||= ::Io::Flow::V0::Clients::Users.new(self)
        end

        def validations
          @validations ||= ::Io::Flow::V0::Clients::Validations.new(self)
        end
      end

      module Clients

        class Attributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search attributes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "key" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Attribute.new(x) }
          end

          # Add attribute
          def post(organization, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_json(attribute_form.to_json).post
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Returns information about a specific attribute.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Create or update an attribute with the specified key.
          def put_by_key(organization, key, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").with_json(attribute_form.to_json).put
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Delete an attribute with the specified key.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AttributeVersion.new(x) }
          end

        end

        class Catalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific catalog.
          def get_catalog(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog").get
            ::Io::Flow::V0::Models::Catalog.new(r)
          end

        end

        class Experiences

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search experiences. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :region => (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Experience.new(x) }
          end

          # Add experience
          def post(organization, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_json(experience_form.to_json).post
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Returns information about a specific experience.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Update experience with the specified key, creating if it does not exist.
          def put_by_key(organization, key, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").with_json(experience_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Delete the experience with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").delete
            nil
          end

          # Update the configuration of the price display for this experience.
          def put_price_display_by_key(organization, key, price_display)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('price_display', price_display, ::Io::Flow::V0::Models::PriceDisplay)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/price_display").with_json(price_display.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Compose items and prices. Always paginated.
          def get_items(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :from_country => (x = opts.delete(:from_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('from_country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperienceVersion.new(x) }
          end

        end

        class Items

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search items. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add catalog item(s)
          def post(organization, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about a specific item.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_by_number(organization, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the item with this number
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemVersion.new(x) }
          end

        end

        class Orders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search orders. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Order.new(x) }
          end

          # Create an order - the order must be booked (see bookings) before its
          # expiration
          def post(organization, order_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('order_form', order_form, ::Io::Flow::V0::Models::OrderForm)
            r = @client.request("/#{CGI.escape(organization)}/orders").with_json(order_form.to_json).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Returns information about a specific order.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Delete an order. Note that only orders that have not yet been booked may be
          # deleted.
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").delete
            nil
          end

          # Books an order. You will get a validation error if the order has already
          # expired (and a new quote could not be automatically recreated for a lower or
          # same price). This method is idempotent - booking an order a second time has
          # no effect.
          def put_bookings_by_number(organization, number, order_booking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('order_booking_form', order_booking_form, ::Io::Flow::V0::Models::OrderBookingForm)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/bookings").with_json(order_booking_form.to_json).put
            ::Io::Flow::V0::Models::OrderBooking.new(r)
          end

          # Provides visibility into recent changes of each order, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderVersion.new(x) }
          end

        end

        class Subcatalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalogs. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Subcatalog.new(x) }
          end

          # Add subcatalog
          def post(organization, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_json(subcatalog_form.to_json).post
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Returns information about a specific subcatalog.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Update subcatalog with the specified id, creating if it does not exist.
          def put_by_id(organization, id, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").with_json(subcatalog_form.to_json).put
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Delete the subcatalog with this id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").delete
            nil
          end

          # Sync subcatalog
          def post_events_by_id_and_event(organization, id, event, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('event', event, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/events/#{CGI.escape(event)}").with_json(hash.to_json).post
            nil
          end

          # Returns information about a specific subcatalog's settings.
          def get_settings_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").get
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Update subcatalog settings for the specified subcatalog.
          def put_settings_by_id(organization, id, subcatalog_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_settings_form', subcatalog_settings_form, ::Io::Flow::V0::Models::SubcatalogSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").with_json(subcatalog_settings_form.to_json).put
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Search exclusions. Always paginated.
          def get_exclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific exclusion by catalog item number.
          def get_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add exclusion
          def put_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an exclusion with this catalog item number
          def delete_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search inclusions. Always paginated.
          def get_inclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific inclusion by catalog item number.
          def get_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add inclusion
          def put_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an inclusion with this catalog item number
          def delete_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search queries. Always paginated.
          def get_queries_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, Array).map { |v| HttpClient::Preconditions.assert_class('type', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Query.new(x) }
          end

          # Add query
          def post_queries_by_subcatalog_id(organization, subcatalog_id, query_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('query_form', query_form, ::Io::Flow::V0::Models::QueryForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_json(query_form.to_json).post
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Returns information about a specific query.
          def get_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Delete a query with this id
          def delete_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class SubcatalogItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalog items. Always paginated.
          def get(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add subcatalog item
          def post(organization, subcatalog_id, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about specific subcatalog items.
          def get_by_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update subcatalog item with the specified number, creating if it does not
          # exist.
          def put_by_number(organization, subcatalog_id, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the subcatalog item with this number
          def delete_by_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class Functions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search functions. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :position => (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Array).map { |v| HttpClient::Preconditions.assert_class('position', v, Integer) }),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, Array).map { |v| HttpClient::Preconditions.assert_class('subcatalog', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Function.new(x) }
          end

          # Add function
          def post(organization, function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('function_form', function_form, ::Io::Flow::V0::Models::FunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/functions").with_json(function_form.to_json).post
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Returns information about a specific function.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Update function with the specified key, creating if it does not exist.
          def put_by_key(organization, key, function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('function_form', function_form, ::Io::Flow::V0::Models::FunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").with_json(function_form.to_json).put
            ::Io::Flow::V0::Models::Function.new(r)
          end

          # Delete the function with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/functions/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, Array).map { |v| HttpClient::Preconditions.assert_class('name', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::FunctionVersion.new(x) }
          end

        end

        class Duties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, origin, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('origin', origin, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => HttpClient::Preconditions.assert_class('number', opts.delete(:number), String),
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/duties/#{CGI.escape(origin)}").with_query(query).get
            ::Io::Flow::V0::Models::Duty.new(r)
          end

        end

        class HarmonizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").get
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

          def put(organization, harmonization_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonization_settings_form', harmonization_settings_form, ::Io::Flow::V0::Models::HarmonizationSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").with_json(harmonization_settings_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

        end

        class HarmonizedItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItem.new(x) }
          end

          def post(organization, harmonized_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_form', harmonized_item_form, ::Io::Flow::V0::Models::HarmonizedItemForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_json(harmonized_item_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          # Create or update an item to harmonize
          def put_by_number(organization, number, harmonized_item_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('harmonized_item_put_form', harmonized_item_put_form, ::Io::Flow::V0::Models::HarmonizedItemPutForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").with_json(harmonized_item_put_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_id => (x = opts.delete(:item_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemVersion.new(x) }
          end

        end

        class HarmonizedItemDuties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x) }
          end

          def post(organization, harmonized_item_duty_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_duty_form', harmonized_item_duty_form, ::Io::Flow::V0::Models::HarmonizedItemDutyForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_json(harmonized_item_duty_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :harmonized_item_duty_id => (x = opts.delete(:harmonized_item_duty_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('harmonized_item_duty_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('harmonized_item_duty_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDutyVersion.new(x) }
          end

        end

        class Hs10

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs10_id => (x = opts.delete(:hs10_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs10_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10Version.new(x) }
          end

        end

        class Hs6

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs6_id => (x = opts.delete(:hs6_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs6_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6Version.new(x) }
          end

        end

        class Taxes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/taxes").with_query(query).get
            ::Io::Flow::V0::Models::Tax.new(r)
          end

        end

        class Authorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Authorization.new(x) }
          end

          # Create a new authorization.
          def post(organization, authorization_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('authorization_form', authorization_form, ::Io::Flow::V0::Models::AuthorizationForm)
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Returns information about a specific authorization.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Authorization.new(r)
          end

          # Deletes a given authorization. This method will return a 422 if funds have
          # already been captured.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AuthorizationVersion.new(x) }
          end

        end

        class Captures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Capture.new(x) }
          end

          # Create a new capture.
          def post(organization, capture_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('capture_form', capture_form, ::Io::Flow::V0::Models::CaptureForm)
            r = @client.request("/#{CGI.escape(organization)}/captures").with_json(capture_form.to_json).post
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Returns information about a specific capture.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('capture_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureVersion.new(x) }
          end

        end

        class Cards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Card.new(x) }
          end

          # Create a new card.
          def post(organization, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Returns information about a specific card.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Deletes the card with the specified ID.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}").delete
            nil
          end

          # Updates are implemented as copy on write. This method is a convenience
          # method that will transactionally DELETE the card with the specified ID, then
          # CREATE a new card with the data from this request. Note that this means the
          # returned credit card token will be DIFFERENT from the one used in the
          # request.
          def post_updates_by_id(organization, id, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(id)}/updates").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :card_id => (x = opts.delete(:card_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardVersion.new(x) }
          end

        end

        class Refunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :reference => (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, Array).map { |v| HttpClient::Preconditions.assert_class('reference', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_reference => (x = opts.delete(:authorization_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_reference', x, String)),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String)),
              :capture_reference => (x = opts.delete(:capture_reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_reference', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Refund.new(x) }
          end

          # Create a new refund.
          def post(organization, refund_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('refund_form', refund_form, ::Io::Flow::V0::Models::RefundForm)
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_json(refund_form.to_json).post
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns information about a specific refund.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :refund_id => (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('refund_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundVersion.new(x) }
          end

        end

        class Bookings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Booking.new(x) }
          end

          def post(organization, booking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('booking_form', booking_form, ::Io::Flow::V0::Models::BookingForm)
            r = @client.request("/#{CGI.escape(organization)}/bookings").with_json(booking_form.to_json).post
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/bookings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Booking.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :booking => (x = opts.delete(:booking); x.nil? ? nil : HttpClient::Preconditions.assert_class('booking', x, Array).map { |v| HttpClient::Preconditions.assert_class('booking', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/bookings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::BookingVersion.new(x) }
          end

        end

        class Carriers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Carrier.new(x) }
          end

          def post(carrier_form)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers").with_json(carrier_form.to_json).post
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def put_by_id(id, carrier_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_form', carrier_form, ::Io::Flow::V0::Models::CarrierForm)
            r = @client.request("/carriers/#{CGI.escape(id)}").with_json(carrier_form.to_json).put
            ::Io::Flow::V0::Models::Carrier.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/carriers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier => (x = opts.delete(:carrier); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/carriers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierVersion.new(x) }
          end

        end

        class CarrierAccounts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccount.new(x) }
          end

          def post(organization, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts").with_json(carrier_account_form.to_json).post
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def put_by_id(organization, id, carrier_account_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('carrier_account_form', carrier_account_form, ::Io::Flow::V0::Models::CarrierAccountForm)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").with_json(carrier_account_form.to_json).put
            ::Io::Flow::V0::Models::CarrierAccount.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_account => (x = opts.delete(:carrier_account); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_account', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_account', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/carrier_accounts/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CarrierAccountVersion.new(x) }
          end

        end

        class Centers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def post(organization, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers").with_json(center_form.to_json).post
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def put_by_id(organization, id, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").with_json(center_form.to_json).put
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CenterVersion.new(x) }
          end

        end

        class DeliveryWindows

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to request a delivery window. Requires some knowledge of origin
          # (based on organization, center, or specified address string) and destination
          # (based on ip, lat/long, or address string). Other attributes allow us to
          # narrow down delivery windows even more such as service level to be used and
          # timestamp of expected shipment date.
          def get_summary(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :strategy => (x = (x = opts.delete(:strategy); x.nil? ? "range" : x); x.is_a?(::Io::Flow::V0::Models::Strategy) ? x : ::Io::Flow::V0::Models::Strategy.apply(x)).value,
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/delivery-windows/summary").with_query(query).get
            ::Io::Flow::V0::Models::DeliveryWindow.new(r)
          end

        end

        class InventoryRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRule.new(x) }
          end

          def post(organization, inventory_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_rule_form', inventory_rule_form, ::Io::Flow::V0::Models::InventoryRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_json(inventory_rule_form.to_json).post
            ::Io::Flow::V0::Models::InventoryRule.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRuleVersion.new(x) }
          end

        end

        class InventorySnapshots

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item => (x = opts.delete(:item); x.nil? ? nil : HttpClient::Preconditions.assert_class('item', x, Array).map { |v| HttpClient::Preconditions.assert_class('item', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshot.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventorySnapshot.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_snapshot => (x = opts.delete(:inventory_snapshot); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_snapshot', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_snapshot', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshotVersion.new(x) }
          end

        end

        class InventoryUpdates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item => (x = opts.delete(:item); x.nil? ? nil : HttpClient::Preconditions.assert_class('item', x, Array).map { |v| HttpClient::Preconditions.assert_class('item', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdate.new(x) }
          end

          def post(organization, inventory_update_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_update_form', inventory_update_form, ::Io::Flow::V0::Models::InventoryUpdateForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_json(inventory_update_form.to_json).post
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_update => (x = opts.delete(:inventory_update); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_update', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_update', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdateVersion.new(x) }
          end

        end

        class Labels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Label.new(x) }
          end

          def post(organization, label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('label_form', label_form, ::Io::Flow::V0::Models::LabelForm)
            r = @client.request("/#{CGI.escape(organization)}/labels").with_json(label_form.to_json).post
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Label.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelVersion.new(x) }
          end

        end

        class LabelEvents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :label_id => (x = opts.delete(:label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/label_events").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelEvent.new(x) }
          end

          def get_by_id(organization, id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/label_events/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::LabelEvent.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label_event_id => (x = opts.delete(:label_event_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('label_event_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('label_event_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/label_events/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LabelEventVersion.new(x) }
          end

        end

        class Lanes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, Array).map { |v| HttpClient::Preconditions.assert_class('origin', v, String) }),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, Array).map { |v| HttpClient::Preconditions.assert_class('destination', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Lane.new(x) }
          end

          def post(lane_form)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes").with_json(lane_form.to_json).post
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def put_by_id(id, lane_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('lane_form', lane_form, ::Io::Flow::V0::Models::LaneForm)
            r = @client.request("/lanes/#{CGI.escape(id)}").with_json(lane_form.to_json).put
            ::Io::Flow::V0::Models::Lane.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/lanes/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :lane => (x = opts.delete(:lane); x.nil? ? nil : HttpClient::Preconditions.assert_class('lane', x, Array).map { |v| HttpClient::Preconditions.assert_class('lane', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/lanes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::LaneVersion.new(x) }
          end

        end

        class Quotes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search quotes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def post(organization, quote_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('quote_form', quote_form, ::Io::Flow::V0::Models::QuoteForm)
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_json(quote_form.to_json).post
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/quotes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :quote => (x = opts.delete(:quote); x.nil? ? nil : HttpClient::Preconditions.assert_class('quote', x, Array).map { |v| HttpClient::Preconditions.assert_class('quote', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::QuoteVersion.new(x) }
          end

        end

        class Services

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Service.new(x) }
          end

          def post(service_form)
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services").with_json(service_form.to_json).post
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/services/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def put_by_id(id, service_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('service_form', service_form, ::Io::Flow::V0::Models::ServiceForm)
            r = @client.request("/services/#{CGI.escape(id)}").with_json(service_form.to_json).put
            ::Io::Flow::V0::Models::Service.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/services/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/services/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ServiceVersion.new(x) }
          end

        end

        class Shipments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Shipment.new(x) }
          end

          def post(organization, shipment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('shipment_form', shipment_form, ::Io::Flow::V0::Models::ShipmentForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments").with_json(shipment_form.to_json).post
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Shipment.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentVersion.new(x) }
          end

        end

        class ShipmentLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabel.new(x) }
          end

          def post(organization, tracking_number, shipment_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            HttpClient::Preconditions.assert_class('shipment_label_form', shipment_label_form, ::Io::Flow::V0::Models::ShipmentLabelForm)
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels").with_json(shipment_label_form.to_json).post
            ::Io::Flow::V0::Models::ShipmentLabel.new(r)
          end

          def get_versions(organization, tracking_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_number', tracking_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipments/#{CGI.escape(tracking_number)}/labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShipmentLabelVersion.new(x) }
          end

        end

        class Tiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tier.new(x) }
          end

          def post(organization, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_json(tier_form.to_json).post
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def put_by_id(organization, id, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").with_json(tier_form.to_json).put
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier => (x = opts.delete(:tier); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierVersion.new(x) }
          end

        end

        class Trackings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tracking.new(x) }
          end

          def post(organization, tracking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_form', tracking_form, ::Io::Flow::V0::Models::TrackingForm)
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_json(tracking_form.to_json).post
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/trackings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingVersion.new(x) }
          end

        end

        class Countries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of countries.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

        end

        class Currencies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of currencies.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/currencies").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

        end

        class Languages

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of languages.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/languages").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Language.new(x) }
          end

        end

        class Regions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of regions.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/regions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Region.new(x) }
          end

          # Returns the region with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/regions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Region.new(r)
          end

        end

        class Timezones

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of timezones.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

        end

        class Documents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns items based on search criteria
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :attributes => (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Array).map { |v| HttpClient::Preconditions.assert_class('attributes', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogItemDocument.new(x) }
          end

          # Returns harmonization information based on search criteria
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizationDocument.new(x) }
          end

        end

        class EmailVerifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_token(token, hash)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/users/emails/verifications/#{CGI.escape(token)}").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::EmailVerification.new(r)
          end

        end

        class Healthchecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_healthcheck
            r = @client.request("/_internal_/healthcheck").get
            ::Io::Flow::V0::Models::Healthcheck.new(r)
          end

        end

        class Invitations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search invitations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Invitation.new(x) }
          end

          # Create a new invitation.
          def post(invitation_form)
            HttpClient::Preconditions.assert_class('invitation_form', invitation_form, ::Io::Flow::V0::Models::InvitationForm)
            r = @client.request("/invitations").with_json(invitation_form.to_json).post
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Returns information about a specific invitation.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/invitations/#{CGI.escape(id)}").delete
            nil
          end

          # Lookup an invitation by its token.
          def get_tokens_by_token(token, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Accepts the invitation w/ the specified token, creating a membership record
          # for this user within this organization. Invitations are one time use only -
          # you will get a validation error if the invitation has previously been
          # accepted.
          def put_tokens_by_token(token, invitation_accepts_form)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('invitation_accepts_form', invitation_accepts_form, ::Io::Flow::V0::Models::InvitationAcceptsForm)
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_json(invitation_accepts_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :invitation => (x = opts.delete(:invitation); x.nil? ? nil : HttpClient::Preconditions.assert_class('invitation', x, Array).map { |v| HttpClient::Preconditions.assert_class('invitation', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InvitationVersion.new(x) }
          end

        end

        class Locations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Based on the provided location parameters, returns a list of the best
          # potential matching addresses.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/locations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Location.new(x) }
          end

        end

        class Memberships

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search memberships. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Membership.new(x) }
          end

          # Create a new membership.
          def post(membership_form)
            HttpClient::Preconditions.assert_class('membership_form', membership_form, ::Io::Flow::V0::Models::MembershipForm)
            r = @client.request("/memberships").with_json(membership_form.to_json).post
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Returns information about a specific membership.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Change the role for a specific membership record. If the user already has
          # the specified role within the organization, does nothing.
          def put_by_id(id, membership_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('membership_put_form', membership_put_form, ::Io::Flow::V0::Models::MembershipPutForm)
            r = @client.request("/memberships/#{CGI.escape(id)}").with_json(membership_put_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/memberships/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :membership => (x = opts.delete(:membership); x.nil? ? nil : HttpClient::Preconditions.assert_class('membership', x, Array).map { |v| HttpClient::Preconditions.assert_class('membership', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::MembershipVersion.new(x) }
          end

        end

        class Organizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organizations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :environment => (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)).value),
              :parent => (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Organization.new(x) }
          end

          # Create a new organization.
          def post(organization_form)
            HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Io::Flow::V0::Models::OrganizationForm)
            r = @client.request("/organizations").with_json(organization_form.to_json).post
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Returns information about a specific organization.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Update or create an organization with the specified id.
          def put_by_id(id, organization_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('organization_put_form', organization_put_form, ::Io::Flow::V0::Models::OrganizationPutForm)
            r = @client.request("/organizations/#{CGI.escape(id)}").with_json(organization_put_form.to_json).put
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Delete the organization with this id
          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationVersion.new(x) }
          end

        end

        class OrganizationAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # For the authorized user, if the specified organization exists, and the user
          # is an active member of this organization, returns the authorization data
          # used throughout APIs at Flow, including the user's role in that organization
          # and the organization environment. Otherwise, returns 401 - this indicates
          # either the org does not exist or the user does not have access to the org.
          def get_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/organization-authorizations/#{CGI.escape(organization)}").get
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

        end

        class PasswordResetForms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(password_reset_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('password_reset_form', password_reset_form, ::Io::Flow::V0::Models::PasswordResetForm)
            r = @client.request("/users/passwords").with_query(query).with_json(password_reset_form.to_json).post
            ::Io::Flow::V0::Models::ExpandableUser.from_json(r)
          end

          def post_resets(password_reset_request_form)
            HttpClient::Preconditions.assert_class('password_reset_request_form', password_reset_request_form, ::Io::Flow::V0::Models::PasswordResetRequestForm)
            r = @client.request("/users/passwords/resets").with_json(password_reset_request_form.to_json).post
            nil
          end

        end

        class Suggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-count" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

          # Returns search suggestions for harmonization data
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

        end

        class Tokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens that you are authorized to view. Note that the cleartext
          # token value is never sent. To view the API token itself, see the resource
          # path /:id/cleartext
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Token.new(x) }
          end

          # Create a new token for the requesting user
          def post(token_form)
            HttpClient::Preconditions.assert_class('token_form', token_form, ::Io::Flow::V0::Models::TokenForm)
            r = @client.request("/tokens").with_json(token_form.to_json).post
            ::Io::Flow::V0::Models::Token.new(r)
          end

          # Get metadata for the token with this ID
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Token.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Retrieves the token with the actual string token in cleartext
          def get_cleartext_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}/cleartext").get
            ::Io::Flow::V0::Models::Cleartext.new(r)
          end

          # Preferred method to validate a token, obtaining user information if the
          # token is valid (or a 404 if the token does not exist). We use an HTTP POST
          # with a form body to enusre that the token itself is not logged in the
          # request logs.
          def post_authentications(token_authentication_form)
            HttpClient::Preconditions.assert_class('token_authentication_form', token_authentication_form, ::Io::Flow::V0::Models::TokenAuthenticationForm)
            r = @client.request("/tokens/authentications").with_json(token_authentication_form.to_json).post
            ::Io::Flow::V0::Models::TokenReference.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token_id => (x = opts.delete(:token_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('token_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('token_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TokenVersion.new(x) }
          end

        end

        class Users

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search users. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::User.new(x) }
          end

          # Create a new user.
          def post(user_form)
            HttpClient::Preconditions.assert_class('user_form', user_form, ::Io::Flow::V0::Models::UserForm)
            r = @client.request("/users").with_json(user_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Returns information about a specific user.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update a user.
          def put_by_id(id, user_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('user_put_form', user_put_form, ::Io::Flow::V0::Models::UserPutForm)
            r = @client.request("/users/#{CGI.escape(id)}").with_json(user_put_form.to_json).put
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update the password for a user.
          def patch_passwords_by_id(id, password_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('password_change_form', password_change_form, ::Io::Flow::V0::Models::PasswordChangeForm)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").with_json(password_change_form.to_json).patch
            nil
          end

          # Deletes a password for the given user.
          def delete_passwords_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").delete
            nil
          end

          # Authenticates a user by email / password.
          def post_authenticate(authentication_form)
            HttpClient::Preconditions.assert_class('authentication_form', authentication_form, ::Io::Flow::V0::Models::AuthenticationForm)
            r = @client.request("/users/authenticate").with_json(authentication_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user_id => (x = opts.delete(:user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('user_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::UserVersion.new(x) }
          end

        end

        class Validations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(validation_form)
            HttpClient::Preconditions.assert_class('validation_form', validation_form, ::Io::Flow::V0::Models::ValidationForm)
            r = @client.request("/token-validations").with_json(validation_form.to_json).post
            ::Io::Flow::V0::Models::Validation.new(r)
          end

        end

      end

      module Models

        # Cost variation used to calculate localized prices
        class Adjustment

          module Types
            MARGIN = 'margin' unless defined?(MARGIN)
            ROUNDING = 'rounding' unless defined?(ROUNDING)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Adjustment')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Adjustment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::MARGIN; Margin.new(hash)
              when Types::ROUNDING; Rounding.new(hash)
              else AdjustmentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class AdjustmentUndefinedType < Adjustment

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents all possible responses from an authorization attempt
        class AuthorizationDetails

          module Types
            AUTHORIZATION_DETAILS_DECLINE = 'authorization_details_decline' unless defined?(AUTHORIZATION_DETAILS_DECLINE)
            AUTHORIZATION_DETAILS_SUCCESS = 'authorization_details_success' unless defined?(AUTHORIZATION_DETAILS_SUCCESS)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'AuthorizationDetails')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def AuthorizationDetails.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::AUTHORIZATION_DETAILS_DECLINE; AuthorizationDetailsDecline.new(hash)
              when Types::AUTHORIZATION_DETAILS_SUCCESS; AuthorizationDetailsSuccess.new(hash)
              else AuthorizationDetailsUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class AuthorizationDetailsUndefinedType < AuthorizationDetails

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Deminimus

          module Types
            DEMINIMUS_SIMPLE = 'deminimus_simple' unless defined?(DEMINIMUS_SIMPLE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Deminimus')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Deminimus.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::DEMINIMUS_SIMPLE; DeminimusSimple.new(hash)
              else DeminimusUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DeminimusUndefinedType < Deminimus

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Document

          module Types
            CATALOG_ITEM_DOCUMENT = 'catalog_item_document' unless defined?(CATALOG_ITEM_DOCUMENT)
            HARMONIZATION_DOCUMENT = 'harmonization_document' unless defined?(HARMONIZATION_DOCUMENT)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Document')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def Document.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::CATALOG_ITEM_DOCUMENT; CatalogItemDocument.new(hash)
              when Types::HARMONIZATION_DOCUMENT; HarmonizationDocument.new(hash)
              else DocumentUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class DocumentUndefinedType < Document

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A function can be represented with just it's ID, or the entire model
        class ExpandableFunction

          module Types
            FUNCTION = 'function' unless defined?(FUNCTION)
            FUNCTION_REFERENCE = 'function_reference' unless defined?(FUNCTION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableFunction')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableFunction.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::FUNCTION; Function.new(hash)
              when Types::FUNCTION_REFERENCE; FunctionReference.new(hash)
              else ExpandableFunctionUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableFunctionUndefinedType < ExpandableFunction

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableLocation

          module Types
            LOCATION = 'location' unless defined?(LOCATION)
            LOCATION_REFERENCE = 'location_reference' unless defined?(LOCATION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableLocation')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableLocation.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::LOCATION; Location.new(hash)
              when Types::LOCATION_REFERENCE; LocationReference.new(hash)
              else ExpandableLocationUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableLocationUndefinedType < ExpandableLocation

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrganization

          module Types
            ORGANIZATION = 'organization' unless defined?(ORGANIZATION)
            ORGANIZATION_REFERENCE = 'organization_reference' unless defined?(ORGANIZATION_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableOrganization')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableOrganization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::ORGANIZATION; Organization.new(hash)
              when Types::ORGANIZATION_REFERENCE; OrganizationReference.new(hash)
              else ExpandableOrganizationUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableOrganizationUndefinedType < ExpandableOrganization

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A subcatalog can be represented with just it's ID, or the entire model
        class ExpandableSubcatalog

          module Types
            SUBCATALOG = 'subcatalog' unless defined?(SUBCATALOG)
            SUBCATALOG_REFERENCE = 'subcatalog_reference' unless defined?(SUBCATALOG_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableSubcatalog')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableSubcatalog.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::SUBCATALOG; Subcatalog.new(hash)
              when Types::SUBCATALOG_REFERENCE; SubcatalogReference.new(hash)
              else ExpandableSubcatalogUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableSubcatalogUndefinedType < ExpandableSubcatalog

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableUser

          module Types
            USER = 'user' unless defined?(USER)
            USER_REFERENCE = 'user_reference' unless defined?(USER_REFERENCE)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'ExpandableUser')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def ExpandableUser.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::USER; User.new(hash)
              when Types::USER_REFERENCE; UserReference.new(hash)
              else ExpandableUserUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class ExpandableUserUndefinedType < ExpandableUser

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Types of rules used to apply on inventory to calculate available quantity
        class InventoryStrategy

          module Types
            # Enables backorders, setting an optional number of units that we allow for
            # backorder. For example, a backorder w/ quantity 10 will enable selling until
            # the actual inventory quantity is -10.
            INVENTORY_BACKORDER = 'inventory_backorder' unless defined?(INVENTORY_BACKORDER)
            # Treats inventory as available as long as the actual inventory quantity is >
            # the specified quantity. A common use case is to set quantity to zero to
            # indicate availability as long as there is at least 1 unit available.
            INVENTORY_STOCK = 'inventory_stock' unless defined?(INVENTORY_STOCK)
            # Items affected with rules pursuing an unlimited strategy will always be
            # available
            INVENTORY_UNLIMITED = 'inventory_unlimited' unless defined?(INVENTORY_UNLIMITED)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'InventoryStrategy')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def InventoryStrategy.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::INVENTORY_BACKORDER; InventoryBackorder.new(hash)
              when Types::INVENTORY_STOCK; InventoryStock.new(hash)
              when Types::INVENTORY_UNLIMITED; InventoryUnlimited.new(hash)
              else InventoryStrategyUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class InventoryStrategyUndefinedType < InventoryStrategy

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Possible outcome types from a tier rule
        class TierRuleOutcome

          module Types
            # Add a certain amount on the actual base cost
            AMOUNT_MARGIN = 'amount_margin' unless defined?(AMOUNT_MARGIN)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            FLAT_RATE = 'flat_rate' unless defined?(FLAT_RATE)
            FREE_SHIPPING = 'free_shipping' unless defined?(FREE_SHIPPING)
            # Add a certain percentage of the actual base cost
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'TierRuleOutcome')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @name)
          end

          def TierRuleOutcome.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            case HttpClient::Helper.symbolize_keys(hash)[:discriminator]
              when Types::AMOUNT_MARGIN; AmountMargin.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::FLAT_RATE; FlatRate.new(hash)
              when Types::FREE_SHIPPING; FreeShipping.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeUndefinedType.new(:name => union_type_name)
            end
          end

        end

        class TierRuleOutcomeUndefinedType < TierRuleOutcome

          attr_reader :name

          def initialize(incoming={})
            super(:name => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AdjustmentType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AdjustmentType for this value, creating a new instance for an unknown value
          def AdjustmentType.apply(value)
            if value.instance_of?(AdjustmentType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AdjustmentType.new(value))
            end
          end

          # Returns the instance of AdjustmentType for this value, or nil if not found
          def AdjustmentType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AdjustmentType.ALL.find { |v| v.value == value }
          end

          def AdjustmentType.ALL
            @@all ||= [AdjustmentType.fixed_margin, AdjustmentType.percent_margin, AdjustmentType.round]
          end

          def AdjustmentType.fixed_margin
            @@_fixed_margin ||= AdjustmentType.new('fixed_margin')
          end

          def AdjustmentType.percent_margin
            @@_percent_margin ||= AdjustmentType.new('percent_margin')
          end

          def AdjustmentType.round
            @@_round ||= AdjustmentType.new('round')
          end

          def to_hash
            value
          end

        end

        class Calendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Calendar for this value, creating a new instance for an unknown value
          def Calendar.apply(value)
            if value.instance_of?(Calendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Calendar.new(value))
            end
          end

          # Returns the instance of Calendar for this value, or nil if not found
          def Calendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Calendar.ALL.find { |v| v.value == value }
          end

          def Calendar.ALL
            @@all ||= [Calendar.weekdays, Calendar.everyday]
          end

          # Mon - Fri
          def Calendar.weekdays
            @@_weekdays ||= Calendar.new('weekdays')
          end

          # 7 days per week
          def Calendar.everyday
            @@_everyday ||= Calendar.new('everyday')
          end

          def to_hash
            value
          end

        end

        class Capability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Capability for this value, creating a new instance for an unknown value
          def Capability.apply(value)
            if value.instance_of?(Capability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Capability.new(value))
            end
          end

          # Returns the instance of Capability for this value, or nil if not found
          def Capability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Capability.ALL.find { |v| v.value == value }
          end

          def Capability.ALL
            @@all ||= [Capability.crossdock]
          end

          def Capability.crossdock
            @@_crossdock ||= Capability.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class CardType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardType for this value, creating a new instance for an unknown value
          def CardType.apply(value)
            if value.instance_of?(CardType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardType.new(value))
            end
          end

          # Returns the instance of CardType for this value, or nil if not found
          def CardType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardType.ALL.find { |v| v.value == value }
          end

          def CardType.ALL
            @@all ||= [CardType.visa, CardType.mastercard, CardType.american_express, CardType.diners_club, CardType.discover, CardType.jcb, CardType.china_union_pay]
          end

          def CardType.visa
            @@_visa ||= CardType.new('visa')
          end

          def CardType.mastercard
            @@_mastercard ||= CardType.new('mastercard')
          end

          def CardType.american_express
            @@_american_express ||= CardType.new('american_express')
          end

          def CardType.diners_club
            @@_diners_club ||= CardType.new('diners_club')
          end

          def CardType.discover
            @@_discover ||= CardType.new('discover')
          end

          def CardType.jcb
            @@_jcb ||= CardType.new('jcb')
          end

          def CardType.china_union_pay
            @@_china_union_pay ||= CardType.new('china_union_pay')
          end

          def to_hash
            value
          end

        end

        class ChangeType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ChangeType for this value, creating a new instance for an unknown value
          def ChangeType.apply(value)
            if value.instance_of?(ChangeType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ChangeType.new(value))
            end
          end

          # Returns the instance of ChangeType for this value, or nil if not found
          def ChangeType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ChangeType.ALL.find { |v| v.value == value }
          end

          def ChangeType.ALL
            @@all ||= [ChangeType.insert, ChangeType.update, ChangeType.delete]
          end

          def ChangeType.insert
            @@_insert ||= ChangeType.new('insert')
          end

          def ChangeType.update
            @@_update ||= ChangeType.new('update')
          end

          def ChangeType.delete
            @@_delete ||= ChangeType.new('delete')
          end

          def to_hash
            value
          end

        end

        class DeliveredDuty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDuty for this value, creating a new instance for an unknown value
          def DeliveredDuty.apply(value)
            if value.instance_of?(DeliveredDuty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDuty.new(value))
            end
          end

          # Returns the instance of DeliveredDuty for this value, or nil if not found
          def DeliveredDuty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDuty.ALL.find { |v| v.value == value }
          end

          def DeliveredDuty.ALL
            @@all ||= [DeliveredDuty.paid, DeliveredDuty.unpaid]
          end

          def DeliveredDuty.paid
            @@_paid ||= DeliveredDuty.new('paid')
          end

          def DeliveredDuty.unpaid
            @@_unpaid ||= DeliveredDuty.new('unpaid')
          end

          def to_hash
            value
          end

        end

        class Environment

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Environment for this value, creating a new instance for an unknown value
          def Environment.apply(value)
            if value.instance_of?(Environment)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Environment.new(value))
            end
          end

          # Returns the instance of Environment for this value, or nil if not found
          def Environment.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Environment.ALL.find { |v| v.value == value }
          end

          def Environment.ALL
            @@all ||= [Environment.sandbox, Environment.production]
          end

          # In sandbox, no external services (e.g. payments, logistics) will generate real
          # transactions
          def Environment.sandbox
            @@_sandbox ||= Environment.new('sandbox')
          end

          # In production, all external services are live and will generate real
          # transactions
          def Environment.production
            @@_production ||= Environment.new('production')
          end

          def to_hash
            value
          end

        end

        class ExceptionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExceptionType for this value, creating a new instance for an unknown value
          def ExceptionType.apply(value)
            if value.instance_of?(ExceptionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExceptionType.new(value))
            end
          end

          # Returns the instance of ExceptionType for this value, or nil if not found
          def ExceptionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExceptionType.ALL.find { |v| v.value == value }
          end

          def ExceptionType.ALL
            @@all ||= [ExceptionType.open, ExceptionType.closed]
          end

          def ExceptionType.open
            @@_open ||= ExceptionType.new('open')
          end

          def ExceptionType.closed
            @@_closed ||= ExceptionType.new('closed')
          end

          def to_hash
            value
          end

        end

        class HolidayCalendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of HolidayCalendar for this value, creating a new instance for an unknown value
          def HolidayCalendar.apply(value)
            if value.instance_of?(HolidayCalendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || HolidayCalendar.new(value))
            end
          end

          # Returns the instance of HolidayCalendar for this value, or nil if not found
          def HolidayCalendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            HolidayCalendar.ALL.find { |v| v.value == value }
          end

          def HolidayCalendar.ALL
            @@all ||= [HolidayCalendar.us_bank_holidays, HolidayCalendar.jewish_holidays]
          end

          def HolidayCalendar.us_bank_holidays
            @@_us_bank_holidays ||= HolidayCalendar.new('us_bank_holidays')
          end

          def HolidayCalendar.jewish_holidays
            @@_jewish_holidays ||= HolidayCalendar.new('jewish_holidays')
          end

          def to_hash
            value
          end

        end

        class Levy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Levy for this value, creating a new instance for an unknown value
          def Levy.apply(value)
            if value.instance_of?(Levy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Levy.new(value))
            end
          end

          # Returns the instance of Levy for this value, or nil if not found
          def Levy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Levy.ALL.find { |v| v.value == value }
          end

          def Levy.ALL
            @@all ||= [Levy.duty, Levy.shipping, Levy.vat]
          end

          def Levy.duty
            @@_duty ||= Levy.new('duty')
          end

          def Levy.shipping
            @@_shipping ||= Levy.new('shipping')
          end

          # Value-Added Tax
          def Levy.vat
            @@_vat ||= Levy.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyComponent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyComponent for this value, creating a new instance for an unknown value
          def LevyComponent.apply(value)
            if value.instance_of?(LevyComponent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyComponent.new(value))
            end
          end

          # Returns the instance of LevyComponent for this value, or nil if not found
          def LevyComponent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyComponent.ALL.find { |v| v.value == value }
          end

          def LevyComponent.ALL
            @@all ||= [LevyComponent.goods, LevyComponent.duty, LevyComponent.insurance, LevyComponent.freight, LevyComponent.vat]
          end

          # The value of goods
          def LevyComponent.goods
            @@_goods ||= LevyComponent.new('goods')
          end

          def LevyComponent.duty
            @@_duty ||= LevyComponent.new('duty')
          end

          def LevyComponent.insurance
            @@_insurance ||= LevyComponent.new('insurance')
          end

          def LevyComponent.freight
            @@_freight ||= LevyComponent.new('freight')
          end

          # Value-Added Tax
          def LevyComponent.vat
            @@_vat ||= LevyComponent.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyStrategy for this value, creating a new instance for an unknown value
          def LevyStrategy.apply(value)
            if value.instance_of?(LevyStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyStrategy.new(value))
            end
          end

          # Returns the instance of LevyStrategy for this value, or nil if not found
          def LevyStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyStrategy.ALL.find { |v| v.value == value }
          end

          def LevyStrategy.ALL
            @@all ||= [LevyStrategy.minimum, LevyStrategy.average, LevyStrategy.maximum]
          end

          def LevyStrategy.minimum
            @@_minimum ||= LevyStrategy.new('minimum')
          end

          def LevyStrategy.average
            @@_average ||= LevyStrategy.new('average')
          end

          def LevyStrategy.maximum
            @@_maximum ||= LevyStrategy.new('maximum')
          end

          def to_hash
            value
          end

        end

        class MeasurementSystem

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MeasurementSystem for this value, creating a new instance for an unknown value
          def MeasurementSystem.apply(value)
            if value.instance_of?(MeasurementSystem)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MeasurementSystem.new(value))
            end
          end

          # Returns the instance of MeasurementSystem for this value, or nil if not found
          def MeasurementSystem.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MeasurementSystem.ALL.find { |v| v.value == value }
          end

          def MeasurementSystem.ALL
            @@all ||= [MeasurementSystem.imperial, MeasurementSystem.metric]
          end

          def MeasurementSystem.imperial
            @@_imperial ||= MeasurementSystem.new('imperial')
          end

          def MeasurementSystem.metric
            @@_metric ||= MeasurementSystem.new('metric')
          end

          def to_hash
            value
          end

        end

        class QueryType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QueryType for this value, creating a new instance for an unknown value
          def QueryType.apply(value)
            if value.instance_of?(QueryType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QueryType.new(value))
            end
          end

          # Returns the instance of QueryType for this value, or nil if not found
          def QueryType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QueryType.ALL.find { |v| v.value == value }
          end

          def QueryType.ALL
            @@all ||= [QueryType.exclusion, QueryType.inclusion]
          end

          # Exclude items satisfied by the associated query
          def QueryType.exclusion
            @@_exclusion ||= QueryType.new('exclusion')
          end

          # Include items satisfied by the associated query
          def QueryType.inclusion
            @@_inclusion ||= QueryType.new('inclusion')
          end

          def to_hash
            value
          end

        end

        class Role

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Role for this value, creating a new instance for an unknown value
          def Role.apply(value)
            if value.instance_of?(Role)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Role.new(value))
            end
          end

          # Returns the instance of Role for this value, or nil if not found
          def Role.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Role.ALL.find { |v| v.value == value }
          end

          def Role.ALL
            @@all ||= [Role.admin, Role.member]
          end

          def Role.admin
            @@_admin ||= Role.new('admin')
          end

          def Role.member
            @@_member ||= Role.new('member')
          end

          def to_hash
            value
          end

        end

        class RoundingMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingMethod for this value, creating a new instance for an unknown value
          def RoundingMethod.apply(value)
            if value.instance_of?(RoundingMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingMethod.new(value))
            end
          end

          # Returns the instance of RoundingMethod for this value, or nil if not found
          def RoundingMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingMethod.ALL.find { |v| v.value == value }
          end

          def RoundingMethod.ALL
            @@all ||= [RoundingMethod.up, RoundingMethod.down, RoundingMethod.nearest]
          end

          # Round up to the specified rounding.value
          def RoundingMethod.up
            @@_up ||= RoundingMethod.new('up')
          end

          # Round down to the specified rounding.value
          def RoundingMethod.down
            @@_down ||= RoundingMethod.new('down')
          end

          # Round to the nearest specified rounding.value. If equidistant, will round up.
          def RoundingMethod.nearest
            @@_nearest ||= RoundingMethod.new('nearest')
          end

          def to_hash
            value
          end

        end

        class ScheduleExceptionStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ScheduleExceptionStatus for this value, creating a new instance for an unknown value
          def ScheduleExceptionStatus.apply(value)
            if value.instance_of?(ScheduleExceptionStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ScheduleExceptionStatus.new(value))
            end
          end

          # Returns the instance of ScheduleExceptionStatus for this value, or nil if not found
          def ScheduleExceptionStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ScheduleExceptionStatus.ALL.find { |v| v.value == value }
          end

          def ScheduleExceptionStatus.ALL
            @@all ||= [ScheduleExceptionStatus.open, ScheduleExceptionStatus.closed]
          end

          def ScheduleExceptionStatus.open
            @@_open ||= ScheduleExceptionStatus.new('Open')
          end

          def ScheduleExceptionStatus.closed
            @@_closed ||= ScheduleExceptionStatus.new('Closed')
          end

          def to_hash
            value
          end

        end

        class ShipmentIntegrationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShipmentIntegrationType for this value, creating a new instance for an unknown value
          def ShipmentIntegrationType.apply(value)
            if value.instance_of?(ShipmentIntegrationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShipmentIntegrationType.new(value))
            end
          end

          # Returns the instance of ShipmentIntegrationType for this value, or nil if not found
          def ShipmentIntegrationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShipmentIntegrationType.ALL.find { |v| v.value == value }
          end

          def ShipmentIntegrationType.ALL
            @@all ||= [ShipmentIntegrationType.direct, ShipmentIntegrationType.information, ShipmentIntegrationType.preadvice]
          end

          # Always generate a label for the chosen delivery option.
          def ShipmentIntegrationType.direct
            @@_direct ||= ShipmentIntegrationType.new('direct')
          end

          # Booking and label generation is not available. Just use Flow to calculate
          # delivery window estimates and shipment prices to display.
          def ShipmentIntegrationType.information
            @@_information ||= ShipmentIntegrationType.new('information')
          end

          # A generic label will be provided by the client organization when available as
          # pre-advice shipment notification to carrier partner.
          def ShipmentIntegrationType.preadvice
            @@_preadvice ||= ShipmentIntegrationType.new('preadvice')
          end

          def to_hash
            value
          end

        end

        class SortDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SortDirection for this value, creating a new instance for an unknown value
          def SortDirection.apply(value)
            if value.instance_of?(SortDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SortDirection.new(value))
            end
          end

          # Returns the instance of SortDirection for this value, or nil if not found
          def SortDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SortDirection.ALL.find { |v| v.value == value }
          end

          def SortDirection.ALL
            @@all ||= [SortDirection.ascending, SortDirection.descending]
          end

          def SortDirection.ascending
            @@_ascending ||= SortDirection.new('ascending')
          end

          def SortDirection.descending
            @@_descending ||= SortDirection.new('descending')
          end

          def to_hash
            value
          end

        end

        class Strategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Strategy for this value, creating a new instance for an unknown value
          def Strategy.apply(value)
            if value.instance_of?(Strategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Strategy.new(value))
            end
          end

          # Returns the instance of Strategy for this value, or nil if not found
          def Strategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Strategy.ALL.find { |v| v.value == value }
          end

          def Strategy.ALL
            @@all ||= [Strategy.range, Strategy.from, Strategy.to]
          end

          # Tightest range
          def Strategy.range
            @@_range ||= Strategy.new('range')
          end

          # Lowest minimum of the ranges
          def Strategy.from
            @@_from ||= Strategy.new('from')
          end

          # Lowest maximum of the ranges
          def Strategy.to
            @@_to ||= Strategy.new('to')
          end

          def to_hash
            value
          end

        end

        class TierStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierStrategy for this value, creating a new instance for an unknown value
          def TierStrategy.apply(value)
            if value.instance_of?(TierStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierStrategy.new(value))
            end
          end

          # Returns the instance of TierStrategy for this value, or nil if not found
          def TierStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierStrategy.ALL.find { |v| v.value == value }
          end

          def TierStrategy.ALL
            @@all ||= [TierStrategy.fastest, TierStrategy.lowest_cost]
          end

          # Optimize for fastest first, then cheapest
          def TierStrategy.fastest
            @@_fastest ||= TierStrategy.new('fastest')
          end

          # Optimize for lowest cost first, then fastest
          def TierStrategy.lowest_cost
            @@_lowest_cost ||= TierStrategy.new('lowest_cost')
          end

          def to_hash
            value
          end

        end

        class TrackingStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TrackingStatus for this value, creating a new instance for an unknown value
          def TrackingStatus.apply(value)
            if value.instance_of?(TrackingStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TrackingStatus.new(value))
            end
          end

          # Returns the instance of TrackingStatus for this value, or nil if not found
          def TrackingStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TrackingStatus.ALL.find { |v| v.value == value }
          end

          def TrackingStatus.ALL
            @@all ||= [TrackingStatus.pending, TrackingStatus.info_received, TrackingStatus.in_transit, TrackingStatus.out_for_delivery, TrackingStatus.attempt_fail, TrackingStatus.delivered, TrackingStatus.exception, TrackingStatus.expired]
          end

          def TrackingStatus.pending
            @@_pending ||= TrackingStatus.new('pending')
          end

          def TrackingStatus.info_received
            @@_info_received ||= TrackingStatus.new('info_received')
          end

          def TrackingStatus.in_transit
            @@_in_transit ||= TrackingStatus.new('in_transit')
          end

          def TrackingStatus.out_for_delivery
            @@_out_for_delivery ||= TrackingStatus.new('out_for_delivery')
          end

          def TrackingStatus.attempt_fail
            @@_attempt_fail ||= TrackingStatus.new('attempt_fail')
          end

          def TrackingStatus.delivered
            @@_delivered ||= TrackingStatus.new('delivered')
          end

          def TrackingStatus.exception
            @@_exception ||= TrackingStatus.new('exception')
          end

          def TrackingStatus.expired
            @@_expired ||= TrackingStatus.new('expired')
          end

          def to_hash
            value
          end

        end

        class UnitOfMeasurement

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfMeasurement for this value, creating a new instance for an unknown value
          def UnitOfMeasurement.apply(value)
            if value.instance_of?(UnitOfMeasurement)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfMeasurement.new(value))
            end
          end

          # Returns the instance of UnitOfMeasurement for this value, or nil if not found
          def UnitOfMeasurement.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfMeasurement.ALL.find { |v| v.value == value }
          end

          def UnitOfMeasurement.ALL
            @@all ||= [UnitOfMeasurement.millimeter, UnitOfMeasurement.centimeter, UnitOfMeasurement.inch, UnitOfMeasurement.foot, UnitOfMeasurement.cubic_inch, UnitOfMeasurement.cubic_meter, UnitOfMeasurement.gram, UnitOfMeasurement.kilogram, UnitOfMeasurement.meter, UnitOfMeasurement.ounce, UnitOfMeasurement.pound]
          end

          # Equivalent to MILLI(METRE).
          def UnitOfMeasurement.millimeter
            @@_millimeter ||= UnitOfMeasurement.new('millimeter')
          end

          # Equivalent to CENTI(METRE).
          def UnitOfMeasurement.centimeter
            @@_centimeter ||= UnitOfMeasurement.new('centimeter')
          end

          # A unit of length equal to 0.01004 m (standard name in).
          def UnitOfMeasurement.inch
            @@_inch ||= UnitOfMeasurement.new('inch')
          end

          # A unit of length equal to 0.3048 m (standard name ft).
          def UnitOfMeasurement.foot
            @@_foot ||= UnitOfMeasurement.new('foot')
          end

          # A unit of volume equal to one cubic inch (in³).
          def UnitOfMeasurement.cubic_inch
            @@_cubic_inch ||= UnitOfMeasurement.new('cubic_inch')
          end

          # The metric unit for volume quantities (m³).
          def UnitOfMeasurement.cubic_meter
            @@_cubic_meter ||= UnitOfMeasurement.new('cubic_meter')
          end

          # A unit of mass equal to 1 / 1000 kilogram (standard name g).
          def UnitOfMeasurement.gram
            @@_gram ||= UnitOfMeasurement.new('gram')
          end

          # The base unit for mass quantities (kg).
          def UnitOfMeasurement.kilogram
            @@_kilogram ||= UnitOfMeasurement.new('kilogram')
          end

          # The base unit for length quantities (m).
          def UnitOfMeasurement.meter
            @@_meter ||= UnitOfMeasurement.new('meter')
          end

          # A unit of mass equal to 1 / 16 POUND (standard name oz).
          def UnitOfMeasurement.ounce
            @@_ounce ||= UnitOfMeasurement.new('ounce')
          end

          # A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
          def UnitOfMeasurement.pound
            @@_pound ||= UnitOfMeasurement.new('pound')
          end

          def to_hash
            value
          end

        end

        class UnitOfTime

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfTime for this value, creating a new instance for an unknown value
          def UnitOfTime.apply(value)
            if value.instance_of?(UnitOfTime)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfTime.new(value))
            end
          end

          # Returns the instance of UnitOfTime for this value, or nil if not found
          def UnitOfTime.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfTime.ALL.find { |v| v.value == value }
          end

          def UnitOfTime.ALL
            @@all ||= [UnitOfTime.day, UnitOfTime.hour, UnitOfTime.minute]
          end

          def UnitOfTime.day
            @@_day ||= UnitOfTime.new('day')
          end

          def UnitOfTime.hour
            @@_hour ||= UnitOfTime.new('hour')
          end

          def UnitOfTime.minute
            @@_minute ||= UnitOfTime.new('minute')
          end

          def to_hash
            value
          end

        end

        class UpdatePolicy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
          def UpdatePolicy.apply(value)
            if value.instance_of?(UpdatePolicy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
            end
          end

          # Returns the instance of UpdatePolicy for this value, or nil if not found
          def UpdatePolicy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdatePolicy.ALL.find { |v| v.value == value }
          end

          def UpdatePolicy.ALL
            @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
          end

          def UpdatePolicy.auto
            @@_auto ||= UpdatePolicy.new('auto')
          end

          # Queue item update for approval.
          def UpdatePolicy.queue
            @@_queue ||= UpdatePolicy.new('queue')
          end

          def UpdatePolicy.discard
            @@_discard ||= UpdatePolicy.new('discard')
          end

          def to_hash
            value
          end

        end

        class UpdateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdateType for this value, creating a new instance for an unknown value
          def UpdateType.apply(value)
            if value.instance_of?(UpdateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdateType.new(value))
            end
          end

          # Returns the instance of UpdateType for this value, or nil if not found
          def UpdateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdateType.ALL.find { |v| v.value == value }
          end

          def UpdateType.ALL
            @@all ||= [UpdateType.change, UpdateType.set]
          end

          # Long value to increment or decrement. Positive quantities are added to
          # inventory while negative quantities are decrement from inventory.
          def UpdateType.change
            @@_change ||= UpdateType.new('change')
          end

          # Set aboluste quantity to new value with no regard for previous updates
          def UpdateType.set
            @@_set ||= UpdateType.new('set')
          end

          def to_hash
            value
          end

        end

        class ValueAddedService

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ValueAddedService for this value, creating a new instance for an unknown value
          def ValueAddedService.apply(value)
            if value.instance_of?(ValueAddedService)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ValueAddedService.new(value))
            end
          end

          # Returns the instance of ValueAddedService for this value, or nil if not found
          def ValueAddedService.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ValueAddedService.ALL.find { |v| v.value == value }
          end

          def ValueAddedService.ALL
            @@all ||= [ValueAddedService.hazardous_material]
          end

          # See https://en.wikipedia.org/wiki/ORM-D
          def ValueAddedService.hazardous_material
            @@_hazardous_material ||= ValueAddedService.new('Hazardous Material')
          end

          def to_hash
            value
          end

        end

        class Visibility

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Visibility for this value, creating a new instance for an unknown value
          def Visibility.apply(value)
            if value.instance_of?(Visibility)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Visibility.new(value))
            end
          end

          # Returns the instance of Visibility for this value, or nil if not found
          def Visibility.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Visibility.ALL.find { |v| v.value == value }
          end

          def Visibility.ALL
            @@all ||= [Visibility.public, Visibility.private]
          end

          def Visibility.public
            @@_public ||= Visibility.new('public')
          end

          def Visibility.private
            @@_private ||= Visibility.new('private')
          end

          def to_hash
            value
          end

        end

        class Address

          attr_reader :contact, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contact, :location], 'Address')
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Address.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contact => contact.to_hash,
              :location => location.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin price
        class AmountMargin < TierRuleOutcome

          attr_reader :addition

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::AMOUNT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:addition], 'AmountMargin')
            @addition = (x = opts.delete(:addition); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :addition => addition.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost of the service
        class AtCost < TierRuleOutcome

          attr_reader :at_cost

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::AT_COST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:at_cost], 'AtCost')
            @at_cost = HttpClient::Preconditions.assert_class('at_cost', opts.delete(:at_cost), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AtCost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :at_cost => at_cost
            }
          end

        end

        # An attribute can be configured to be used in different ways throughout Flow. A
        # common example is to identify a meaningful attribute (e.g. brand) that can
        # then be displayed throughout the Flow console.
        class Attribute

          attr_reader :id, :key, :options, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :options], 'Attribute')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :options => options.to_hash,
              :label => label
            }
          end

        end

        class AttributeForm

          attr_reader :key, :options, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :options], 'AttributeForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :options => options.to_hash,
              :label => label
            }
          end

        end

        # Retrieve journaled history of an attribute
        class AttributeVersion

          attr_reader :id, :timestamp, :type, :attribute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :attribute], 'AttributeVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :attribute => attribute.to_hash
            }
          end

        end

        class AuthenticationForm

          attr_reader :email, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :password], 'AuthenticationForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class Authorization

          attr_reader :id, :reference, :card, :amount, :currency, :customer, :metadata, :shipping, :ip, :cvv, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :card, :amount, :currency, :customer, :metadata, :details], 'Authorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::CardReference) ? x : ::Io::Flow::V0::Models::CardReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::CustomerForm) ? x : ::Io::Flow::V0::Models::CustomerForm.new(x))
            @metadata = HttpClient::Preconditions.assert_class('metadata', opts.delete(:metadata), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @details = (x = opts.delete(:details); x.is_a?(::Io::Flow::V0::Models::AuthorizationDetails) ? x : ::Io::Flow::V0::Models::AuthorizationDetails.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Authorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :card => card.to_hash,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :metadata => metadata,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :ip => ip,
              :cvv => cvv,
              :details => details.to_hash
            }
          end

        end

        # Represents a declined authorization
        class AuthorizationDetailsDecline < AuthorizationDetails

          attr_reader :reason, :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_DECLINE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:reason], 'AuthorizationDetailsDecline')
            @reason = HttpClient::Preconditions.assert_class('reason', opts.delete(:reason), String)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsDecline.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :reason => reason,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # Represents a successful authorization
        class AuthorizationDetailsSuccess < AuthorizationDetails

          attr_reader :avs, :cvv

          def initialize(incoming={})
            super(:name => AuthorizationDetails::Types::AUTHORIZATION_DETAILS_SUCCESS)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDetailsSuccess.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class AuthorizationForm

          attr_reader :reference, :token, :amount, :currency, :customer, :cvv, :metadata, :shipping, :ip

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :amount, :currency, :customer], 'AuthorizationForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::CustomerForm) ? x : ::Io::Flow::V0::Models::CustomerForm.new(x))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :token => token,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :cvv => cvv,
              :metadata => metadata.nil? ? nil : metadata,
              :shipping => shipping.nil? ? nil : shipping.to_hash,
              :ip => ip
            }
          end

        end

        class AuthorizationReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'AuthorizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class AuthorizationVersion

          attr_reader :id, :timestamp, :type, :authorization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :authorization], 'AuthorizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :authorization => authorization.to_hash
            }
          end

        end

        # Representation of a service level available at a center, including misc
        # attributes. Only ID for now, more attributes will be added in the future.
        class AvailableService

          attr_reader :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service], 'AvailableService')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service
            }
          end

        end

        # Represents data from the address verification check
        class Avs

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Avs')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Avs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class Booking

          attr_reader :id, :number, :shipments

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :shipments], 'Booking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @shipments = HttpClient::Preconditions.assert_class('shipments', opts.delete(:shipments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentReference) ? x : ::Io::Flow::V0::Models::ShipmentReference.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Booking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :shipments => shipments.map { |o| o.to_hash }
            }
          end

        end

        # Represents second step of two-step purchase of Flow services.
        class BookingForm

          attr_reader :number, :quote, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quote, :options], 'BookingForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| HttpClient::Preconditions.assert_class('options', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quote => quote,
              :options => options
            }
          end

        end

        class BookingSummary

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'BookingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class BookingVersion

          attr_reader :id, :timestamp, :type, :booking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :booking], 'BookingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @booking = (x = opts.delete(:booking); x.is_a?(::Io::Flow::V0::Models::BookingSummary) ? x : ::Io::Flow::V0::Models::BookingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            BookingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :booking => booking.to_hash
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class Capture

          attr_reader :id, :reference, :authorization, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :authorization, :amount, :currency], 'Capture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Capture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :authorization => authorization.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class CaptureForm

          attr_reader :reference, :authorization_id, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'CaptureForm')
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :reference => reference,
              :authorization_id => authorization_id,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class CaptureVersion

          attr_reader :id, :timestamp, :type, :capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :capture], 'CaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :capture => capture.to_hash
            }
          end

        end

        # Card represents the metadata about a secure, tokenized card. The card 'id' is
        # a unique, cryptographically secure token by which this card can be identified
        # in the future.
        class Card

          attr_reader :id, :type, :expiration, :last4, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :expiration, :last4, :name], 'Card')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Card.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :expiration => expiration.to_hash,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardForm

          attr_reader :number, :expiration_month, :expiration_year, :name, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :expiration_month, :expiration_year], 'CardForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @expiration_month = HttpClient::Preconditions.assert_class('expiration_month', opts.delete(:expiration_month), Integer)
            @expiration_year = HttpClient::Preconditions.assert_class('expiration_year', opts.delete(:expiration_year), Integer)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :expiration_month => expiration_month,
              :expiration_year => expiration_year,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        class CardReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CardVersion

          attr_reader :id, :timestamp, :type, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :card], 'CardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :card => card.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class Carrier

          attr_reader :id, :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :facilities, :visibility], 'Carrier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = HttpClient::Preconditions.assert_class('facilities', opts.delete(:facilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)) }
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Carrier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :facilities => facilities.map { |o| o.to_hash },
              :visibility => visibility.value
            }
          end

        end

        # carrier_account an organization has with a carrier. A carrier can have
        # multiple carrier_accounts with a single carrier. This represents the
        # many-to-many relationship between organizations and carriers.
        class CarrierAccount

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierAccount')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccount.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class CarrierAccountForm

          attr_reader :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:carrier], 'CarrierAccountForm')
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :carrier => carrier,
              :name => name
            }
          end

        end

        class CarrierAccountReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierAccountReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CarrierAccountSummary

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'CarrierAccountSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class CarrierAccountVersion

          attr_reader :id, :timestamp, :type, :carrier_account

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier_account], 'CarrierAccountVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier_account = (x = opts.delete(:carrier_account); x.is_a?(::Io::Flow::V0::Models::CarrierAccountSummary) ? x : ::Io::Flow::V0::Models::CarrierAccountSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierAccountVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier_account => carrier_account.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class CarrierForm

          attr_reader :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'CarrierForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = (x = opts.delete(:facilities); x.nil? ? nil : HttpClient::Preconditions.assert_class('facilities', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)) })
            @visibility = (x = opts.delete(:visibility); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :facilities => facilities.nil? ? nil : facilities.map { |o| o.to_hash },
              :visibility => visibility.nil? ? nil : visibility.value
            }
          end

        end

        class CarrierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CarrierVersion

          attr_reader :id, :timestamp, :type, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :carrier], 'CarrierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :carrier => carrier.to_hash
            }
          end

        end

        class Catalog

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CatalogItemDocument < Document

          attr_reader :number, :name, :categories, :experiences, :attributes

          def initialize(incoming={})
            super(:name => Document::Types::CATALOG_ITEM_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :categories, :experiences, :attributes], 'CatalogItemDocument')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @experiences = HttpClient::Preconditions.assert_class('experiences', opts.delete(:experiences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DocumentAttribute) ? x : ::Io::Flow::V0::Models::DocumentAttribute.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :name => name,
              :categories => categories,
              :experiences => experiences.map { |o| o.to_hash },
              :attributes => attributes.map { |o| o.to_hash }
            }
          end

        end

        class CatalogVersion

          attr_reader :id, :timestamp, :type, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :catalog => catalog.to_hash
            }
          end

        end

        class CategorySummary

          attr_reader :name, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:count], 'CategorySummary')
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CategorySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :count => count
            }
          end

        end

        # Represents a facility capable of fulfilling a shipment
        class Center

          attr_reader :id, :address, :packaging, :name, :services, :schedule, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :address, :packaging, :name, :services, :schedule, :timezone], 'Center')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Center.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone
            }
          end

        end

        class CenterForm

          attr_reader :address, :packaging, :name, :services, :schedule, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :packaging, :name, :services, :schedule, :timezone], 'CenterForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone
            }
          end

        end

        class CenterReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CenterVersion

          attr_reader :id, :timestamp, :type, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :center], 'CenterVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :center => center.to_hash
            }
          end

        end

        # The actual value of the API token. This is modeled as a separate resource as
        # it is fetched only on demand.
        class Cleartext

          attr_reader :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value], 'Cleartext')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cleartext.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value
            }
          end

        end

        class Component

          attr_reader :adjustments, :levies

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:adjustments, :levies], 'Component')
            @adjustments = HttpClient::Preconditions.assert_class('adjustments', opts.delete(:adjustments), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x)) }
            @levies = HttpClient::Preconditions.assert_class('levies', opts.delete(:levies), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Levy) ? x : ::Io::Flow::V0::Models::Levy.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Component.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :adjustments => adjustments.map { |o| o.value },
              :levies => levies.map { |o| o.value }
            }
          end

        end

        # Defines structured fields for a contact person. Typically used for specifying
        # contact person for an account, shipment, or organization representative
        class Contact

          attr_reader :name, :email, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Contact')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Contact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :email => email,
              :phone => phone
            }
          end

        end

        # Describes conversion information from a base currency to a target currency.
        class Conversion

          attr_reader :base, :target, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :rate], 'Conversion')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Conversion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :rate => rate
            }
          end

        end

        class Country

          attr_reader :name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :default_currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system], 'Country')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @iso_3166_3 = HttpClient::Preconditions.assert_class('iso_3166_3', opts.delete(:iso_3166_3), String)
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @default_currency = (x = opts.delete(:default_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Country.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_3166_2 => iso_3166_2,
              :iso_3166_3 => iso_3166_3,
              :languages => languages,
              :measurement_system => measurement_system,
              :default_currency => default_currency
            }
          end

        end

        # ISO 4217 3-character currency code. See
        # https://api.flow.io/reference/currencies
        class Currency

          attr_reader :name, :iso_4217_3, :number_decimals

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_4217_3, :number_decimals], 'Currency')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_4217_3 = HttpClient::Preconditions.assert_class('iso_4217_3', opts.delete(:iso_4217_3), String)
            @number_decimals = HttpClient::Preconditions.assert_class('number_decimals', opts.delete(:number_decimals), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Currency.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_4217_3 => iso_4217_3,
              :number_decimals => number_decimals
            }
          end

        end

        # A customer represents the actual person purchasing from you. This information
        # is needed primarily to support logistics (delivery to this person), fraud
        # management (verification of who the person id), and reporting. We also
        # recommend including your customer.number whenever possible as doing so will
        # allow Flow to link up transactions for this customer making customer service
        # easieer.
        class Customer

          attr_reader :id, :number, :name, :phone, :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'Customer')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Customer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name.to_hash,
              :phone => phone,
              :email => email
            }
          end

        end

        # A customer represents the actual person purchasing from you. This information
        # is needed primarily to support logistics (delivery to this person), fraud
        # management (verification of who the person id), and reporting. We also
        # recommend including your customer.number whenever possible as doing so will
        # allow Flow to link up transactions for this customer making customer service
        # easieer.
        class CustomerForm

          attr_reader :number, :name, :phone, :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'CustomerForm')
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CustomerForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name.to_hash,
              :phone => phone,
              :email => email
            }
          end

        end

        # Represents data from the card verification number check
        class Cvv

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Cvv')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cvv.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        class DatetimeRange

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DatetimeRange')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DatetimeRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class Delivery

          attr_reader :id, :items, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :options], 'Delivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOption) ? x : ::Io::Flow::V0::Models::DeliveryOption.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Delivery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :options => options.map { |o| o.to_hash }
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class DeliveryForm

          attr_reader :quote, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quote, :items, :destination], 'DeliveryForm')
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :quote => quote,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOption

          attr_reader :id, :cost, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :price, :service, :tier, :window], 'DeliveryOption')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOption.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOptionForm

          attr_reader :delivery, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivery, :items, :destination], 'DeliveryOptionForm')
            @delivery = HttpClient::Preconditions.assert_class('delivery', opts.delete(:delivery), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivery => delivery,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class DeliveryOptionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'DeliveryOptionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class DeliveryOptionSummary

          attr_reader :id, :cost, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :price, :service, :tier, :window], 'DeliveryOptionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        class DeliveryOptionVersion

          attr_reader :id, :timestamp, :type, :delivery_option

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery_option], 'DeliveryOptionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery_option = (x = opts.delete(:delivery_option); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionSummary) ? x : ::Io::Flow::V0::Models::DeliveryOptionSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery_option => delivery_option.to_hash
            }
          end

        end

        class DeliverySummary

          attr_reader :id, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items], 'DeliverySummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliverySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class DeliveryVersion

          attr_reader :id, :timestamp, :type, :delivery

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery], 'DeliveryVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery = (x = opts.delete(:delivery); x.is_a?(::Io::Flow::V0::Models::DeliverySummary) ? x : ::Io::Flow::V0::Models::DeliverySummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery => delivery.to_hash
            }
          end

        end

        class DeliveryWindow

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DeliveryWindow')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class DeminimusSimple < Deminimus

          attr_reader :value, :currency, :components, :minimum

          def initialize(incoming={})
            super(:name => Deminimus::Types::DEMINIMUS_SIMPLE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :currency, :components, :minimum], 'DeminimusSimple')
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @minimum = HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(opts.delete(:minimum)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimusSimple.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :value => value,
              :currency => currency,
              :components => components.map { |o| o.value },
              :minimum => minimum
            }
          end

        end

        class Dimension

          attr_reader :depth, :diameter, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @diameter = (x = opts.delete(:diameter); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :depth => depth.nil? ? nil : depth.to_hash,
              :diameter => diameter.nil? ? nil : diameter.to_hash,
              :length => length.nil? ? nil : length.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :width => width.nil? ? nil : width.to_hash
            }
          end

        end

        class Dimensions

          attr_reader :product, :packaging

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @product = (x = opts.delete(:product); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
            @packaging = (x = opts.delete(:packaging); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :product => product.nil? ? nil : product.to_hash,
              :packaging => packaging.nil? ? nil : packaging.to_hash
            }
          end

        end

        class DocumentAttribute

          attr_reader :name, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'DocumentAttribute')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DocumentAttribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :value => value
            }
          end

        end

        # Represents a simple model of duties that apply to a given item / trade lane.
        class Duty

          attr_reader :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :components], 'Duty')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Represents the successful response of an email verification token. We return
        # the email address in this case to allow the UI to display which email address
        # was verified.
        class EmailVerification

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailVerification')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Represents an error of some sort (e.g. invalid input). Each error will contain
        # a code and a specific message describing the failure.
        class Error

          attr_reader :code, :message

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Error')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :message => message
            }
          end

        end

        # Range of time given a from and to number and the unit. For example: 1-4 hours
        # or 4-7 days
        class EstimatedWindow

          attr_reader :from, :to, :unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :unit], 'EstimatedWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :unit => unit.value
            }
          end

        end

        # Represents an exception to the schedule of a location.
        class Exception

          attr_reader :type, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :datetime_range], 'Exception')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExceptionType) ? x : ::Io::Flow::V0::Models::ExceptionType.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Exception.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        # Properties that define a customized local experience for a given geographic
        # region
        class Experience

          attr_reader :id, :key, :region, :currency, :language, :measurement_system, :name, :subcatalog, :price_display

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :region, :currency, :language, :measurement_system, :name, :subcatalog, :price_display], 'Experience')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x))
            @price_display = (x = opts.delete(:price_display); x.is_a?(::Io::Flow::V0::Models::PriceDisplay) ? x : ::Io::Flow::V0::Models::PriceDisplay.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experience.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :region => region.to_hash,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value,
              :name => name,
              :subcatalog => subcatalog.to_hash,
              :price_display => price_display.to_hash
            }
          end

        end

        # Data needed to create an experience for a given geographic region
        class ExperienceForm

          attr_reader :region_id, :name, :currency, :language, :key, :measurement_system, :subcatalog_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:region_id, :name], 'ExperienceForm')
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @measurement_system = (x = opts.delete(:measurement_system); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x)))
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :region_id => region_id,
              :name => name,
              :currency => currency,
              :language => language,
              :key => key,
              :measurement_system => measurement_system.nil? ? nil : measurement_system.value,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class ExperienceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Some important fields related to experiences used in various APIs
        class ExperienceSummary

          attr_reader :id, :key, :name, :currency, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name], 'ExperienceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :currency => currency,
              :country => country
            }
          end

        end

        class ExperienceVersion

          attr_reader :id, :timestamp, :type, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :experience], 'ExperienceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :experience => experience.to_hash
            }
          end

        end

        # The month and year at which a card expires
        class Expiration

          attr_reader :month, :year

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:month, :year], 'Expiration')
            @month = HttpClient::Preconditions.assert_class('month', opts.delete(:month), Integer)
            @year = HttpClient::Preconditions.assert_class('year', opts.delete(:year), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Expiration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :month => month,
              :year => year
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is pre-defined flat rate
        class FlatRate < TierRuleOutcome

          attr_reader :price

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::FLAT_RATE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRate')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRate.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        # Flow internal model containing an item's origin and classified harmonization
        # code (6 digit)
        class Flow

          attr_reader :origin, :function, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @function = (x = opts.delete(:function); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableFunction) ? x : ::Io::Flow::V0::Models::ExpandableFunction.from_json(x)))
            @hs6 = (x = opts.delete(:hs6); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Flow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :origin => origin,
              :function => function.nil? ? nil : function.to_hash,
              :hs6 => hs6
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is free
        class FreeShipping < TierRuleOutcome

          attr_reader :free_shipping

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::FREE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:free_shipping], 'FreeShipping')
            @free_shipping = HttpClient::Preconditions.assert_class('free_shipping', opts.delete(:free_shipping), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :free_shipping => free_shipping
            }
          end

        end

        class FulfillmentExperienceReference

          attr_reader :id, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :currency], 'FulfillmentExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :currency => currency
            }
          end

        end

        # Prioritized calculation yielding a localized price (also allows for custom
        # defined price function)
        class Function < ExpandableFunction

          attr_reader :id, :subcatalog_id, :key, :name, :position, :presets, :code, :q

          def initialize(incoming={})
            super(:name => ExpandableFunction::Types::FUNCTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :subcatalog_id, :key, :name, :position, :presets, :code], 'Function')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @presets = (x = opts.delete(:presets); x.is_a?(::Io::Flow::V0::Models::Presets) ? x : ::Io::Flow::V0::Models::Presets.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Function.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :subcatalog_id => subcatalog_id,
              :key => key,
              :name => name,
              :position => position,
              :presets => presets.to_hash,
              :code => code,
              :q => q
            }
          end

        end

        class FunctionForm

          attr_reader :name, :subcatalog_id, :q, :presets, :code, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :subcatalog_id], 'FunctionForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @presets = (x = opts.delete(:presets); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Presets) ? x : ::Io::Flow::V0::Models::Presets.new(x)))
            @code = (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :subcatalog_id => subcatalog_id,
              :q => q,
              :presets => presets.nil? ? nil : presets.to_hash,
              :code => code,
              :position => position
            }
          end

        end

        class FunctionReference < ExpandableFunction

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableFunction::Types::FUNCTION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'FunctionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class FunctionSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'FunctionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class FunctionVersion

          attr_reader :id, :timestamp, :type, :function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :function], 'FunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @function = (x = opts.delete(:function); x.is_a?(::Io::Flow::V0::Models::Function) ? x : ::Io::Flow::V0::Models::Function.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :function => function.to_hash
            }
          end

        end

        class HarmonizationDocument < Document

          attr_reader :code, :categories, :origin

          def initialize(incoming={})
            super(:name => Document::Types::HARMONIZATION_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :categories], 'HarmonizationDocument')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CategorySummary) ? x : ::Io::Flow::V0::Models::CategorySummary.new(x)) }
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :code => code,
              :categories => categories.map { |o| o.to_hash },
              :origin => origin
            }
          end

        end

        # Organization level settings.
        class HarmonizationSettings

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = (x = opts.delete(:duty_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
            @tax_strategy = (x = (x = opts.delete(:tax_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.value,
              :tax_strategy => tax_strategy.value
            }
          end

        end

        class HarmonizationSettingsForm

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = opts.delete(:duty_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
            @tax_strategy = (x = opts.delete(:tax_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.nil? ? nil : duty_strategy.value,
              :tax_strategy => tax_strategy.nil? ? nil : tax_strategy.value
            }
          end

        end

        # A harmonized item stores explicit information about this item for the purposes
        # of harmonization / classification. The harmonization process begins by
        # creating a harmonized item; this kicks off the internal processes. Once
        # assigned, codes will be available via the hs6 and hs10 resources
        class HarmonizedItem

          attr_reader :id, :number, :name, :description, :categories, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :name], 'HarmonizedItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @metadata = HttpClient::Preconditions.assert_class('metadata', (x = opts.delete(:metadata); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name,
              :description => description,
              :categories => categories,
              :metadata => metadata
            }
          end

        end

        # Used to specifically set an item's duty rate for a given trade lane.
        class HarmonizedItemDuty

          attr_reader :id, :item, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :rate], 'HarmonizedItemDuty')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDuty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyForm

          attr_reader :number, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :origin, :destination, :rate], 'HarmonizedItemDutyForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyVersion

          attr_reader :id, :timestamp, :type, :harmonized_item_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item_duty], 'HarmonizedItemDutyVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item_duty = (x = opts.delete(:harmonized_item_duty); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemDuty) ? x : ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item_duty => harmonized_item_duty.to_hash
            }
          end

        end

        class HarmonizedItemForm

          attr_reader :name, :number, :categories, :description, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :number], 'HarmonizedItemForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :number => number,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :metadata => metadata.nil? ? nil : metadata
            }
          end

        end

        class HarmonizedItemPutForm

          attr_reader :name, :categories, :description, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'HarmonizedItemPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('metadata', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :metadata => metadata.nil? ? nil : metadata
            }
          end

        end

        class HarmonizedItemReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'HarmonizedItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class HarmonizedItemVersion

          attr_reader :id, :timestamp, :type, :harmonized_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item], 'HarmonizedItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item = (x = opts.delete(:harmonized_item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItem) ? x : ::Io::Flow::V0::Models::HarmonizedItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item => harmonized_item.to_hash
            }
          end

        end

        class Healthcheck

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Healthcheck')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # The (Harmonized System) HS-10 code assigned to an item with a given
        # origin/destination pair.
        class Hs10

          attr_reader :id, :item, :origin, :destination, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :code], 'Hs10')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        class Hs10Version

          attr_reader :id, :timestamp, :type, :hs10

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs10], 'Hs10Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs10 = (x = opts.delete(:hs10); x.is_a?(::Io::Flow::V0::Models::Hs10) ? x : ::Io::Flow::V0::Models::Hs10.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs10 => hs10.to_hash
            }
          end

        end

        # The (Harmonized System) HS-6 code assigned to an item.
        class Hs6

          attr_reader :id, :item, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :code], 'Hs6')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :code => code
            }
          end

        end

        class Hs6Version

          attr_reader :id, :timestamp, :type, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs6], 'Hs6Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs6 = (x = opts.delete(:hs6); x.is_a?(::Io::Flow::V0::Models::Hs6) ? x : ::Io::Flow::V0::Models::Hs6.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs6 => hs6.to_hash
            }
          end

        end

        # The URL to an image, with optional tags. Flow Commerce primarily uses images
        # to enhance the administrative tools (e.g. showing an item image in console)
        class Image

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags
            }
          end

        end

        # Image form defines the data needed to create an image
        class ImageForm

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImageForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImageForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.nil? ? nil : tags
            }
          end

        end

        # Enables backorders, setting an optional number of units that we allow for
        # backorder. For example, a backorder w/ quantity 10 will enable selling until
        # the actual inventory quantity is -10.
        class InventoryBackorder < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_BACKORDER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryBackorder')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryBackorder.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        class InventoryCenterReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'InventoryCenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class InventoryItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'InventoryItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # Ordered list of rules to apply, from first to last, to get available quantity.
        # This is unique per organization
        class InventoryRule

          attr_reader :id, :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :strategy], 'InventoryRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleForm

          attr_reader :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:position, :query, :strategy], 'InventoryRuleForm')
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleVersion

          attr_reader :id, :timestamp, :type, :inventory_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_rule], 'InventoryRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_rule = (x = opts.delete(:inventory_rule); x.is_a?(::Io::Flow::V0::Models::InventoryRule) ? x : ::Io::Flow::V0::Models::InventoryRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_rule => inventory_rule.to_hash
            }
          end

        end

        # Inventory snapshot reflects the current quantity and available number of units
        # for a given center / item
        class InventorySnapshot

          attr_reader :id, :available, :center, :item, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :available, :center, :item, :quantity], 'InventorySnapshot')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshot.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :available => available,
              :center => center.to_hash,
              :item => item.to_hash,
              :quantity => quantity
            }
          end

        end

        class InventorySnapshotVersion

          attr_reader :id, :timestamp, :type, :inventory_snapshot

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_snapshot], 'InventorySnapshotVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_snapshot = (x = opts.delete(:inventory_snapshot); x.is_a?(::Io::Flow::V0::Models::InventorySnapshot) ? x : ::Io::Flow::V0::Models::InventorySnapshot.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshotVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_snapshot => inventory_snapshot.to_hash
            }
          end

        end

        # Treats inventory as available as long as the actual inventory quantity is >
        # the specified quantity. A common use case is to set quantity to zero to
        # indicate availability as long as there is at least 1 unit available.
        class InventoryStock < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_STOCK)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryStock')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryStock.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Items affected with rules pursuing an unlimited strategy will always be
        # available
        class InventoryUnlimited < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:name => InventoryStrategy::Types::INVENTORY_UNLIMITED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @quantity = HttpClient::Preconditions.assert_class('quantity', (x = opts.delete(:quantity); x.nil? ? "unlimited" : x), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUnlimited.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Represents a single update on inventory quantity
        class InventoryUpdate

          attr_reader :id, :idempotency_key, :center, :item, :notes, :quantity, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :idempotency_key, :center, :item, :notes, :quantity, :type], 'InventoryUpdate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @notes = HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(opts.delete(:notes)), Hash)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :idempotency_key => idempotency_key,
              :center => center.to_hash,
              :item => item.to_hash,
              :notes => notes,
              :quantity => quantity,
              :type => type.value
            }
          end

        end

        # Form used to create an update on inventory. If inventory for center/item has
        # not been previously created, a new row is created for the center/item tuple.
        class InventoryUpdateForm

          attr_reader :center, :idempotency_key, :item, :quantity, :type, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:center, :idempotency_key, :item, :quantity, :type], 'InventoryUpdateForm')
            @center = HttpClient::Preconditions.assert_class('center', opts.delete(:center), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @item = HttpClient::Preconditions.assert_class('item', opts.delete(:item), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :center => center,
              :idempotency_key => idempotency_key,
              :item => item,
              :quantity => quantity,
              :type => type.value,
              :notes => notes
            }
          end

        end

        class InventoryUpdateVersion

          attr_reader :id, :timestamp, :type, :inventory_update

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_update], 'InventoryUpdateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_update = (x = opts.delete(:inventory_update); x.is_a?(::Io::Flow::V0::Models::InventoryUpdate) ? x : ::Io::Flow::V0::Models::InventoryUpdate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_update => inventory_update.to_hash
            }
          end

        end

        # An invitation via email to a user to join this organization. The user will
        # then walk through a user login/registration process and will immediately
        # become a member of the organization.
        class Invitation

          attr_reader :id, :organization, :email, :name, :role, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :email, :name, :role, :expiration], 'Invitation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Invitation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :email => email,
              :name => name.to_hash,
              :role => role.value,
              :expiration => expiration
            }
          end

        end

        class InvitationAcceptsForm

          attr_reader :user_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:user_id], 'InvitationAcceptsForm')
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationAcceptsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :user_id => user_id
            }
          end

        end

        class InvitationForm

          attr_reader :organization, :email, :name, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :email], 'InvitationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :role => role.value
            }
          end

        end

        class InvitationVersion

          attr_reader :id, :timestamp, :type, :invitation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :invitation], 'InvitationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @invitation = (x = opts.delete(:invitation); x.is_a?(::Io::Flow::V0::Models::Invitation) ? x : ::Io::Flow::V0::Models::Invitation.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :invitation => invitation.to_hash
            }
          end

        end

        # The Flow item defines a specific item that can be purchased by a consumer. For
        # many clients, this will map to a Sku.
        class Item

          attr_reader :id, :number, :locale, :name, :price, :categories, :description, :attributes, :dimensions, :images, :flow, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :locale, :name, :price, :dimensions], 'Item')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @images = HttpClient::Preconditions.assert_class('images', (x = opts.delete(:images); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)) }
            @flow = (x = opts.delete(:flow); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Flow) ? x : ::Io::Flow::V0::Models::Flow.new(x)))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :locale => locale,
              :name => name,
              :price => price.to_hash,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions.to_hash,
              :images => images.map { |o| o.to_hash },
              :flow => flow.nil? ? nil : flow.to_hash,
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # The item form defines the data required to create an item.
        class ItemForm

          attr_reader :number, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :locale, :name, :currency, :price], 'ItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # Summary of product line item as part of the quote
        class ItemSummary

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'ItemSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        class ItemVersion

          attr_reader :id, :timestamp, :type, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item => item.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class Label

          attr_reader :id, :tracking, :status, :carrier, :tracking_number, :timestamp, :delivery_estimate, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number, :timestamp], 'Label')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Label.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :timestamp => timestamp,
              :delivery_estimate => delivery_estimate,
              :description => description
            }
          end

        end

        class LabelEvent

          attr_reader :id, :label, :location, :status, :timestamp, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :label, :location, :status, :timestamp], 'LabelEvent')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::ExpandableLocation) ? x : ::Io::Flow::V0::Models::ExpandableLocation.from_json(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEvent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :label => label.to_hash,
              :location => location.to_hash,
              :status => status.value,
              :timestamp => timestamp,
              :description => description
            }
          end

        end

        class LabelEventForm

          attr_reader :label_id, :timestamp, :status, :description, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label_id, :timestamp, :status], 'LabelEventForm')
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @location = (x = opts.delete(:location); x.nil? ? nil : HttpClient::Preconditions.assert_class('location', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label_id => label_id,
              :timestamp => timestamp,
              :status => status.value,
              :description => description,
              :location => location
            }
          end

        end

        class LabelEventSummary

          attr_reader :id, :status, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :timestamp], 'LabelEventSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :timestamp => timestamp
            }
          end

        end

        class LabelEventVersion

          attr_reader :id, :timestamp, :type, :label_event

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :label_event], 'LabelEventVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @label_event = (x = opts.delete(:label_event); x.is_a?(::Io::Flow::V0::Models::LabelEventSummary) ? x : ::Io::Flow::V0::Models::LabelEventSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelEventVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :label_event => label_event.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class LabelForm

          attr_reader :tracking_id, :status, :carrier, :tracking_number, :delivery_estimate, :description, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_id, :carrier, :tracking_number], 'LabelForm')
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @status = (x = (x = opts.delete(:status); x.nil? ? "pending" : x); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @timestamp = (x = opts.delete(:timestamp); x.nil? ? nil : HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_id => tracking_id,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :timestamp => timestamp
            }
          end

        end

        class LabelSummary

          attr_reader :id, :tracking, :status, :carrier, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number], 'LabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number
            }
          end

        end

        class LabelVersion

          attr_reader :id, :timestamp, :type, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :label], 'LabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @label = (x = opts.delete(:label); x.is_a?(::Io::Flow::V0::Models::LabelSummary) ? x : ::Io::Flow::V0::Models::LabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :label => label.to_hash
            }
          end

        end

        # Available origin/destination mapping and available metadata for lanes of a
        # carrier Service. e.g. UPS Ground only US-US, UPS Intl only US-Intl, etc
        class Lane

          attr_reader :id, :service, :origin, :destination, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :origin, :destination, :window], 'Lane')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Lane.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :origin => origin,
              :destination => destination,
              :window => window.to_hash
            }
          end

        end

        class LaneForm

          attr_reader :service, :origin_country, :destination_country, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :origin_country, :destination_country, :window], 'LaneForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin_country = HttpClient::Preconditions.assert_class('origin_country', opts.delete(:origin_country), String)
            @destination_country = HttpClient::Preconditions.assert_class('destination_country', opts.delete(:destination_country), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :origin_country => origin_country,
              :destination_country => destination_country,
              :window => window.to_hash
            }
          end

        end

        class LaneSummary

          attr_reader :id, :service, :origin, :destination, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :origin, :destination, :window], 'LaneSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::EstimatedWindow) ? x : ::Io::Flow::V0::Models::EstimatedWindow.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :origin => origin,
              :destination => destination,
              :window => window.to_hash
            }
          end

        end

        class LaneVersion

          attr_reader :id, :timestamp, :type, :lane

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :lane], 'LaneVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @lane = (x = opts.delete(:lane); x.is_a?(::Io::Flow::V0::Models::LaneSummary) ? x : ::Io::Flow::V0::Models::LaneSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LaneVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :lane => lane.to_hash
            }
          end

        end

        # ISO 639 2-character language code. See https://api.flow.io/reference/languages
        class Language

          attr_reader :name, :iso_639_2

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_639_2], 'Language')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_639_2 = HttpClient::Preconditions.assert_class('iso_639_2', opts.delete(:iso_639_2), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Language.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_639_2 => iso_639_2
            }
          end

        end

        # Represents an order line item
        class Line

          attr_reader :number, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'Line')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Line.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity
            }
          end

        end

        class Local

          attr_reader :prices

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:prices], 'Local')
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Local.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :prices => prices.map { |o| o.to_hash }
            }
          end

        end

        class LocalizedPrice

          attr_reader :key, :currency, :amount, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label], 'LocalizedPrice')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedPrice.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :currency => currency,
              :amount => amount,
              :label => label
            }
          end

        end

        # Defines structured fields for address to be used in user/form input. Either
        # text or the structured input needs to be present.
        class Location < ExpandableLocation

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude

          def initialize(incoming={})
            super(:name => ExpandableLocation::Types::LOCATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Location.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude
            }
          end

        end

        class LocationReference < ExpandableLocation

          attr_reader :text

          def initialize(incoming={})
            super(:name => ExpandableLocation::Types::LOCATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :text => text
            }
          end

        end

        class Margin < Adjustment

          attr_reader :name, :value

          def initialize(incoming={})
            super(:name => Adjustment::Types::MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'Margin')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Margin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :name => name.value,
              :value => value
            }
          end

        end

        class Measurement

          attr_reader :value, :units

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :units], 'Measurement')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Measurement.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :units => units.value
            }
          end

        end

        # Represents the users that are part of this organization. Primary purpose is to
        # manage which users have access to the organization's data and to provide a
        # simple user interface to assign roles and permissions to each member of the
        # organization
        class Membership

          attr_reader :id, :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :role], 'Membership')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipForm

          attr_reader :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :user], 'MembershipForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user = HttpClient::Preconditions.assert_class('user', opts.delete(:user), String)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :user => user,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipPutForm

          attr_reader :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value
            }
          end

        end

        class MembershipVersion

          attr_reader :id, :timestamp, :type, :membership

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :membership], 'MembershipVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :membership => membership.to_hash
            }
          end

        end

        class Name

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Name.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NameForm

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NameForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        # Flags to indicate whether a feature is enabled/disabled on a particular model
        # (e.g. show/do not show attribute as a column in harmonization table view of
        # items)
        class Options

          attr_reader :required, :show_in_catalog, :show_in_harmonization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @required = HttpClient::Preconditions.assert_boolean('required', (x = opts.delete(:required); x.nil? ? false : x))
            @show_in_catalog = HttpClient::Preconditions.assert_boolean('show_in_catalog', (x = opts.delete(:show_in_catalog); x.nil? ? false : x))
            @show_in_harmonization = HttpClient::Preconditions.assert_boolean('show_in_harmonization', (x = opts.delete(:show_in_harmonization); x.nil? ? false : x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Options.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :required => required,
              :show_in_catalog => show_in_catalog,
              :show_in_harmonization => show_in_harmonization
            }
          end

        end

        # An order represents all of the information about a particular line item,
        # including pricing, currency rates, delivery options, etc. All information in
        # an order is guaranteed by Flow - if an order is booked before its expiration.
        # The intended use case is to create an order as a consumer enters checkout,
        # then to book that order in order processing.
        class Order

          attr_reader :id, :number, :customer, :expires_at, :deliveries, :prices, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :customer, :expires_at, :deliveries, :prices, :total], 'Order')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Order.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :customer => customer.to_hash,
              :expires_at => expires_at,
              :deliveries => deliveries.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash
            }
          end

        end

        # Represents an order that has been booked. Booked orders can no longer be
        # deleted as they represent transactions in the real world
        class OrderBooking

          attr_reader :id, :created_at, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :created_at, :order], 'OrderBooking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBooking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :created_at => created_at,
              :order => order.to_hash
            }
          end

        end

        # Books an order. This means two things: a. all pricing in the quote will be
        # guaranteed by Flow (subject to an active contract); b. you will be invoiced
        # for any relevant costs.
        class OrderBookingForm

          attr_reader :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:options], 'OrderBookingForm')
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| HttpClient::Preconditions.assert_class('options', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderBookingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :options => options
            }
          end

        end

        # The order form is used to create an open order, providing the details on
        # pricing and delivery options for destination and items/quantities specified
        class OrderForm

          attr_reader :number, :customer, :destination, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :customer, :destination, :items], 'OrderForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::CustomerForm) ? x : ::Io::Flow::V0::Models::CustomerForm.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Location) ? x : ::Io::Flow::V0::Models::Location.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :customer => customer.to_hash,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class OrderReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrderReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class OrderVersion

          attr_reader :id, :timestamp, :type, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order], 'OrderVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order => order.to_hash
            }
          end

        end

        # Represents a single organization in the system, and what environment it is
        # currently operating in.
        class Organization < ExpandableOrganization

          attr_reader :id, :name, :environment, :parent

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :environment], 'Organization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Organization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent => parent.nil? ? nil : parent.to_hash
            }
          end

        end

        # Defines the data used for broad authorization of user access to org level data
        class OrganizationAuthorization

          attr_reader :role, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:role, :environment], 'OrganizationAuthorization')
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value,
              :environment => environment.value
            }
          end

        end

        # Either id or name is required.
        class OrganizationForm

          attr_reader :id, :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = (x = opts.delete(:environment); x.nil? ? "production" : x); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent_id => parent_id
            }
          end

        end

        # Data required to upsert an organization.
        class OrganizationPutForm

          attr_reader :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :environment => environment.nil? ? nil : environment.value,
              :parent_id => parent_id
            }
          end

        end

        class OrganizationReference < ExpandableOrganization

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableOrganization::Types::ORGANIZATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class OrganizationSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'OrganizationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        class OrganizationVersion

          attr_reader :id, :timestamp, :type, :organization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization], 'OrganizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization => organization.to_hash
            }
          end

        end

        # Represents packaging available to ship items
        class Packaging

          attr_reader :dimensions, :name, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions], 'Packaging')
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', opts.delete(:dimensions), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)) }
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Packaging.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.map { |o| o.to_hash },
              :name => name,
              :number => number
            }
          end

        end

        class PasswordChangeForm

          attr_reader :current, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:current, :new], 'PasswordChangeForm')
            @current = HttpClient::Preconditions.assert_class('current', opts.delete(:current), String)
            @new = HttpClient::Preconditions.assert_class('new', opts.delete(:new), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :current => current,
              :new => new
            }
          end

        end

        class PasswordResetForm

          attr_reader :token, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordResetForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token,
              :password => password
            }
          end

        end

        class PasswordResetRequestForm

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequestForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetRequestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin percentage
        class PercentMargin < TierRuleOutcome

          attr_reader :percentage

          def initialize(incoming={})
            super(:name => TierRuleOutcome::Types::PERCENT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percentage], 'PercentMargin')
            @percentage = HttpClient::Preconditions.assert_class('percentage', opts.delete(:percentage), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PercentMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percentage => percentage
            }
          end

        end

        # Presentation for UI that is used to generate a localized price function
        class Presets

          attr_reader :adjustments, :levies

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @adjustments = HttpClient::Preconditions.assert_class('adjustments', (x = opts.delete(:adjustments); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Adjustment) ? x : ::Io::Flow::V0::Models::Adjustment.from_json(x)) }
            @levies = HttpClient::Preconditions.assert_class('levies', (x = opts.delete(:levies); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Levy) ? x : ::Io::Flow::V0::Models::Levy.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Presets.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :adjustments => adjustments.map { |o| o.to_hash },
              :levies => levies.map { |o| o.value }
            }
          end

        end

        # Represents an amount-currency pair for a basic price
        class Price

          attr_reader :amount, :currency, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency, :label], 'Price')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label
            }
          end

        end

        # Defines which elements of a the item price should be explicitly displayed
        # (e.g. deciding whether to list VAT standalone from item price or as part of
        # the item price)
        class PriceDisplay

          attr_reader :levies

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:levies], 'PriceDisplay')
            @levies = HttpClient::Preconditions.assert_class('levies', opts.delete(:levies), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Levy) ? x : ::Io::Flow::V0::Models::Levy.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDisplay.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :levies => levies.map { |o| o.value }
            }
          end

        end

        class PriceEquation

          attr_reader :base_price, :conversion, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax, :rounding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base_price, :conversion, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax], 'PriceEquation')
            @base_price = HttpClient::Preconditions.assert_class('base_price', HttpClient::Helper.to_big_decimal(opts.delete(:base_price)), BigDecimal)
            @conversion = (x = opts.delete(:conversion); x.is_a?(::Io::Flow::V0::Models::Conversion) ? x : ::Io::Flow::V0::Models::Conversion.new(x))
            @fixed_margin = (x = opts.delete(:fixed_margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @percent_margin = (x = opts.delete(:percent_margin); x.is_a?(::Io::Flow::V0::Models::Margin) ? x : ::Io::Flow::V0::Models::Margin.new(x))
            @insurance = HttpClient::Preconditions.assert_class('insurance', HttpClient::Helper.to_big_decimal(opts.delete(:insurance)), BigDecimal)
            @freight = HttpClient::Preconditions.assert_class('freight', HttpClient::Helper.to_big_decimal(opts.delete(:freight)), BigDecimal)
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
            @rounding = (x = opts.delete(:rounding); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceEquation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base_price => base_price,
              :conversion => conversion.to_hash,
              :fixed_margin => fixed_margin.to_hash,
              :percent_margin => percent_margin.to_hash,
              :insurance => insurance,
              :freight => freight,
              :duty => duty.to_hash,
              :tax => tax.to_hash,
              :rounding => rounding.nil? ? nil : rounding.to_hash
            }
          end

        end

        # Amount-currency paid for a basic price to be used in model forms, before a
        # price label is created. Label in the main price model is created by the
        # implementing api.
        class PriceForm

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'PriceForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Represents a typed query to indicate which items to include or exclude in a
        # subcatalog
        class Query

          attr_reader :id, :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :type], 'Query')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Query.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :type => type.value
            }
          end

        end

        # Defines a query specifying items to be included or excluded in a subcatalog
        class QueryForm

          attr_reader :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :type], 'QueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :type => type.value
            }
          end

        end

        # Represents a collection of deliveries and available options for fulfillment of
        # that delivery
        class Quote

          attr_reader :id, :destination, :deliveries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination, :deliveries], 'Quote')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Quote.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash }
            }
          end

        end

        class QuoteForm

          attr_reader :destination, :experience, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :experience, :items], 'QuoteForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :experience => experience,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class QuoteSummary

          attr_reader :id, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination], 'QuoteSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash
            }
          end

        end

        class QuoteVersion

          attr_reader :id, :timestamp, :type, :quote

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :quote], 'QuoteVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @quote = (x = opts.delete(:quote); x.is_a?(::Io::Flow::V0::Models::QuoteSummary) ? x : ::Io::Flow::V0::Models::QuoteSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :quote => quote.to_hash
            }
          end

        end

        # Refunds are used to issue refunds against a prior capture.
        class Refund

          attr_reader :id, :reference, :capture, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :capture, :amount, :currency], 'Refund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Refund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :reference => reference,
              :capture => capture.to_hash,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Refund actually transfers funds. You can refund as many times as you'd like up
        # until the total amount of the capture has been refunded.
        class RefundForm

          attr_reader :capture_id, :reference, :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capture_id], 'RefundForm')
            @capture_id = HttpClient::Preconditions.assert_class('capture_id', opts.delete(:capture_id), String)
            @reference = (x = opts.delete(:reference); x.nil? ? nil : HttpClient::Preconditions.assert_class('reference', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capture_id => capture_id,
              :reference => reference,
              :amount => amount,
              :currency => currency
            }
          end

        end

        class RefundVersion

          attr_reader :id, :timestamp, :type, :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :refund], 'RefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :refund => refund.to_hash
            }
          end

        end

        # A region represents a geographic area of the world. Regions can be countries,
        # continents or other political areas (like the Eurozone).
        class Region

          attr_reader :id, :name, :countries, :currencies, :languages, :measurement_systems

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :countries, :currencies, :languages, :measurement_systems], 'Region')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_systems = HttpClient::Preconditions.assert_class('measurement_systems', opts.delete(:measurement_systems), Array).map { |v| HttpClient::Preconditions.assert_class('measurement_systems', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Region.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :countries => countries,
              :currencies => currencies,
              :languages => languages,
              :measurement_systems => measurement_systems
            }
          end

        end

        class RegionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RegionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class Rounding < Adjustment

          attr_reader :name, :method, :value

          def initialize(incoming={})
            super(:name => Adjustment::Types::ROUNDING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :method, :value], 'Rounding')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::AdjustmentType) ? x : ::Io::Flow::V0::Models::AdjustmentType.apply(x))
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::RoundingMethod) ? x : ::Io::Flow::V0::Models::RoundingMethod.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rounding.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :name => name.value,
              :method => method.value,
              :value => value
            }
          end

        end

        # Represents operating calendar and holidays of a location
        class Schedule

          attr_reader :calendar, :holiday, :exception, :cutoff

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:holiday, :exception], 'Schedule')
            @calendar = (x = opts.delete(:calendar); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Calendar) ? x : ::Io::Flow::V0::Models::Calendar.apply(x)))
            @holiday = (x = opts.delete(:holiday); x.is_a?(::Io::Flow::V0::Models::HolidayCalendar) ? x : ::Io::Flow::V0::Models::HolidayCalendar.apply(x))
            @exception = HttpClient::Preconditions.assert_class('exception', opts.delete(:exception), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Exception) ? x : ::Io::Flow::V0::Models::Exception.new(x)) }
            @cutoff = (x = opts.delete(:cutoff); x.nil? ? nil : HttpClient::Preconditions.assert_class('cutoff', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Schedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :calendar => calendar.nil? ? nil : calendar.value,
              :holiday => holiday.value,
              :exception => exception.map { |o| o.to_hash },
              :cutoff => cutoff
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class Service

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'Service')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Service.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class ServiceForm

          attr_reader :name, :carrier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :carrier], 'ServiceForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :carrier => carrier
            }
          end

        end

        class ServiceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ServiceSummary

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'ServiceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class ServiceVersion

          attr_reader :id, :timestamp, :type, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :service], 'ServiceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :service => service.to_hash
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment. Flow provides a generated tracking number to track this shipment
        # across multiple possible hops and carriers.
        class Shipment

          attr_reader :id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :commercial_invoice, :destination, :items, :shipment_labels, :tracking_number], 'Shipment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = HttpClient::Preconditions.assert_class('shipment_labels', opts.delete(:shipment_labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabel) ? x : ::Io::Flow::V0::Models::ShipmentLabel.new(x)) }
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Shipment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :commercial_invoice => commercial_invoice,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.map { |o| o.to_hash },
              :tracking_number => tracking_number
            }
          end

        end

        # Represents a subset of items from an order grouped into a single physical
        # shipment.
        class ShipmentForm

          attr_reader :destination, :items, :shipment_labels

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :items], 'ShipmentForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @shipment_labels = (x = opts.delete(:shipment_labels); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment_labels', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShipmentLabelForm) ? x : ::Io::Flow::V0::Models::ShipmentLabelForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :shipment_labels => shipment_labels.nil? ? nil : shipment_labels.map { |o| o.to_hash }
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabel

          attr_reader :id, :service, :tracking_number, :window, :pdf, :zpl

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :tracking_number], 'ShipmentLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x))
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :pdf => pdf,
              :zpl => zpl
            }
          end

        end

        # Top-level information on shipment tracking shipment_label and number
        class ShipmentLabelForm

          attr_reader :service, :tracking_number, :window, :data, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service, :tracking_number], 'ShipmentLabelForm')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @data = (x = opts.delete(:data); x.nil? ? nil : HttpClient::Preconditions.assert_class('data', x, String))
            @shipment = (x = opts.delete(:shipment); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipment', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :data => data,
              :shipment => shipment
            }
          end

        end

        class ShipmentLabelReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentLabelReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentLabelSummary

          attr_reader :id, :service, :tracking_number, :window, :pdf, :zpl

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :service, :tracking_number], 'ShipmentLabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :service => service.to_hash,
              :tracking_number => tracking_number,
              :window => window.nil? ? nil : window.to_hash,
              :pdf => pdf,
              :zpl => zpl
            }
          end

        end

        class ShipmentLabelVersion

          attr_reader :id, :timestamp, :type, :shipment_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment_label], 'ShipmentLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment_label = (x = opts.delete(:shipment_label); x.is_a?(::Io::Flow::V0::Models::ShipmentLabelSummary) ? x : ::Io::Flow::V0::Models::ShipmentLabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment_label => shipment_label.to_hash
            }
          end

        end

        class ShipmentReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ShipmentReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ShipmentSummary

          attr_reader :id, :commercial_invoice, :destination, :items, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :commercial_invoice, :destination, :items, :tracking_number], 'ShipmentSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ItemSummary) ? x : ::Io::Flow::V0::Models::ItemSummary.new(x)) }
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :commercial_invoice => commercial_invoice,
              :destination => destination.to_hash,
              :items => items.map { |o| o.to_hash },
              :tracking_number => tracking_number
            }
          end

        end

        class ShipmentVersion

          attr_reader :id, :timestamp, :type, :shipment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipment], 'ShipmentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipment = (x = opts.delete(:shipment); x.is_a?(::Io::Flow::V0::Models::ShipmentSummary) ? x : ::Io::Flow::V0::Models::ShipmentSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShipmentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipment => shipment.to_hash
            }
          end

        end

        # A configuration with custom query to select a subset of master catalog items
        # for a localized experience
        class Subcatalog < ExpandableSubcatalog

          attr_reader :id, :catalog, :settings

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :settings], 'Subcatalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::SubcatalogSettings) ? x : ::Io::Flow::V0::Models::SubcatalogSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Subcatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :catalog => catalog.to_hash,
              :settings => settings.to_hash
            }
          end

        end

        class SubcatalogForm

          attr_reader :settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @settings = (x = opts.delete(:settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :settings => settings.nil? ? nil : settings.to_hash
            }
          end

        end

        class SubcatalogItem

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogReference < ExpandableSubcatalog

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableSubcatalog::Types::SUBCATALOG_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogSettings

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.value
            }
          end

        end

        class SubcatalogSettingsForm

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.nil? ? nil : update_policy.value
            }
          end

        end

        class SubcatalogVersion

          attr_reader :id, :timestamp, :type, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog], 'SubcatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::Subcatalog) ? x : ::Io::Flow::V0::Models::Subcatalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class Suggestion

          attr_reader :label, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label, :count], 'Suggestion')
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Suggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label => label,
              :count => count
            }
          end

        end

        # Represents a simple model of taxes that apply to a given item / destination.
        class Tax

          attr_reader :name, :rate, :components, :deminimus

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rate, :components], 'Tax')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimus = (x = opts.delete(:deminimus); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimus) ? x : ::Io::Flow::V0::Models::Deminimus.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tax.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimus => deminimus.nil? ? nil : deminimus.to_hash
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class Tier

          attr_reader :id, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'Tier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class TierForm

          attr_reader :currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'TierForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :experience => experience,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # System to filter incoming quote for a shipment request based on a query and
        # output corresponding outcomes.
        class TierRule

          attr_reader :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:query, :outcome], 'TierRule')
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierSummary

          attr_reader :id, :experience, :integration, :name, :rules, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'TierSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierVersion

          attr_reader :id, :timestamp, :type, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier], 'TierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier => tier.to_hash
            }
          end

        end

        # Time zone data is provided by the public IANA time zone database. See
        # http://www.iana.org/time-zones
        class Timezone

          attr_reader :name, :description, :offset

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :offset], 'Timezone')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @offset = HttpClient::Preconditions.assert_class('offset', opts.delete(:offset), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Timezone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :offset => offset
            }
          end

        end

        # All of the metadata associated with a given token.
        class Token

          attr_reader :id, :user, :partial, :created_at, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user, :partial, :created_at], 'Token')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Token.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to authenticate a given token.
        class TokenAuthenticationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenAuthenticationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenAuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Used to create a new token for the user authorized by the request. You can
        # only create an API token for your own account.
        class TokenForm

          attr_reader :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description
            }
          end

        end

        # Summary data for a given token
        class TokenReference

          attr_reader :id, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user], 'TokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash
            }
          end

        end

        class TokenVersion

          attr_reader :id, :timestamp, :type, :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :token], 'TokenVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @token = (x = opts.delete(:token); x.is_a?(::Io::Flow::V0::Models::Token) ? x : ::Io::Flow::V0::Models::Token.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :token => token.to_hash
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class Tracking

          attr_reader :id, :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :metadata], 'Tracking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @metadata = HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(opts.delete(:metadata)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tracking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :metadata => metadata
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class TrackingForm

          attr_reader :status, :metadata

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x)))
            @metadata = (x = opts.delete(:metadata); x.nil? ? nil : HttpClient::Preconditions.assert_class('metadata', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.nil? ? nil : status.value,
              :metadata => metadata
            }
          end

        end

        class TrackingSummary

          attr_reader :id, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status], 'TrackingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value
            }
          end

        end

        class TrackingVersion

          attr_reader :id, :timestamp, :type, :tracking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking], 'TrackingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking => tracking.to_hash
            }
          end

        end

        # Represents a single user in the system
        class User < ExpandableUser

          attr_reader :id, :email, :name

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'User')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            User.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :email => email,
              :name => name.to_hash
            }
          end

        end

        class UserForm

          attr_reader :email, :password, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserPutForm

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserReference < ExpandableUser

          attr_reader :id

          def initialize(incoming={})
            super(:name => ExpandableUser::Types::USER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'UserReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class UserSummary

          attr_reader :id, :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'UserSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :email => email,
              :name => name
            }
          end

        end

        class UserVersion

          attr_reader :id, :timestamp, :type, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :user], 'UserVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :user => user.to_hash
            }
          end

        end

        # Model used to report whether or not a given token is valid
        class Validation

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Validation')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Validation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Defines the payload of a request to validate a token, with primary goal of
        # preventing the token from being included in an HTTP GET.
        class ValidationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'ValidationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ValidationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

      end

      # ===== END OF SERVICE DEFINITION =====
      module HttpClient

        class Request

          def initialize(uri)
            @uri = Preconditions.assert_class('uri', uri, URI)
            @params = nil
            @body = nil
            @auth = nil
            @headers = {}
            @header_keys_lower_case = []
          end

          def with_header(name, value)
            Preconditions.check_not_blank('name', name, "Header name is required")
            Preconditions.check_not_blank('value', value, "Header value is required")
            Preconditions.check_state(!@headers.has_key?(name),
                                      "Duplicate header named[%s]" % name)
            @headers[name] = value
            @header_keys_lower_case << name.downcase
            self
          end

          def with_auth(auth)
            Preconditions.assert_class('auth', auth, HttpClient::Authorization)
            Preconditions.check_state(@auth.nil?, "auth previously set")

            if auth.scheme.name == AuthScheme::BASIC.name
              @auth = auth
            else
              raise "Auth Scheme[#{auth.scheme.name}] not supported"
            end
            self
          end

          def with_query(params)
            Preconditions.assert_class('params', params, Hash)
            Preconditions.check_state(@params.nil?, "Already have query parameters")
            @params = params
            self
          end

          # Wrapper to set Content-Type header to application/json and set
          # the provided json document as the body
          def with_json(json)
            @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
            with_body(json)
          end

          def with_body(body)
            Preconditions.check_not_blank('body', body)
            @body = body
            self
          end

          # Creates a new Net:HTTP client. The client returned should be
          # fully configured to make a request.
          def new_http_client
            client = Net::HTTP.new(@uri.host, @uri.port)
            if @uri.scheme == "https"
              configure_ssl(client)
            end
            client
          end

          # If HTTPS is required, this method accepts an HTTP Client and configures SSL
          def configure_ssl(http)
            Preconditions.assert_class('http', http, Net::HTTP)
            http.use_ssl = true
            http.verify_mode = OpenSSL::SSL::VERIFY_PEER
            http.cert_store = OpenSSL::X509::Store.new
            http.cert_store.set_default_paths
          end

          def get(&block)
            do_request(Net::HTTP::Get, &block)
          end

          def delete(&block)
            do_request(Net::HTTP::Delete, &block)
          end

          def options(&block)
            do_request(Net::HTTP::Options, &block)
          end

          def post(&block)
            do_request(Net::HTTP::Post, &block)
          end

          def put(&block)
            do_request(Net::HTTP::Put, &block)
          end

          class PATCH < Net::HTTP::Put
            METHOD = "PATCH"
          end

          def patch(&block)
            do_request(PATCH, &block)
          end

          def do_request(klass)
            Preconditions.assert_class('klass', klass, Class)

            uri = @uri.to_s
            if q = to_query(@params)
              uri += "?%s" % q
            end

            request = klass.send(:new, uri)

            curl = ['curl']
            if klass != Net::HTTP::Get
              curl << "-X%s" % klass.name.split("::").last.upcase
            end

            if @body
              # DEBUG path = "/tmp/rest_client.tmp"
              # DEBUG File.open(path, "w") { |os| os << @body.to_s }
              # DEBUG curl << "-d@%s" % path
              request.body = @body
            end

            if @auth
              curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
              Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                        "Cannot specify both an Authorization header and an auth instance")
              user_pass = "%s:%s" % [@auth.username, @auth.password]
              encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
              request.add_field("Authorization", "Basic %s" % encoded)
            end

            @headers.each { |key, value|
              curl <<  "-H \"%s: %s\"" % [key, value]
              request.add_field(key, value)
            }

            curl << "'%s'" % uri
            # DEBUG puts curl.join(" ")

            raw_response = http_request(request)
            response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

            if block_given?
              yield response
            else
              response
            end
          end

          private
          def to_query(params={})
            parts = (params || {}).map { |k,v|
              if v.respond_to?(:each)
                v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
              else
                "%s=%s" % [k, CGI.escape(v.to_s)]
              end
            }
            parts.empty? ? nil : parts.join("&")
          end

          def http_request(request)
            response = begin
                         new_http_client.request(request)
                       rescue SocketError => e
                         raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                       end

            case response
            when Net::HTTPSuccess
              response.body
            else
              body = response.body rescue nil
              raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
            end
          end
        end

        class ServerError < StandardError

          attr_reader :code, :details, :body, :uri

          def initialize(code, details, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @code = HttpClient::Preconditions.assert_class('code', code, Integer)
            @details = HttpClient::Preconditions.assert_class('details', details, String)
            @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
            @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
            super(self.message)
          end

          def message
            m = "%s %s" % [@code, @details]
            if @body
              m << ": %s" % @body
            end
            m
          end

          def body_json
            JSON.parse(@body)
          end

        end

        class PreconditionException < Exception

          attr_reader :message

          def initialize(message)
            super(message)
            @message = message
          end

        end

        module Preconditions

          def Preconditions.check_argument(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_argument failed")
            end
            nil
          end

          def Preconditions.check_state(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_state failed")
            end
            nil
          end

          def Preconditions.check_not_nil(field_name, reference, error_message=nil)
            if reference.nil?
              raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
            end
            reference
          end

          def Preconditions.check_not_blank(field_name, reference, error_message=nil)
            if reference.to_s.strip == ""
              raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
            end
            reference
          end

          # Throws an error if opts is not empty. Useful when parsing
          # arguments to a function
          def Preconditions.assert_empty_opts(opts)
            if !opts.empty?
              raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
            end
          end

          # Requires that the provided hash has the specified keys.
          # @param fields A list of symbols
          def Preconditions.require_keys(hash, fields, error_prefix=nil)
            missing = fields.select { |f| !hash.has_key?(f) }
            if !missing.empty?
              msg = "Missing required fields: " + missing.join(", ")
              raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
            end
          end

          # Asserts that value is not nill and is_?(klass). Returns
          # value. Common use is
          #
          # amount = Preconditions.assert_class('amount', amount, BigDecimal)
          def Preconditions.assert_class(field_name, value, klass)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('klass', klass)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
            Preconditions.check_state(value.is_a?(klass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_class_or_nil(field_name, value, klass)
            if !value.nil?
              Preconditions.assert_class(field_name, value, klass)
            end
          end

          def Preconditions.assert_boolean(field_name, value)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
            Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_boolean_or_nil(field_name, value)
            if !value.nil?
              Preconditions.assert_boolean(field_name, value)
            end
          end

          def Preconditions.assert_collection_of_class(field_name, values, klass)
            Preconditions.assert_class(field_name, values, Array)
            values.each { |v| Preconditions.assert_class(field_name, v, klass) }
          end

          def Preconditions.assert_hash_of_class(field_name, hash, klass)
            Preconditions.assert_class(field_name, hash, Hash)
            values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
          end

        end

        class AuthScheme

          attr_reader :name

          def initialize(name)
            @name = HttpClient::Preconditions.check_not_blank('name', name)
          end

          BASIC = AuthScheme.new("basic") unless defined?(BASIC)

        end

        class Authorization

          attr_reader :scheme, :username, :password

          def initialize(scheme, username, opts={})
            @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
            @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
            @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
          end

          def Authorization.basic(username, password=nil)
            Authorization.new(AuthScheme::BASIC, username, :password => password)
          end

        end

        module Helper

          def Helper.symbolize_keys(hash)
            Preconditions.assert_class('hash', hash, Hash)
            new_hash = {}
            hash.each { |k, v|
              new_hash[k.to_sym] = v
            }
            new_hash
          end

          def Helper.to_big_decimal(value)
            value ? BigDecimal.new(value.to_s) : nil
          end

          def Helper.to_object(value)
            value ? JSON.parse(value) : nil
          end

          def Helper.to_uuid(value)
            Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                      "Invalid guid[%s]" % value)
            value
          end

          def Helper.to_date_iso8601(value)
            if value.is_a?(Date)
              value
            elsif value
              Date.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.to_date_time_iso8601(value)
            if value.is_a?(DateTime)
              value
            elsif value
              DateTime.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.date_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%d')
          end

          def Helper.date_time_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
          end

          TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
          FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

          def Helper.to_boolean(field_name, value)
            string = value.to_s.strip.downcase
            if TRUE_STRINGS.include?(string)
              true
            elsif FALSE_STRINGS.include?(string)
              false
            elsif string != ""
              raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
            else
              nil
            end
          end

        end

      end
    end
  end
end