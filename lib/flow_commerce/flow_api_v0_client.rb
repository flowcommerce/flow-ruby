# Generated by apidoc - http://www.apidoc.me
# Service version: 0.3.26
# apidoc:0.11.78 http://www.apidoc.me/flow/api/0.3.26/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# The Flow Commerce REST API provides full access to the global ecommerce
# platform.
module Io
  module Flow
    module V0

      class Client

        module Constants

          BASE_URL = 'https://api.flow.io' unless defined?(Constants::BASE_URL)
          NAMESPACE = 'io.flow.v0' unless defined?(Constants::NAMESPACE)
          USER_AGENT = 'apidoc:0.11.78 http://www.apidoc.me/flow/api/0.3.26/ruby_client' unless defined?(Constants::USER_AGENT)
          VERSION = '0.3.26' unless defined?(Constants::VERSION)
          VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

        end

        attr_reader :url

        def initialize(url, opts={})
          @url = HttpClient::Preconditions.assert_class('url', url, String)
          @base_url = URI(url)
          @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
          @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
          @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

          HttpClient::Preconditions.assert_empty_opts(opts)
          HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
        end

        # Creates an instance of the client using the base url specified in the API spec.
        def Client.at_base_url(opts={})
          Client.new(Constants::BASE_URL, opts)
        end

        def request(path=nil)
          HttpClient::Preconditions.assert_class_or_nil('path', path, String)
          request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

          @default_headers.each do |key, value|
            request = request.with_header(key, value)
          end

          if @authorization
            request = request.with_auth(@authorization)
          end

          request
        end

        def allocations
          @allocations ||= ::Io::Flow::V0::Clients::Allocations.new(self)
        end

        def attributes
          @attributes ||= ::Io::Flow::V0::Clients::Attributes.new(self)
        end

        def catalogs
          @catalogs ||= ::Io::Flow::V0::Clients::Catalogs.new(self)
        end

        def experiences
          @experiences ||= ::Io::Flow::V0::Clients::Experiences.new(self)
        end

        def experience_defaults
          @experience_defaults ||= ::Io::Flow::V0::Clients::ExperienceDefaults.new(self)
        end

        def items
          @items ||= ::Io::Flow::V0::Clients::Items.new(self)
        end

        def orders
          @orders ||= ::Io::Flow::V0::Clients::Orders.new(self)
        end

        def order_estimates
          @order_estimates ||= ::Io::Flow::V0::Clients::OrderEstimates.new(self)
        end

        def order_identifiers
          @order_identifiers ||= ::Io::Flow::V0::Clients::OrderIdentifiers.new(self)
        end

        def organizations
          @organizations ||= ::Io::Flow::V0::Clients::Organizations.new(self)
        end

        def queries
          @queries ||= ::Io::Flow::V0::Clients::Queries.new(self)
        end

        def subcatalogs
          @subcatalogs ||= ::Io::Flow::V0::Clients::Subcatalogs.new(self)
        end

        def subcatalog_items
          @subcatalog_items ||= ::Io::Flow::V0::Clients::SubcatalogItems.new(self)
        end

        def targetings
          @targetings ||= ::Io::Flow::V0::Clients::Targetings.new(self)
        end

        def targeting_items
          @targeting_items ||= ::Io::Flow::V0::Clients::TargetingItems.new(self)
        end

        def item_functions
          @item_functions ||= ::Io::Flow::V0::Clients::ItemFunctions.new(self)
        end

        def organization_currency_settings
          @organization_currency_settings ||= ::Io::Flow::V0::Clients::OrganizationCurrencySettings.new(self)
        end

        def rates
          @rates ||= ::Io::Flow::V0::Clients::Rates.new(self)
        end

        def harmonization_settings
          @harmonization_settings ||= ::Io::Flow::V0::Clients::HarmonizationSettings.new(self)
        end

        def harmonized_categories
          @harmonized_categories ||= ::Io::Flow::V0::Clients::HarmonizedCategories.new(self)
        end

        def harmonized_items
          @harmonized_items ||= ::Io::Flow::V0::Clients::HarmonizedItems.new(self)
        end

        def harmonized_item_duties
          @harmonized_item_duties ||= ::Io::Flow::V0::Clients::HarmonizedItemDuties.new(self)
        end

        def harmonized_landed_costs
          @harmonized_landed_costs ||= ::Io::Flow::V0::Clients::HarmonizedLandedCosts.new(self)
        end

        def hs10
          @hs10 ||= ::Io::Flow::V0::Clients::Hs10.new(self)
        end

        def hs6
          @hs6 ||= ::Io::Flow::V0::Clients::Hs6.new(self)
        end

        def hs_codes
          @hs_codes ||= ::Io::Flow::V0::Clients::HsCodes.new(self)
        end

        def authorizations
          @authorizations ||= ::Io::Flow::V0::Clients::Authorizations.new(self)
        end

        def captures
          @captures ||= ::Io::Flow::V0::Clients::Captures.new(self)
        end

        def cards
          @cards ||= ::Io::Flow::V0::Clients::Cards.new(self)
        end

        def payments
          @payments ||= ::Io::Flow::V0::Clients::Payments.new(self)
        end

        def public_keys
          @public_keys ||= ::Io::Flow::V0::Clients::PublicKeys.new(self)
        end

        def refunds
          @refunds ||= ::Io::Flow::V0::Clients::Refunds.new(self)
        end

        def centers
          @centers ||= ::Io::Flow::V0::Clients::Centers.new(self)
        end

        def delivery_windows
          @delivery_windows ||= ::Io::Flow::V0::Clients::DeliveryWindows.new(self)
        end

        def inventory_rules
          @inventory_rules ||= ::Io::Flow::V0::Clients::InventoryRules.new(self)
        end

        def inventory_snapshots
          @inventory_snapshots ||= ::Io::Flow::V0::Clients::InventorySnapshots.new(self)
        end

        def inventory_updates
          @inventory_updates ||= ::Io::Flow::V0::Clients::InventoryUpdates.new(self)
        end

        def quotes
          @quotes ||= ::Io::Flow::V0::Clients::Quotes.new(self)
        end

        def returns
          @returns ||= ::Io::Flow::V0::Clients::Returns.new(self)
        end

        def shipping_labels
          @shipping_labels ||= ::Io::Flow::V0::Clients::ShippingLabels.new(self)
        end

        def shipping_notifications
          @shipping_notifications ||= ::Io::Flow::V0::Clients::ShippingNotifications.new(self)
        end

        def tiers
          @tiers ||= ::Io::Flow::V0::Clients::Tiers.new(self)
        end

        def tier_defaults
          @tier_defaults ||= ::Io::Flow::V0::Clients::TierDefaults.new(self)
        end

        def tier_rules
          @tier_rules ||= ::Io::Flow::V0::Clients::TierRules.new(self)
        end

        def trackings
          @trackings ||= ::Io::Flow::V0::Clients::Trackings.new(self)
        end

        def tracking_events
          @tracking_events ||= ::Io::Flow::V0::Clients::TrackingEvents.new(self)
        end

        def tracking_labels
          @tracking_labels ||= ::Io::Flow::V0::Clients::TrackingLabels.new(self)
        end

        def webhooks
          @webhooks ||= ::Io::Flow::V0::Clients::Webhooks.new(self)
        end

        def webhook_deliveries
          @webhook_deliveries ||= ::Io::Flow::V0::Clients::WebhookDeliveries.new(self)
        end

        def addresses
          @addresses ||= ::Io::Flow::V0::Clients::Addresses.new(self)
        end

        def country_defaults
          @country_defaults ||= ::Io::Flow::V0::Clients::CountryDefaults.new(self)
        end

        def timezones
          @timezones ||= ::Io::Flow::V0::Clients::Timezones.new(self)
        end

        def countries
          @countries ||= ::Io::Flow::V0::Clients::Countries.new(self)
        end

        def currencies
          @currencies ||= ::Io::Flow::V0::Clients::Currencies.new(self)
        end

        def languages
          @languages ||= ::Io::Flow::V0::Clients::Languages.new(self)
        end

        def locales
          @locales ||= ::Io::Flow::V0::Clients::Locales.new(self)
        end

        def provinces
          @provinces ||= ::Io::Flow::V0::Clients::Provinces.new(self)
        end

        def regions
          @regions ||= ::Io::Flow::V0::Clients::Regions.new(self)
        end

        def documents
          @documents ||= ::Io::Flow::V0::Clients::Documents.new(self)
        end

        def email_verifications
          @email_verifications ||= ::Io::Flow::V0::Clients::EmailVerifications.new(self)
        end

        def exports
          @exports ||= ::Io::Flow::V0::Clients::Exports.new(self)
        end

        def feeds
          @feeds ||= ::Io::Flow::V0::Clients::Feeds.new(self)
        end

        def healthchecks
          @healthchecks ||= ::Io::Flow::V0::Clients::Healthchecks.new(self)
        end

        def imports
          @imports ||= ::Io::Flow::V0::Clients::Imports.new(self)
        end

        def invitations
          @invitations ||= ::Io::Flow::V0::Clients::Invitations.new(self)
        end

        def memberships
          @memberships ||= ::Io::Flow::V0::Clients::Memberships.new(self)
        end

        def organization_authorizations
          @organization_authorizations ||= ::Io::Flow::V0::Clients::OrganizationAuthorizations.new(self)
        end

        def organization_tokens
          @organization_tokens ||= ::Io::Flow::V0::Clients::OrganizationTokens.new(self)
        end

        def partner_tokens
          @partner_tokens ||= ::Io::Flow::V0::Clients::PartnerTokens.new(self)
        end

        def password_reset_forms
          @password_reset_forms ||= ::Io::Flow::V0::Clients::PasswordResetForms.new(self)
        end

        def scheduled_exports
          @scheduled_exports ||= ::Io::Flow::V0::Clients::ScheduledExports.new(self)
        end

        def sessions
          @sessions ||= ::Io::Flow::V0::Clients::Sessions.new(self)
        end

        def session_authorizations
          @session_authorizations ||= ::Io::Flow::V0::Clients::SessionAuthorizations.new(self)
        end

        def suggestions
          @suggestions ||= ::Io::Flow::V0::Clients::Suggestions.new(self)
        end

        def tokens
          @tokens ||= ::Io::Flow::V0::Clients::Tokens.new(self)
        end

        def token_validations
          @token_validations ||= ::Io::Flow::V0::Clients::TokenValidations.new(self)
        end

        def uploads
          @uploads ||= ::Io::Flow::V0::Clients::Uploads.new(self)
        end

        def users
          @users ||= ::Io::Flow::V0::Clients::Users.new(self)
        end
      end

      module Clients

        class Allocations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Order-level price details allocated using a strategy among individual order
          # item units.
          def get(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/allocations/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Allocation.new(r)
          end

        end

        class Attributes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search attributes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "key" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Attribute.new(x) }
          end

          # Add attribute
          def post(organization, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes").with_json(attribute_form.to_json).post
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Returns information about a specific attribute.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Create or update an attribute with the specified key.
          def put_by_key(organization, key, attribute_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('attribute_form', attribute_form, ::Io::Flow::V0::Models::AttributeForm)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").with_json(attribute_form.to_json).put
            ::Io::Flow::V0::Models::Attribute.new(r)
          end

          # Delete an attribute with the specified key.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/attributes/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/attributes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AttributeVersion.new(x) }
          end

        end

        class Catalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns information about a specific catalog.
          def get_catalog(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog").get
            ::Io::Flow::V0::Models::Catalog.new(r)
          end

          # Search global restrictions. Always paginated.
          def get_catalog_and_restrictions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns a spcifical globally restricted item.
          def get_catalog_and_restrictions_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Upsert a global restriction
          def put_catalog_and_restrictions_by_number(organization, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the global restriction for this catalog item number
          def delete_catalog_and_restrictions_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/restrictions/#{CGI.escape(number)}").delete
            nil
          end

          # Get statistics for this organization's catalog.
          def get_catalog_and_statistics(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/statistics").get
            ::Io::Flow::V0::Models::CatalogStatistics.new(r)
          end

        end

        class Experiences

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search experiences. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :region => (x = opts.delete(:region); x.nil? ? nil : HttpClient::Preconditions.assert_class('region', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :subcatalog => (x = opts.delete(:subcatalog); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Experience.new(x) }
          end

          # Add experience
          def post(organization, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences").with_json(experience_form.to_json).post
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          def get_margins_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMargin.new(x) }
          end

          def post_margins_by_experience_key(organization, experience_key, item_margin_post_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('item_margin_post_form', item_margin_post_form, ::Io::Flow::V0::Models::ItemMarginPostForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins").with_json(item_margin_post_form.to_json).post
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def get_margins_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def put_margins_by_experience_key_and_key(organization, experience_key, key, item_margin_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('item_margin_put_form', item_margin_put_form, ::Io::Flow::V0::Models::ItemMarginPutForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").with_json(item_margin_put_form.to_json).put
            ::Io::Flow::V0::Models::ItemMargin.new(r)
          end

          def delete_margins_by_experience_key_and_key(organization, experience_key, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/#{CGI.escape(key)}").delete
            nil
          end

          def get_margins_and_versions_by_experience_key(organization, experience_key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('experience_key', experience_key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(experience_key)}/margins/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemMarginVersion.new(x) }
          end

          # Returns information about a specific experience.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Update experience with the specified key, creating if it does not exist.
          def put_by_key(organization, key, experience_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('experience_form', experience_form, ::Io::Flow::V0::Models::ExperienceForm)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").with_json(experience_form.to_json).put
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          # Delete the experience with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}").delete
            nil
          end

          # Returns detailed information on the pricing of this item within this
          # experience
          def get_items_and_price_by_key_and_number(organization, key, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/items/#{CGI.escape(number)}/price").get
            ::Io::Flow::V0::Models::PriceCheck.new(r)
          end

          # Get the pricing settings for this experience
          def get_pricing_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").get
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Update the pricing settings for this experience
          def put_pricing_by_key(organization, key, pricing)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('pricing', pricing, ::Io::Flow::V0::Models::Pricing)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/pricing").with_json(pricing.to_json).put
            ::Io::Flow::V0::Models::Pricing.new(r)
          end

          # Get available promotions for the experience
          def get_promotions_and_available_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/experiences/#{CGI.escape(key)}/promotions/available").get
            r.map { |x| ::Io::Flow::V0::Models::Promotion.from_json(x) }
          end

          # Formats the requested amount using the formatting settings for the
          # experience.
          def get_conversions_by_base_and_amount(organization, base, amount, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('base', base, String)
            HttpClient::Preconditions.assert_class('amount', amount, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/conversions/#{CGI.escape(base)}/#{CGI.escape(amount)}").with_query(query).get
            ::Io::Flow::V0::Models::PriceWithBase.new(r)
          end

          # Returns localized information about 1 or more items. The items will be
          # localized based on the experience selected by the query parameters in the
          # order of experience, then country, then ip address.
          def get_items(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :status => (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x)).value }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about this item localized based on the query parameters
          def get_items_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/items/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experiences/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExperienceVersion.new(x) }
          end

        end

        class ExperienceDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns recommended default settings when creating a new experience
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :region_id => (x = opts.delete(:region_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('region_id', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/experience/defaults").with_query(query).get
            ::Io::Flow::V0::Models::ExperienceDefaults.new(r)
          end

        end

        class Items

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search items. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Add catalog item(s)
          def post(organization, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items").with_json(item_form.to_json).post
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Returns information about a specific item.
          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Update item with the specified number, creating if it does not exist.
          def put_by_number(organization, number, item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('item_form', item_form, ::Io::Flow::V0::Models::ItemForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").with_json(item_form.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete the item with this number
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemVersion.new(x) }
          end

        end

        class Orders

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search orders. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :identifier => (x = opts.delete(:identifier); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifier', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Order.new(x) }
          end

          # Create an order, using the localized information from the experience
          # selected by the query parameters. Note the order must be submitted before
          # its expiration
          def post(organization, order_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('order_form', order_form, ::Io::Flow::V0::Models::OrderForm)
            r = @client.request("/#{CGI.escape(organization)}/orders").with_query(query).with_json(order_form.to_json).post
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Returns information about a specific order.
          def get_by_number(organization, number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").with_query(query).get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Upserts an order. using the localized information from the experience
          # selected by the query parameters. Note the order must be submitted before
          # its expiration
          def put_by_number(organization, number, order_put_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String)),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('order_put_form', order_put_form, ::Io::Flow::V0::Models::OrderPutForm)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").with_query(query).with_json(order_put_form.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Delete an order. Note that production orders that have already been
          # submitted cannot be deleted (you will see a 422 response in these cases).
          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}").delete
            nil
          end

          # Submits an order. You will get a validation error if the order has already
          # expired (and a new quote could not be automatically recreated for a lower or
          # same price). This method is idempotent - submitting an order a second time
          # has no effect.
          def put_submissions_by_number(organization, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/orders/#{CGI.escape(number)}/submissions").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Returns information about a specific order using an identifier number
          def get_identifier_by_identifier_number(organization, identifier_number, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('identifier_number', identifier_number, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/identifier/#{CGI.escape(identifier_number)}").with_query(query).get
            ::Io::Flow::V0::Models::Order.new(r)
          end

          # Provides visibility into recent changes of each order, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/orders/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderVersion.new(x) }
          end

        end

        class OrderEstimates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Create an order estimate, using the localized information from the
          # experience selected by the query parameters. This is similar to the POST
          # orders endpoint, except this just returns an estimate and cannot be
          # submitted.
          def post(organization, order_estimate_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('order_estimate_form', order_estimate_form, ::Io::Flow::V0::Models::OrderEstimateForm)
            r = @client.request("/#{CGI.escape(organization)}/order-estimates").with_query(query).with_json(order_estimate_form.to_json).post
            ::Io::Flow::V0::Models::OrderEstimate.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/order-estimates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Experience.new(r)
          end

          def put_by_id(organization, id, order_estimate_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :currency => (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String)),
              :language => (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('order_estimate_form', order_estimate_form, ::Io::Flow::V0::Models::OrderEstimateForm)
            r = @client.request("/#{CGI.escape(organization)}/order-estimates/#{CGI.escape(id)}").with_query(query).with_json(order_estimate_form.to_json).put
            ::Io::Flow::V0::Models::OrderEstimate.new(r)
          end

        end

        class OrderIdentifiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderIdentifier.new(x) }
          end

          def post(organization, order_identifier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('order_identifier_form', order_identifier_form, ::Io::Flow::V0::Models::OrderIdentifierForm)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers").with_json(order_identifier_form.to_json).post
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def put_by_number(organization, number, order_identifier_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('order_identifier_put_form', order_identifier_put_form, ::Io::Flow::V0::Models::OrderIdentifierPutForm)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(number)}").with_json(order_identifier_put_form.to_json).put
            ::Io::Flow::V0::Models::OrderIdentifier.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/#{CGI.escape(number)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/order-identifiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrderIdentifierVersion.new(x) }
          end

        end

        class Organizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # The countries resources provides a unique list of all of the countries for
          # which an experience exists. We generate this list of countries by iterating
          # through all of the experience regions, and collecting all of the countries.
          def get_countries_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

          # List of all destination countries available for this organization, including
          # countries within a world experience.
          def get_countries_and_destinations_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/countries/destinations").get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

          # Search organizations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
              :environment => (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)).value),
              :parent => (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Organization.new(x) }
          end

          # Create a new organization.
          def post(organization_form)
            HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Io::Flow::V0::Models::OrganizationForm)
            r = @client.request("/organizations").with_json(organization_form.to_json).post
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Returns information about a specific organization.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Update or create an organization with the specified id.
          def put_by_id(id, organization_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('organization_put_form', organization_put_form, ::Io::Flow::V0::Models::OrganizationPutForm)
            r = @client.request("/organizations/#{CGI.escape(id)}").with_json(organization_put_form.to_json).put
            ::Io::Flow::V0::Models::Organization.new(r)
          end

          # Delete the organization with this id
          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/organizations/#{CGI.escape(id)}").delete
            nil
          end

          # Returns currencies for a specific organization.
          def get_settings_and_currencies_by_organization_id(organization_id)
            HttpClient::Preconditions.assert_class('organization_id', organization_id, String)
            r = @client.request("/organizations/#{CGI.escape(organization_id)}/settings/currencies").get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, Array).map { |v| HttpClient::Preconditions.assert_class('organization', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/organizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationVersion.new(x) }
          end

        end

        class Queries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_validations(organization, values)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_collection_of_class('strings', strings, ::Io::Flow::V0::Models::String)
            r = @client.request("/#{CGI.escape(organization)}/query/validations").with_json(strings.to_json).post
            ::Io::Flow::V0::Models::QueryValidation.new(r)
          end

        end

        class Subcatalogs

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalogs. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Subcatalog.new(x) }
          end

          # Add subcatalog
          def post(organization, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs").with_json(subcatalog_form.to_json).post
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Returns information about a specific subcatalog.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Update subcatalog with the specified id, creating if it does not exist.
          def put_by_id(organization, id, subcatalog_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_form', subcatalog_form, ::Io::Flow::V0::Models::SubcatalogForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").with_json(subcatalog_form.to_json).put
            ::Io::Flow::V0::Models::Subcatalog.new(r)
          end

          # Delete the subcatalog with this id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}").delete
            nil
          end

          # Returns information about a specific subcatalog's settings.
          def get_settings_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").get
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Update subcatalog settings for the specified subcatalog.
          def put_settings_by_id(organization, id, subcatalog_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('subcatalog_settings_form', subcatalog_settings_form, ::Io::Flow::V0::Models::SubcatalogSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(id)}/settings").with_json(subcatalog_settings_form.to_json).put
            ::Io::Flow::V0::Models::SubcatalogSettings.new(r)
          end

          # Search exclusions. Always paginated.
          def get_exclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific exclusion by catalog item number.
          def get_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add exclusion
          def put_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an exclusion with this catalog item number
          def delete_exclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/exclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Gets the ordered list of item functions for this subcatalog
          def get_functions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogFunction.new(x) }
          end

          # Associates a function with this subcatalog
          def post_functions_by_subcatalog_id(organization, subcatalog_id, subcatalog_function_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('subcatalog_function_form', subcatalog_function_form, ::Io::Flow::V0::Models::SubcatalogFunctionForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions").with_json(subcatalog_function_form.to_json).post
            ::Io::Flow::V0::Models::SubcatalogFunction.new(r)
          end

          def get_functions_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::SubcatalogFunction.new(r)
          end

          # Deletes the subcatalog item function - note that this removes the
          # association between the function and subcatalog / does not actually delete
          # the function itself.
          def delete_functions_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_functions_and_versions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogFunctionVersion.new(x) }
          end

          # Search inclusions. Always paginated.
          def get_inclusions_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Item.new(x) }
          end

          # Returns information about a specific inclusion by catalog item number.
          def get_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Add inclusion
          def put_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Item.new(r)
          end

          # Delete an inclusion with this catalog item number
          def delete_inclusions_by_subcatalog_id_and_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/inclusions/#{CGI.escape(number)}").delete
            nil
          end

          # Search queries. Always paginated.
          def get_queries_by_subcatalog_id(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, Array).map { |v| HttpClient::Preconditions.assert_class('type', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Query.new(x) }
          end

          # Add query
          def post_queries_by_subcatalog_id(organization, subcatalog_id, query_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('query_form', query_form, ::Io::Flow::V0::Models::QueryForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries").with_json(query_form.to_json).post
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Returns information about a specific query.
          def get_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Query.new(r)
          end

          # Delete a query with this id
          def delete_queries_by_subcatalog_id_and_id(organization, subcatalog_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/queries/#{CGI.escape(id)}").delete
            nil
          end

          # Get statistics for the specified subcatalog
          def get_statistics_by_subcatalog_id(organization, subcatalog_id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/statistics").get
            ::Io::Flow::V0::Models::SubcatalogStatistics.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogVersion.new(x) }
          end

        end

        class SubcatalogItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search subcatalog items. Always paginated.
          def get(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :status => (x = opts.delete(:status); x.nil? ? nil : HttpClient::Preconditions.assert_class('status', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogItem.new(x) }
          end

          # Returns information about specific subcatalog items.
          def get_by_number(organization, subcatalog_id, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::SubcatalogItem.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, subcatalog_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('subcatalog_id', subcatalog_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/subcatalogs/#{CGI.escape(subcatalog_id)}/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::SubcatalogItemVersion.new(x) }
          end

        end

        class Targetings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Targeting.new(x) }
          end

          def post(organization, targeting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('targeting_form', targeting_form, ::Io::Flow::V0::Models::TargetingForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings").with_json(targeting_form.to_json).post
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def put_by_key(organization, key, targeting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('targeting_form', targeting_form, ::Io::Flow::V0::Models::TargetingForm)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").with_json(targeting_form.to_json).put
            ::Io::Flow::V0::Models::Targeting.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/#{CGI.escape(key)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/targetings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TargetingVersion.new(x) }
          end

        end

        class TargetingItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/catalog/targeting-items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TargetingItem.new(x) }
          end

        end

        class ItemFunctions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search item functions. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/item-functions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemFunction.new(x) }
          end

          # Create item function
          def post(organization, item_function_post_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('item_function_post_form', item_function_post_form, ::Io::Flow::V0::Models::ItemFunctionPostForm)
            r = @client.request("/#{CGI.escape(organization)}/item-functions").with_json(item_function_post_form.to_json).post
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Returns information about a specific item function.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Upsert item function
          def put_by_key(organization, key, item_function_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('item_function_put_form', item_function_put_form, ::Io::Flow::V0::Models::ItemFunctionPutForm)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").with_json(item_function_put_form.to_json).put
            ::Io::Flow::V0::Models::ItemFunction.new(r)
          end

          # Delete the item function with this key
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/item-functions/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/item-functions/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ItemFunctionVersion.new(x) }
          end

        end

        class OrganizationCurrencySettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency settings. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x) }
          end

          # Create organization currency settings.
          def post(organization, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('organization_currency_setting_form', organization_currency_setting_form, ::Io::Flow::V0::Models::OrganizationCurrencySettingForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings").with_json(organization_currency_setting_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Update an existing organization currency setting by id.
          def put_by_id(organization, id, organization_currency_setting_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('organization_currency_setting_form', organization_currency_setting_form, ::Io::Flow::V0::Models::OrganizationCurrencySettingForm)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").with_json(organization_currency_setting_form.to_json).put
            ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(r)
          end

          # Delete the organization currency setting with this id.
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/settings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationCurrencySettingVersion.new(x) }
          end

        end

        class Rates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search organization currency conversion rates. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, Array).map { |v| HttpClient::Preconditions.assert_class('base', v, String) }),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Rate.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :base => (x = opts.delete(:base); x.nil? ? nil : HttpClient::Preconditions.assert_class('base', x, String)),
              :target => (x = opts.delete(:target); x.nil? ? nil : HttpClient::Preconditions.assert_class('target', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/currency/rates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RateVersion.new(x) }
          end

        end

        class HarmonizationSettings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").get
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

          def put(organization, harmonization_settings_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonization_settings_form', harmonization_settings_form, ::Io::Flow::V0::Models::HarmonizationSettingsForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/settings").with_json(harmonization_settings_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizationSettings.new(r)
          end

        end

        class HarmonizedCategories

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :parent_id => (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/categories").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedCategory.new(x) }
          end

        end

        class HarmonizedItems

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItem.new(x) }
          end

          def post(organization, harmonized_item_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_form', harmonized_item_form, ::Io::Flow::V0::Models::HarmonizedItemForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items").with_json(harmonized_item_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def get_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").get
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          # Create or update an item to harmonize
          def put_by_number(organization, number, harmonized_item_put_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            HttpClient::Preconditions.assert_class('harmonized_item_put_form', harmonized_item_put_form, ::Io::Flow::V0::Models::HarmonizedItemPutForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").with_json(harmonized_item_put_form.to_json).put
            ::Io::Flow::V0::Models::HarmonizedItem.new(r)
          end

          def delete_by_number(organization, number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('number', number, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/#{CGI.escape(number)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_id => (x = opts.delete(:item_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/items/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemVersion.new(x) }
          end

        end

        class HarmonizedItemDuties

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :number => (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, Array).map { |v| HttpClient::Preconditions.assert_class('number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x) }
          end

          def post(organization, harmonized_item_duty_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_item_duty_form', harmonized_item_duty_form, ::Io::Flow::V0::Models::HarmonizedItemDutyForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties").with_json(harmonized_item_duty_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::HarmonizedItemDuty.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :harmonized_item_duty_id => (x = opts.delete(:harmonized_item_duty_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('harmonized_item_duty_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('harmonized_item_duty_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/item-duties/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizedItemDutyVersion.new(x) }
          end

        end

        class HarmonizedLandedCosts

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Single operation that provides harmonization landed costs (i.e. duties and
          # taxes) for 1 or more items. This method is designed to enable a single call
          # from applications that need it (like checkout) to get all data for a
          # collection of items
          def post(organization, harmonized_landed_cost_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('harmonized_landed_cost_form', harmonized_landed_cost_form, ::Io::Flow::V0::Models::HarmonizedLandedCostForm)
            r = @client.request("/#{CGI.escape(organization)}/harmonization/landed-costs").with_json(harmonized_landed_cost_form.to_json).post
            ::Io::Flow::V0::Models::HarmonizedLandedCost.new(r)
          end

        end

        class Hs10

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs10_id => (x = opts.delete(:hs10_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs10_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs10_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs10/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs10Version.new(x) }
          end

        end

        class Hs6

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6.new(x) }
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :hs6_id => (x = opts.delete(:hs6_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('hs6_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('hs6_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/harmonization/hs6/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Hs6Version.new(x) }
          end

        end

        class HsCodes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search harmonization codes. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :code => (x = opts.delete(:code); x.nil? ? nil : HttpClient::Preconditions.assert_class('code', x, Array).map { |v| HttpClient::Preconditions.assert_class('code', v, String) }),
              :parent => (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String)),
              :has_parent => (x = opts.delete(:has_parent); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_parent', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "code" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/harmonization/codes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HsCode.new(x) }
          end

          # Returns information about a specific harmonization code.
          def get_by_code(code)
            HttpClient::Preconditions.assert_class('code', code, String)
            r = @client.request("/harmonization/codes/#{CGI.escape(code)}").get
            ::Io::Flow::V0::Models::HsCode.new(r)
          end

        end

        class Authorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Authorization.from_json(x) }
          end

          # Create a new authorization.
          def post(organization, authorization_form, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('authorization_form', authorization_form, ::Io::Flow::V0::Models::AuthorizationForm)
            r = @client.request("/#{CGI.escape(organization)}/authorizations").with_query(query).with_json(authorization_form.to_json).post
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Returns information about a specific authorization.
          def get_by_key(organization, key, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(key)}").with_query(query).get
            ::Io::Flow::V0::Models::Authorization.from_json(r)
          end

          # Deletes a given authorization. This method will return a 422 if funds have
          # already been captured.
          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/authorizations/#{CGI.escape(key)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('authorization_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/authorizations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::AuthorizationVersion.new(x) }
          end

        end

        class Captures

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_key => (x = opts.delete(:authorization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Capture.new(x) }
          end

          # Create a new capture.
          def post(organization, capture_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('capture_form', capture_form, ::Io::Flow::V0::Models::CaptureForm)
            r = @client.request("/#{CGI.escape(organization)}/captures").with_json(capture_form.to_json).post
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Returns information about a specific capture.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/captures/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Capture.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('capture_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/captures/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CaptureVersion.new(x) }
          end

        end

        class Cards

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, Array).map { |v| HttpClient::Preconditions.assert_class('token', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Card.new(x) }
          end

          # Create a new card. Note that when using JSONP to submit a card, you do not
          # need to authenticate.
          def post(organization, card_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('card_form', card_form, ::Io::Flow::V0::Models::CardForm)
            r = @client.request("/#{CGI.escape(organization)}/cards").with_json(card_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Returns information about a specific card.
          def get_by_token(organization, token)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(token)}").get
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Deletes the specified card
          def delete_by_token(organization, token)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('token', token, String)
            r = @client.request("/#{CGI.escape(organization)}/cards/#{CGI.escape(token)}").delete
            nil
          end

          # Creates a card from a one time nonce. Each nonce can be used at most once
          # and you will receive a validation error if the nonce has already been
          # exchanged.
          def post_nonces(organization, card_nonce_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('card_nonce_form', card_nonce_form, ::Io::Flow::V0::Models::CardNonceForm)
            r = @client.request("/#{CGI.escape(organization)}/cards/nonces").with_json(card_nonce_form.to_json).post
            ::Io::Flow::V0::Models::Card.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :card_id => (x = opts.delete(:card_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_id', v, String) }),
              :card_token => (x = opts.delete(:card_token); x.nil? ? nil : HttpClient::Preconditions.assert_class('card_token', x, Array).map { |v| HttpClient::Preconditions.assert_class('card_token', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/cards/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CardVersion.new(x) }
          end

        end

        class Payments

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :payment_method => (x = opts.delete(:payment_method); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_method', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payments").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Payment.from_json(x) }
          end

          # Create a new payment. Note that when using JSONP to submit a payment, you do
          # not need to authenticate.
          def post(organization, payment_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('payment_form', payment_form, ::Io::Flow::V0::Models::PaymentForm)
            r = @client.request("/#{CGI.escape(organization)}/payments").with_json(payment_form.to_json).post
            ::Io::Flow::V0::Models::Payment.from_json(r)
          end

          # Returns information about a specific payment.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/payments/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Payment.from_json(r)
          end

          # Deletes the specified payment
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/payments/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :payment_id => (x = opts.delete(:payment_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('payment_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('payment_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/payments/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PaymentVersion.new(x) }
          end

        end

        class PublicKeys

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns your public keys
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/encryption/keys").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PublicKey.new(x) }
          end

          # Return the latest public key for an organization
          def get_latest(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/encryption/keys/latest").get
            ::Io::Flow::V0::Models::PublicKey.new(r)
          end

        end

        class Refunds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :authorization_id => (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String)),
              :authorization_key => (x = opts.delete(:authorization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_key', x, String)),
              :capture_id => (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String)),
              :capture_key => (x = opts.delete(:capture_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_key', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Refund.new(x) }
          end

          # Create a new refund.
          def post(organization, refund_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('refund_form', refund_form, ::Io::Flow::V0::Models::RefundForm)
            r = @client.request("/#{CGI.escape(organization)}/refunds").with_json(refund_form.to_json).post
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns information about a specific refund.
          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Refund.new(r)
          end

          # Returns a refund order summary for the specified order.
          def get_summary_by_order_number(organization, order_number)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('order_number', order_number, String)
            r = @client.request("/#{CGI.escape(organization)}/refunds/summary/#{CGI.escape(order_number)}").get
            ::Io::Flow::V0::Models::RefundOrderSummary.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, Integer) }),
              :refund_id => (x = opts.delete(:refund_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('refund_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('refund_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/refunds/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::RefundVersion.new(x) }
          end

        end

        class Centers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Center.new(x) }
          end

          def post(organization, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers").with_json(center_form.to_json).post
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def put_by_key(organization, key, center_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('center_form', center_form, ::Io::Flow::V0::Models::CenterForm)
            r = @client.request("/#{CGI.escape(organization)}/centers/#{CGI.escape(key)}").with_json(center_form.to_json).put
            ::Io::Flow::V0::Models::Center.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/centers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CenterVersion.new(x) }
          end

        end

        class DeliveryWindows

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Endpoint to request a delivery window. Requires some knowledge of origin
          # (based on organization, center, or specified address string) and destination
          # (based on ip, lat/long, or address string). Other attributes allow us to
          # narrow down delivery windows even more such as service level to be used and
          # timestamp of expected shipment date.
          def get_summary(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :strategy => (x = (x = opts.delete(:strategy); x.nil? ? "range" : x); x.is_a?(::Io::Flow::V0::Models::Strategy) ? x : ::Io::Flow::V0::Models::Strategy.apply(x)).value,
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String)),
              :origin => (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String)),
              :destination => (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String)),
              :latitude => (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String)),
              :longitude => (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String)),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/delivery-windows/summary").with_query(query).get
            ::Io::Flow::V0::Models::DeliveryWindow.new(r)
          end

        end

        class InventoryRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRule.new(x) }
          end

          def post(organization, inventory_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_rule_form', inventory_rule_form, ::Io::Flow::V0::Models::InventoryRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules").with_json(inventory_rule_form.to_json).post
            ::Io::Flow::V0::Models::InventoryRule.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryRuleVersion.new(x) }
          end

        end

        class InventorySnapshots

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshot.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventorySnapshot.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_snapshot => (x = opts.delete(:inventory_snapshot); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_snapshot', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_snapshot', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_snapshots/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventorySnapshotVersion.new(x) }
          end

        end

        class InventoryUpdates

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :center => (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, Array).map { |v| HttpClient::Preconditions.assert_class('center', v, String) }),
              :item_number => (x = opts.delete(:item_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_number', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdate.new(x) }
          end

          def post(organization, inventory_update_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('inventory_update_form', inventory_update_form, ::Io::Flow::V0::Models::InventoryUpdateForm)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates").with_json(inventory_update_form.to_json).post
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::InventoryUpdate.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :inventory_update => (x = opts.delete(:inventory_update); x.nil? ? nil : HttpClient::Preconditions.assert_class('inventory_update', x, Array).map { |v| HttpClient::Preconditions.assert_class('inventory_update', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/inventory_updates/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InventoryUpdateVersion.new(x) }
          end

        end

        class Quotes

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search quotes. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Quote.new(x) }
          end

          def post(organization, quote_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('quote_form', quote_form, ::Io::Flow::V0::Models::QuoteForm)
            r = @client.request("/#{CGI.escape(organization)}/quotes").with_json(quote_form.to_json).post
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/quotes/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Quote.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :quote => (x = opts.delete(:quote); x.nil? ? nil : HttpClient::Preconditions.assert_class('quote', x, Array).map { |v| HttpClient::Preconditions.assert_class('quote', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/quotes/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::QuoteVersion.new(x) }
          end

        end

        class Returns

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/returns").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Return.new(x) }
          end

          def post(organization, return_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('return_form', return_form, ::Io::Flow::V0::Models::ReturnForm)
            r = @client.request("/#{CGI.escape(organization)}/returns").with_json(return_form.to_json).post
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def put_by_key(organization, key, return_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('return_form', return_form, ::Io::Flow::V0::Models::ReturnForm)
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").with_json(return_form.to_json).put
            ::Io::Flow::V0::Models::Return.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/returns/#{CGI.escape(key)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/returns/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ReturnVersion.new(x) }
          end

        end

        class ShippingLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingLabel.new(x) }
          end

          def post(organization, shipping_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('shipping_label_form', shipping_label_form, ::Io::Flow::V0::Models::ShippingLabelForm)
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels").with_json(shipping_label_form.to_json).post
            ::Io::Flow::V0::Models::ShippingLabel.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ShippingLabel.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :label => (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, Array).map { |v| HttpClient::Preconditions.assert_class('label', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping_labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingLabelVersion.new(x) }
          end

        end

        class ShippingNotifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :carrier_tracking_number => (x = opts.delete(:carrier_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('carrier_tracking_number', v, String) }),
              :flow_tracking_number => (x = opts.delete(:flow_tracking_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('flow_tracking_number', v, String) }),
              :order_number => (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, Array).map { |v| HttpClient::Preconditions.assert_class('order_number', v, String) }),
              :service => (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, Array).map { |v| HttpClient::Preconditions.assert_class('service', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingNotification.new(x) }
          end

          def post(organization, shipping_notification_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('shipping_notification_form', shipping_notification_form, ::Io::Flow::V0::Models::ShippingNotificationForm)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications").with_json(shipping_notification_form.to_json).post
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def get_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").get
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def put_by_key(organization, key, shipping_notification_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            HttpClient::Preconditions.assert_class('shipping_notification_form', shipping_notification_form, ::Io::Flow::V0::Models::ShippingNotificationForm)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").with_json(shipping_notification_form.to_json).put
            ::Io::Flow::V0::Models::ShippingNotification.new(r)
          end

          def delete_by_key(organization, key)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('key', key, String)
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/#{CGI.escape(key)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, Array).map { |v| HttpClient::Preconditions.assert_class('key', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/shipping-notifications/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ShippingNotificationVersion.new(x) }
          end

        end

        class Tiers

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tier.new(x) }
          end

          def post(organization, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers").with_json(tier_form.to_json).post
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def put_by_id(organization, id, tier_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_form', tier_form, ::Io::Flow::V0::Models::TierForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").with_json(tier_form.to_json).put
            ::Io::Flow::V0::Models::Tier.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier => (x = opts.delete(:tier); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierVersion.new(x) }
          end

        end

        class TierDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :experience => (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, Array).map { |v| HttpClient::Preconditions.assert_class('experience', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierDefault.new(x) }
          end

          def post(organization, tier_default_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_default_form', tier_default_form, ::Io::Flow::V0::Models::TierDefaultForm)
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults").with_json(tier_default_form.to_json).post
            ::Io::Flow::V0::Models::TierDefault.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TierDefault.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier_default => (x = opts.delete(:tier_default); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier_default', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier_default', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tier_defaults/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierDefaultVersion.new(x) }
          end

        end

        class TierRules

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, tier_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierRule.new(x) }
          end

          def post(organization, tier_id, tier_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('tier_rule_form', tier_rule_form, ::Io::Flow::V0::Models::TierRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules").with_json(tier_rule_form.to_json).post
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def get_by_id(organization, tier_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def put_by_id(organization, tier_id, id, tier_rule_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('tier_rule_form', tier_rule_form, ::Io::Flow::V0::Models::TierRuleForm)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").with_json(tier_rule_form.to_json).put
            ::Io::Flow::V0::Models::TierRule.new(r)
          end

          def delete_by_id(organization, tier_id, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(organization, tier_id, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tier_id', tier_id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tier_rule => (x = opts.delete(:tier_rule); x.nil? ? nil : HttpClient::Preconditions.assert_class('tier_rule', x, Array).map { |v| HttpClient::Preconditions.assert_class('tier_rule', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tiers/#{CGI.escape(tier_id)}/rules/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TierRuleVersion.new(x) }
          end

        end

        class Trackings

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_trackings_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Tracking.new(x) }
          end

          def post_trackings_by_organization(organization, tracking_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_form', tracking_form, ::Io::Flow::V0::Models::TrackingForm)
            r = @client.request("/#{CGI.escape(organization)}/trackings").with_json(tracking_form.to_json).post
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

          def get_trackings_and_versions_by_organization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/trackings/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingVersion.new(x) }
          end

          # Public endpoint to get all relevant information about a tracking, label(s)
          # under it, and event(s) under those label(s)
          def get_trackings_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/trackings/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Tracking.new(r)
          end

        end

        class TrackingEvents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :tracking_label_id => (x = opts.delete(:tracking_label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-events").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingEvent.new(x) }
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tracking-events/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TrackingEvent.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_event_id => (x = opts.delete(:tracking_event_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_event_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_event_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-events/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingEventVersion.new(x) }
          end

        end

        class TrackingLabels

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_id => (x = opts.delete(:tracking_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingLabel.new(x) }
          end

          def post(organization, tracking_label_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('tracking_label_form', tracking_label_form, ::Io::Flow::V0::Models::TrackingLabelForm)
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels").with_json(tracking_label_form.to_json).post
            ::Io::Flow::V0::Models::TrackingLabel.new(r)
          end

          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::TrackingLabel.new(r)
          end

          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :tracking_label_id => (x = opts.delete(:tracking_label_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('tracking_label_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('tracking_label_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tracking-labels/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::TrackingLabelVersion.new(x) }
          end

        end

        class Webhooks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns webhooks for an organization
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/webhooks").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Webhook.new(x) }
          end

          # Create a new webhook
          def post(organization, webhook_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('webhook_form', webhook_form, ::Io::Flow::V0::Models::WebhookForm)
            r = @client.request("/#{CGI.escape(organization)}/webhooks").with_json(webhook_form.to_json).post
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Returns information about a specific webhook
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Update an existing webhook
          def put_by_id(organization, id, webhook_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('webhook_form', webhook_form, ::Io::Flow::V0::Models::WebhookForm)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").with_json(webhook_form.to_json).put
            ::Io::Flow::V0::Models::Webhook.new(r)
          end

          # Delete a webhook with the specified id
          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/#{CGI.escape(id)}").delete
            nil
          end

          # Returns the webhook settings for an organization
          def get_settings(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/settings").get
            ::Io::Flow::V0::Models::WebhookSettings.new(r)
          end

          # Updates the webhook settings for an organization
          def put_settings(organization, webhook_settings)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('webhook_settings', webhook_settings, ::Io::Flow::V0::Models::WebhookSettings)
            r = @client.request("/#{CGI.escape(organization)}/webhooks/settings").with_json(webhook_settings.to_json).put
            ::Io::Flow::V0::Models::WebhookSettings.new(r)
          end

        end

        class WebhookDeliveries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns deliveries for an organization's webhook
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :webhook_id => (x = opts.delete(:webhook_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('webhook_id', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::WebhookDelivery.new(x) }
          end

          # Returns information about a specific webhook delivery
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::WebhookDelivery.new(r)
          end

          # Redeliver a webhook request. This created a new webhook request to requeue
          # delivery
          def post_requests_by_id(organization, id, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/webhook/deliveries/#{CGI.escape(id)}/requests").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::WebhookRequest.new(r)
          end

        end

        class Addresses

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Geolocates the request based on the provided parameters, returning a list of
          # potential matching addresses.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/addresses").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Address.new(x) }
          end

          def post_verifications(address)
            HttpClient::Preconditions.assert_class('address', address, ::Io::Flow::V0::Models::Address)
            r = @client.request("/addresses/verifications").with_json(address.to_json).post
            ::Io::Flow::V0::Models::AddressVerification.new(r)
          end

        end

        class CountryDefaults

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :country => (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String)),
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/geolocation/defaults").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CountryDefaults.new(x) }
          end

          def get_by_country(country)
            HttpClient::Preconditions.assert_class('country', country, String)
            r = @client.request("/geolocation/defaults/#{CGI.escape(country)}").get
            ::Io::Flow::V0::Models::CountryDefaults.new(r)
          end

        end

        class Timezones

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Provides timezone based on address or geolocated IP.
          def get_geolocation_and_timezones(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :address => (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String)),
              :ip => (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/geolocation/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

          # Returns a list of timezones.
          def get_reference_and_timezones(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/timezones").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Timezone.new(x) }
          end

        end

        class Countries

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of countries.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/countries").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Country.new(x) }
          end

        end

        class Currencies

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of currencies.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/currencies").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Currency.new(x) }
          end

        end

        class Languages

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of languages.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/languages").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Language.new(x) }
          end

        end

        class Locales

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of locales.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/locales").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Locale.new(x) }
          end

          # Returns the locale with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/locales/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Locale.new(r)
          end

        end

        class Provinces

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of provinces.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :countries => (x = opts.delete(:countries); x.nil? ? nil : HttpClient::Preconditions.assert_class('countries', x, Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/provinces").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Province.new(x) }
          end

          # Returns the province with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/provinces/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Province.new(r)
          end

        end

        class Regions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns a list of regions.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/reference/regions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Region.new(x) }
          end

          # Returns the region with the specifed id.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/reference/regions/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Region.new(r)
          end

        end

        class Documents

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns items based on search criteria
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "name" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::CatalogItemDocument.new(x) }
          end

          # Returns harmonization information based on search criteria
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/search/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::HarmonizationDocument.new(x) }
          end

        end

        class EmailVerifications

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_token(token, hash)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/users/emails/verifications/#{CGI.escape(token)}").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::EmailVerification.new(r)
          end

        end

        class Exports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search exports. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :created_by_user_id => (x = opts.delete(:created_by_user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_by_user_id', x, String)),
              :discriminator => (x = opts.delete(:discriminator); x.nil? ? nil : HttpClient::Preconditions.assert_class('discriminator', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Export.new(x) }
          end

          # Create an export.
          def post(organization, export_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('export_form', export_form, ::Io::Flow::V0::Models::ExportForm)
            r = @client.request("/#{CGI.escape(organization)}/exports").with_json(export_form.to_json).post
            ::Io::Flow::V0::Models::Export.new(r)
          end

          # Get a single export.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/exports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Export.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/exports/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each export, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :export_id => (x = opts.delete(:export_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('export_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('export_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/exports/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ExportVersion.new(x) }
          end

        end

        class Feeds

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/feeds").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Feed.from_json(x) }
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/feeds/#{CGI.escape(id)}").delete
            nil
          end

          def post_catalog(organization, catalog_feed_form_post)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('catalog_feed_form_post', catalog_feed_form_post, ::Io::Flow::V0::Models::CatalogFeedFormPost)
            r = @client.request("/#{CGI.escape(organization)}/feeds/catalog").with_json(catalog_feed_form_post.to_json).post
            ::Io::Flow::V0::Models::CatalogFeed.new(r)
          end

          def put_catalog_by_id(organization, id, catalog_feed_form_put)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('catalog_feed_form_put', catalog_feed_form_put, ::Io::Flow::V0::Models::CatalogFeedFormPut)
            r = @client.request("/#{CGI.escape(organization)}/feeds/catalog/#{CGI.escape(id)}").with_json(catalog_feed_form_put.to_json).put
            ::Io::Flow::V0::Models::CatalogFeed.new(r)
          end

        end

        class Healthchecks

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_healthcheck
            r = @client.request("/_internal_/healthcheck").get
            ::Io::Flow::V0::Models::Healthcheck.new(r)
          end

        end

        class Imports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search imports. Always paginated.
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :created_by_user_id => (x = opts.delete(:created_by_user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_by_user_id', x, String)),
              :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/imports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Import.new(x) }
          end

          # Create an import.
          def post(organization, import_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('import_form', import_form, ::Io::Flow::V0::Models::ImportForm)
            r = @client.request("/#{CGI.escape(organization)}/imports").with_json(import_form.to_json).post
            ::Io::Flow::V0::Models::Import.new(r)
          end

          # Get a single import.
          def get_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/imports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Import.new(r)
          end

          def delete_by_id(organization, id)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/#{CGI.escape(organization)}/imports/#{CGI.escape(id)}").delete
            nil
          end

          # Provides visibility into recent changes of each import, including deletion.
          def get_versions(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :import_id => (x = opts.delete(:import_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('import_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('import_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/imports/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ImportVersion.new(x) }
          end

        end

        class Invitations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search invitations. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Invitation.new(x) }
          end

          # Create a new invitation.
          def post(invitation_form)
            HttpClient::Preconditions.assert_class('invitation_form', invitation_form, ::Io::Flow::V0::Models::InvitationForm)
            r = @client.request("/invitations").with_json(invitation_form.to_json).post
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Returns information about a specific invitation.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/invitations/#{CGI.escape(id)}").delete
            nil
          end

          # Lookup an invitation by its token.
          def get_tokens_by_token(token, incoming={})
            HttpClient::Preconditions.assert_class('token', token, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_query(query).get
            ::Io::Flow::V0::Models::Invitation.new(r)
          end

          # Accepts the invitation w/ the specified token and the authenticated user.
          # Creating a membership record for this user within this organization.
          # Invitations are one time use only - you will get a validation error if the
          # invitation has previously been accepted or if the user's email addresses do
          # not match the email on the invite.
          def put_tokens_by_token(token, hash)
            HttpClient::Preconditions.assert_class('token', token, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/invitations/tokens/#{CGI.escape(token)}").with_json(hash.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :invitation => (x = opts.delete(:invitation); x.nil? ? nil : HttpClient::Preconditions.assert_class('invitation', x, Array).map { |v| HttpClient::Preconditions.assert_class('invitation', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/invitations/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::InvitationVersion.new(x) }
          end

        end

        class Memberships

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search memberships. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x)).value }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String),
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Membership.new(x) }
          end

          # Create a new membership.
          def post(membership_form)
            HttpClient::Preconditions.assert_class('membership_form', membership_form, ::Io::Flow::V0::Models::MembershipForm)
            r = @client.request("/memberships").with_json(membership_form.to_json).post
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Returns information about a specific membership.
          def get_by_id(id, incoming={})
            HttpClient::Preconditions.assert_class('id', id, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/#{CGI.escape(id)}").with_query(query).get
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          # Change the role for a specific membership record. If the user already has
          # the specified role within the organization, does nothing.
          def put_by_id(id, membership_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('membership_put_form', membership_put_form, ::Io::Flow::V0::Models::MembershipPutForm)
            r = @client.request("/memberships/#{CGI.escape(id)}").with_json(membership_put_form.to_json).put
            ::Io::Flow::V0::Models::Membership.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/memberships/#{CGI.escape(id)}").delete
            nil
          end

          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :membership => (x = opts.delete(:membership); x.nil? ? nil : HttpClient::Preconditions.assert_class('membership', x, Array).map { |v| HttpClient::Preconditions.assert_class('membership', v, String) }),
              :user => (x = opts.delete(:user); x.nil? ? nil : HttpClient::Preconditions.assert_class('user', x, String)),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/memberships/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::MembershipVersion.new(x) }
          end

        end

        class OrganizationAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # For the authorized user, if the specified organization exists, and the user
          # is an active member of this organization, returns the authorization data
          # used throughout APIs at Flow, including the user's role in that organization
          # and the organization environment. Otherwise, returns 401 - this indicates
          # either the org does not exist or the user does not have access to the org.
          def post(organization_authorization_form)
            HttpClient::Preconditions.assert_class('organization_authorization_form', organization_authorization_form, ::Io::Flow::V0::Models::OrganizationAuthorizationForm)
            r = @client.request("/organization-authorizations").with_json(organization_authorization_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

          # For the authorized user and specific organization, if the user is an active
          # member of this organization, returns the authorization data used throughout
          # APIs at Flow, including the user's role in that organization and the
          # organization environment.
          def get_by_organization(organization)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            r = @client.request("/organization-authorizations/#{CGI.escape(organization)}").get
            ::Io::Flow::V0::Models::OrganizationAuthorization.new(r)
          end

        end

        class OrganizationTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens for the specifed organization
          def get(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::OrganizationToken.new(x) }
          end

        end

        class PartnerTokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens for the specifed partner
          def get(partner, incoming={})
            HttpClient::Preconditions.assert_class('partner', partner, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/partners/#{CGI.escape(partner)}/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::PartnerToken.new(x) }
          end

        end

        class PasswordResetForms

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(password_reset_form, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :expand => (x = opts.delete(:expand); x.nil? ? nil : HttpClient::Preconditions.assert_class('expand', x, Array).map { |v| HttpClient::Preconditions.assert_class('expand', v, String) })
            }.delete_if { |k, v| v.nil? }
            HttpClient::Preconditions.assert_class('password_reset_form', password_reset_form, ::Io::Flow::V0::Models::PasswordResetForm)
            r = @client.request("/users/passwords").with_query(query).with_json(password_reset_form.to_json).post
            ::Io::Flow::V0::Models::ExpandableUser.from_json(r)
          end

          def post_resets(password_reset_request_form)
            HttpClient::Preconditions.assert_class('password_reset_request_form', password_reset_request_form, ::Io::Flow::V0::Models::PasswordResetRequestForm)
            r = @client.request("/users/passwords/resets").with_json(password_reset_request_form.to_json).post
            nil
          end

        end

        class ScheduledExports

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search scheduled exports. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/scheduled/exports").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::ScheduledExport.new(x) }
          end

          # Create a scheduled export.
          def post(scheduled_export_form)
            HttpClient::Preconditions.assert_class('scheduled_export_form', scheduled_export_form, ::Io::Flow::V0::Models::ScheduledExportForm)
            r = @client.request("/users/scheduled/exports").with_json(scheduled_export_form.to_json).post
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          # Get a single excheduled export.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          # Update a scheduled export.
          def put_by_id(id, scheduled_export_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('scheduled_export_form', scheduled_export_form, ::Io::Flow::V0::Models::ScheduledExportForm)
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").with_json(scheduled_export_form.to_json).put
            ::Io::Flow::V0::Models::ScheduledExport.new(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/scheduled/exports/#{CGI.escape(id)}").delete
            nil
          end

        end

        class Sessions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def get_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/#{CGI.escape(session)}").get
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def put_by_session(session, session_put_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            HttpClient::Preconditions.assert_class('session_put_form', session_put_form, ::Io::Flow::V0::Models::SessionPutForm)
            r = @client.request("/sessions/#{CGI.escape(session)}").with_json(session_put_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def delete_by_session(session)
            HttpClient::Preconditions.assert_class('session', session, String)
            r = @client.request("/sessions/#{CGI.escape(session)}").delete
            nil
          end

          # Resets the session based on the provided geo parameters.
          def put_reset_by_session(session, session_reset_form)
            HttpClient::Preconditions.assert_class('session', session, String)
            HttpClient::Preconditions.assert_class('session_reset_form', session_reset_form, ::Io::Flow::V0::Models::SessionResetForm)
            r = @client.request("/sessions/#{CGI.escape(session)}/reset").with_json(session_reset_form.to_json).put
            ::Io::Flow::V0::Models::Session.from_json(r)
          end

          def post_organizations_by_organization(organization, session_form)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('session_form', session_form, ::Io::Flow::V0::Models::SessionForm)
            r = @client.request("/sessions/organizations/#{CGI.escape(organization)}").with_json(session_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

          def post_shopify_by_shop(shop, session_form)
            HttpClient::Preconditions.assert_class('shop', shop, String)
            HttpClient::Preconditions.assert_class('session_form', session_form, ::Io::Flow::V0::Models::SessionForm)
            r = @client.request("/sessions/shopify/#{CGI.escape(shop)}").with_json(session_form.to_json).post
            ::Io::Flow::V0::Models::OrganizationSession.new(r)
          end

        end

        class SessionAuthorizations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(session_authorization_form)
            HttpClient::Preconditions.assert_class('session_authorization_form', session_authorization_form, ::Io::Flow::V0::Models::SessionAuthorizationForm)
            r = @client.request("/authorizations/sessions").with_json(session_authorization_form.to_json).post
            ::Io::Flow::V0::Models::SessionAuthorization.from_json(r)
          end

        end

        class Suggestions

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Returns search suggestions for catalog items
          def get_catalog(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-count" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/catalog").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

          # Returns search suggestions for harmonization data
          def get_harmonization(organization, incoming={})
            HttpClient::Preconditions.assert_class('organization', organization, String)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/#{CGI.escape(organization)}/suggestion/harmonization").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Suggestion.new(x) }
          end

        end

        class Tokens

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Get all tokens that you are authorized to view. Note that the cleartext
          # token value is never sent. To view the API token itself, see the resource
          # path /tokens/:id/cleartext
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :organization => (x = opts.delete(:organization); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization', x, String)),
              :partner => (x = opts.delete(:partner); x.nil? ? nil : HttpClient::Preconditions.assert_class('partner', x, String)),
              :mine => (x = opts.delete(:mine); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('mine', x)),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/tokens").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::Token.from_json(x) }
          end

          # Create a new token for the requesting user
          def post(token_form)
            HttpClient::Preconditions.assert_class('token_form', token_form, ::Io::Flow::V0::Models::TokenForm)
            r = @client.request("/tokens").with_json(token_form.to_json).post
            ::Io::Flow::V0::Models::Token.from_json(r)
          end

          # Get metadata for the token with this ID
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::Token.from_json(r)
          end

          def delete_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}").delete
            nil
          end

          # Retrieves the token with the actual string token in cleartext
          def get_cleartext_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/tokens/#{CGI.escape(id)}/cleartext").get
            ::Io::Flow::V0::Models::Cleartext.new(r)
          end

          # Preferred method to validate a token, obtaining specific information if the
          # token is valid (or a 404 if the token does not exist). We use an HTTP POST
          # with a form body to enusre that the token itself is not logged in the
          # request logs.
          def post_authentications(token_authentication_form)
            HttpClient::Preconditions.assert_class('token_authentication_form', token_authentication_form, ::Io::Flow::V0::Models::TokenAuthenticationForm)
            r = @client.request("/tokens/authentications").with_json(token_authentication_form.to_json).post
            ::Io::Flow::V0::Models::TokenReference.from_json(r)
          end

        end

        class TokenValidations

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post(token_validation_form)
            HttpClient::Preconditions.assert_class('token_validation_form', token_validation_form, ::Io::Flow::V0::Models::TokenValidationForm)
            r = @client.request("/token-validations").with_json(token_validation_form.to_json).post
            ::Io::Flow::V0::Models::TokenValidation.new(r)
          end

        end

        class Uploads

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          def post_by_name(organization, name, hash)
            HttpClient::Preconditions.assert_class('organization', organization, String)
            HttpClient::Preconditions.assert_class('name', name, String)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            r = @client.request("/#{CGI.escape(organization)}/uploads/#{CGI.escape(name)}").with_json(hash.to_json).post
            ::Io::Flow::V0::Models::Upload.new(r)
          end

        end

        class Users

          def initialize(client)
            @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Flow::V0::Client)
          end

          # Search users. Always paginated.
          def get(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
              :status => (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UserStatus) ? x : ::Io::Flow::V0::Models::UserStatus.apply(x)).value),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "-created_at" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::User.new(x) }
          end

          # Create a new user. Note that new users will be created with a status of
          # pending and will not be able to authenticate until approved by a member of
          # the Flow team.
          def post(user_form)
            HttpClient::Preconditions.assert_class('user_form', user_form, ::Io::Flow::V0::Models::UserForm)
            r = @client.request("/users").with_json(user_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Returns information about a specific user.
          def get_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}").get
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update a user.
          def put_by_id(id, user_put_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('user_put_form', user_put_form, ::Io::Flow::V0::Models::UserPutForm)
            r = @client.request("/users/#{CGI.escape(id)}").with_json(user_put_form.to_json).put
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Update the password for a user.
          def patch_passwords_by_id(id, password_change_form)
            HttpClient::Preconditions.assert_class('id', id, String)
            HttpClient::Preconditions.assert_class('password_change_form', password_change_form, ::Io::Flow::V0::Models::PasswordChangeForm)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").with_json(password_change_form.to_json).patch
            nil
          end

          # Deletes a password for the given user.
          def delete_passwords_by_id(id)
            HttpClient::Preconditions.assert_class('id', id, String)
            r = @client.request("/users/#{CGI.escape(id)}/passwords").delete
            nil
          end

          # Authenticates a user by email / password. Note only users that have a status
          # of active will be authorized.
          def post_authenticate(authentication_form)
            HttpClient::Preconditions.assert_class('authentication_form', authentication_form, ::Io::Flow::V0::Models::AuthenticationForm)
            r = @client.request("/users/authenticate").with_json(authentication_form.to_json).post
            ::Io::Flow::V0::Models::User.new(r)
          end

          # Provides visibility into recent changes of each object, including deletion
          def get_versions(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            query = {
              :id => (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, Array).map { |v| HttpClient::Preconditions.assert_class('id', v, String) }),
              :user_id => (x = opts.delete(:user_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_id', x, Array).map { |v| HttpClient::Preconditions.assert_class('user_id', v, String) }),
              :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
              :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer),
              :sort => HttpClient::Preconditions.assert_class('sort', (x = opts.delete(:sort); x.nil? ? "journal_timestamp" : x), String)
            }.delete_if { |k, v| v.nil? }
            r = @client.request("/users/versions").with_query(query).get
            r.map { |x| ::Io::Flow::V0::Models::UserVersion.new(x) }
          end

        end

      end

      module Models

        class AllocationComponent

          module Types
            ALLOCATION_DETAIL_COMPONENT = 'allocation_detail_component' unless defined?(ALLOCATION_DETAIL_COMPONENT)
            ALLOCATION_LEVY_COMPONENT = 'allocation_levy_component' unless defined?(ALLOCATION_LEVY_COMPONENT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AllocationComponent')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of allocation_component directly - must use one of the specific types: allocation_detail_component, allocation_levy_component'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AllocationComponent.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[allocation_component] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ALLOCATION_DETAIL_COMPONENT; AllocationDetailComponent.new(hash)
              when Types::ALLOCATION_LEVY_COMPONENT; AllocationLevyComponent.new(hash)
              else AllocationComponentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AllocationComponentUndefinedType < AllocationComponent

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AllocationDetail

          module Types
            ALLOCATION_LINE_DETAIL = 'allocation_line_detail' unless defined?(ALLOCATION_LINE_DETAIL)
            ALLOCATION_ORDER_DETAIL = 'allocation_order_detail' unless defined?(ALLOCATION_ORDER_DETAIL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AllocationDetail')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of allocation_detail directly - must use one of the specific types: allocation_line_detail, allocation_order_detail'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AllocationDetail.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[allocation_detail] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ALLOCATION_LINE_DETAIL; AllocationLineDetail.new(hash)
              when Types::ALLOCATION_ORDER_DETAIL; AllocationOrderDetail.new(hash)
              else AllocationDetailUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AllocationDetailUndefinedType < AllocationDetail

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Authorization

          module Types
            CARD_AUTHORIZATION = 'card_authorization' unless defined?(CARD_AUTHORIZATION)
            ONLINE_AUTHORIZATION = 'online_authorization' unless defined?(ONLINE_AUTHORIZATION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Authorization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization directly - must use one of the specific types: card_authorization, online_authorization'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Authorization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD_AUTHORIZATION; CardAuthorization.new(hash)
              when Types::ONLINE_AUTHORIZATION; OnlineAuthorization.new(hash)
              else AuthorizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationUndefinedType < Authorization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Flow provides several different options for creating an authorization
        class AuthorizationForm

          module Types
            # Enables card payments
            DIRECT_AUTHORIZATION_FORM = 'direct_authorization_form' unless defined?(DIRECT_AUTHORIZATION_FORM)
            # Enables card payments with Flow as Merchant of Record
            MERCHANT_OF_RECORD_AUTHORIZATION_FORM = 'merchant_of_record_authorization_form' unless defined?(MERCHANT_OF_RECORD_AUTHORIZATION_FORM)
            # Enables authorization via paypal
            PAYPAL_AUTHORIZATION_FORM = 'paypal_authorization_form' unless defined?(PAYPAL_AUTHORIZATION_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'AuthorizationForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of authorization_form directly - must use one of the specific types: direct_authorization_form, merchant_of_record_authorization_form, paypal_authorization_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def AuthorizationForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[authorization_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DIRECT_AUTHORIZATION_FORM; DirectAuthorizationForm.new(hash)
              when Types::MERCHANT_OF_RECORD_AUTHORIZATION_FORM; MerchantOfRecordAuthorizationForm.new(hash)
              when Types::PAYPAL_AUTHORIZATION_FORM; PaypalAuthorizationForm.new(hash)
              else AuthorizationFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class AuthorizationFormUndefinedType < AuthorizationForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # De Minimis describes the country specific rules for exactly how tax and duties
        # are calculated, as well as any exemptions that apply. See
        # https://en.wikipedia.org/wiki/De_minimis for more information.
        class Deminimis

          module Types
            DEMINIMIS_SIMPLE = 'deminimis_simple' unless defined?(DEMINIMIS_SIMPLE)
            DEMINIMIS_PER_ITEM = 'deminimis_per_item' unless defined?(DEMINIMIS_PER_ITEM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Deminimis')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of deminimis directly - must use one of the specific types: deminimis_simple, deminimis_per_item'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Deminimis.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[deminimis] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::DEMINIMIS_SIMPLE; DeminimisSimple.new(hash)
              when Types::DEMINIMIS_PER_ITEM; DeminimisPerItem.new(hash)
              else DeminimisUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DeminimisUndefinedType < Deminimis

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Document

          module Types
            CATALOG_ITEM_DOCUMENT = 'catalog_item_document' unless defined?(CATALOG_ITEM_DOCUMENT)
            HARMONIZATION_DOCUMENT = 'harmonization_document' unless defined?(HARMONIZATION_DOCUMENT)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Document')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of document directly - must use one of the specific types: catalog_item_document, harmonization_document'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Document.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[document] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CATALOG_ITEM_DOCUMENT; CatalogItemDocument.new(hash)
              when Types::HARMONIZATION_DOCUMENT; HarmonizationDocument.new(hash)
              else DocumentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class DocumentUndefinedType < Document

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Event

          module Types
            ATTRIBUTE_UPSERTED = 'attribute_upserted' unless defined?(ATTRIBUTE_UPSERTED)
            ATTRIBUTE_DELETED = 'attribute_deleted' unless defined?(ATTRIBUTE_DELETED)
            CATALOG_UPSERTED = 'catalog_upserted' unless defined?(CATALOG_UPSERTED)
            CATALOG_DELETED = 'catalog_deleted' unless defined?(CATALOG_DELETED)
            SUBCATALOG_UPSERTED = 'subcatalog_upserted' unless defined?(SUBCATALOG_UPSERTED)
            SUBCATALOG_DELETED = 'subcatalog_deleted' unless defined?(SUBCATALOG_DELETED)
            CATALOG_ITEM_UPSERTED = 'catalog_item_upserted' unless defined?(CATALOG_ITEM_UPSERTED)
            CATALOG_ITEM_DELETED = 'catalog_item_deleted' unless defined?(CATALOG_ITEM_DELETED)
            SUBCATALOG_ITEM_UPSERTED = 'subcatalog_item_upserted' unless defined?(SUBCATALOG_ITEM_UPSERTED)
            SUBCATALOG_ITEM_DELETED = 'subcatalog_item_deleted' unless defined?(SUBCATALOG_ITEM_DELETED)
            RATE_DELETED = 'rate_deleted' unless defined?(RATE_DELETED)
            RATE_UPSERTED = 'rate_upserted' unless defined?(RATE_UPSERTED)
            AVAILABLE_PROMOTIONS_UPSERTED = 'available_promotions_upserted' unless defined?(AVAILABLE_PROMOTIONS_UPSERTED)
            AVAILABLE_PROMOTIONS_DELETED = 'available_promotions_deleted' unless defined?(AVAILABLE_PROMOTIONS_DELETED)
            ALLOCATION_DELETED = 'allocation_deleted' unless defined?(ALLOCATION_DELETED)
            ALLOCATION_UPSERTED = 'allocation_upserted' unless defined?(ALLOCATION_UPSERTED)
            EXPERIENCE_DELETED = 'experience_deleted' unless defined?(EXPERIENCE_DELETED)
            EXPERIENCE_UPSERTED = 'experience_upserted' unless defined?(EXPERIENCE_UPSERTED)
            ITEM_MARGIN_DELETED = 'item_margin_deleted' unless defined?(ITEM_MARGIN_DELETED)
            ITEM_MARGIN_UPSERTED = 'item_margin_upserted' unless defined?(ITEM_MARGIN_UPSERTED)
            ITEM_SALES_MARGIN_DELETED = 'item_sales_margin_deleted' unless defined?(ITEM_SALES_MARGIN_DELETED)
            ITEM_SALES_MARGIN_UPSERTED = 'item_sales_margin_upserted' unless defined?(ITEM_SALES_MARGIN_UPSERTED)
            LABEL_FORMAT_DELETED = 'label_format_deleted' unless defined?(LABEL_FORMAT_DELETED)
            LABEL_FORMAT_UPSERTED = 'label_format_upserted' unless defined?(LABEL_FORMAT_UPSERTED)
            ORDER_DELETED = 'order_deleted' unless defined?(ORDER_DELETED)
            ORDER_UPSERTED = 'order_upserted' unless defined?(ORDER_UPSERTED)
            ORDER_IDENTIFIER_DELETED = 'order_identifier_deleted' unless defined?(ORDER_IDENTIFIER_DELETED)
            ORDER_IDENTIFIER_UPSERTED = 'order_identifier_upserted' unless defined?(ORDER_IDENTIFIER_UPSERTED)
            PRICING_DELETED = 'pricing_deleted' unless defined?(PRICING_DELETED)
            PRICING_UPSERTED = 'pricing_upserted' unless defined?(PRICING_UPSERTED)
            TIER_UPSERTED = 'tier_upserted' unless defined?(TIER_UPSERTED)
            TIER_DELETED = 'tier_deleted' unless defined?(TIER_DELETED)
            HS6_CODE_UPSERTED = 'hs6_code_upserted' unless defined?(HS6_CODE_UPSERTED)
            HS6_CODE_DELETED = 'hs6_code_deleted' unless defined?(HS6_CODE_DELETED)
            HS10_CODE_UPSERTED = 'hs10_code_upserted' unless defined?(HS10_CODE_UPSERTED)
            HS10_CODE_DELETED = 'hs10_code_deleted' unless defined?(HS10_CODE_DELETED)
            ITEM_ORIGIN_UPSERTED = 'item_origin_upserted' unless defined?(ITEM_ORIGIN_UPSERTED)
            ITEM_ORIGIN_DELETED = 'item_origin_deleted' unless defined?(ITEM_ORIGIN_DELETED)
            HARMONIZED_ITEM_UPSERTED = 'harmonized_item_upserted' unless defined?(HARMONIZED_ITEM_UPSERTED)
            HARMONIZED_ITEM_DELETED = 'harmonized_item_deleted' unless defined?(HARMONIZED_ITEM_DELETED)
            SNAPSHOT_UPSERTED = 'snapshot_upserted' unless defined?(SNAPSHOT_UPSERTED)
            SNAPSHOT_DELETED = 'snapshot_deleted' unless defined?(SNAPSHOT_DELETED)
            LABEL_UPSERTED = 'label_upserted' unless defined?(LABEL_UPSERTED)
            NOTIFICATION_UPSERTED = 'notification_upserted' unless defined?(NOTIFICATION_UPSERTED)
            NOTIFICATION_DELETED = 'notification_deleted' unless defined?(NOTIFICATION_DELETED)
            LOCALIZED_ITEM_UPSERTED = 'localized_item_upserted' unless defined?(LOCALIZED_ITEM_UPSERTED)
            LOCALIZED_ITEM_DELETED = 'localized_item_deleted' unless defined?(LOCALIZED_ITEM_DELETED)
            LOCALIZED_ITEM_SNAPSHOT = 'localized_item_snapshot' unless defined?(LOCALIZED_ITEM_SNAPSHOT)
            MEMBERSHIP_UPSERTED = 'membership_upserted' unless defined?(MEMBERSHIP_UPSERTED)
            MEMBERSHIP_DELETED = 'membership_deleted' unless defined?(MEMBERSHIP_DELETED)
            ORGANIZATION_UPSERTED = 'organization_upserted' unless defined?(ORGANIZATION_UPSERTED)
            ORGANIZATION_DELETED = 'organization_deleted' unless defined?(ORGANIZATION_DELETED)
            AUTHORIZATION_UPSERTED = 'authorization_upserted' unless defined?(AUTHORIZATION_UPSERTED)
            AUTHORIZATION_DELETED = 'authorization_deleted' unless defined?(AUTHORIZATION_DELETED)
            AUTHORIZATION_DELETED_V2 = 'authorization_deleted_v2' unless defined?(AUTHORIZATION_DELETED_V2)
            # Trigger whenever an auth status changes (e.g. from pending to authorized).
            # Common use case is to subscribe to this event to know when an auth is cleared
            # from fraud review.
            AUTHORIZATION_STATUS_CHANGED = 'authorization_status_changed' unless defined?(AUTHORIZATION_STATUS_CHANGED)
            CARD_AUTHORIZATION_UPSERTED = 'card_authorization_upserted' unless defined?(CARD_AUTHORIZATION_UPSERTED)
            CARD_AUTHORIZATION_UPSERTED_V2 = 'card_authorization_upserted_v2' unless defined?(CARD_AUTHORIZATION_UPSERTED_V2)
            ONLINE_AUTHORIZATION_UPSERTED = 'online_authorization_upserted' unless defined?(ONLINE_AUTHORIZATION_UPSERTED)
            ONLINE_AUTHORIZATION_UPSERTED_V2 = 'online_authorization_upserted_v2' unless defined?(ONLINE_AUTHORIZATION_UPSERTED_V2)
            CAPTURE_UPSERTED = 'capture_upserted' unless defined?(CAPTURE_UPSERTED)
            CAPTURE_UPSERTED_V2 = 'capture_upserted_v2' unless defined?(CAPTURE_UPSERTED_V2)
            CARD_UPSERTED = 'card_upserted' unless defined?(CARD_UPSERTED)
            CARD_UPSERTED_V2 = 'card_upserted_v2' unless defined?(CARD_UPSERTED_V2)
            CARD_DELETED = 'card_deleted' unless defined?(CARD_DELETED)
            PAYMENT_UPSERTED = 'payment_upserted' unless defined?(PAYMENT_UPSERTED)
            PAYMENT_DELETED = 'payment_deleted' unless defined?(PAYMENT_DELETED)
            REFUND_UPSERTED = 'refund_upserted' unless defined?(REFUND_UPSERTED)
            REFUND_UPSERTED_V2 = 'refund_upserted_v2' unless defined?(REFUND_UPSERTED_V2)
            RETURN_UPSERTED = 'return_upserted' unless defined?(RETURN_UPSERTED)
            RETURN_DELETED = 'return_deleted' unless defined?(RETURN_DELETED)
            TARGETING_ITEM_UPSERTED = 'targeting_item_upserted' unless defined?(TARGETING_ITEM_UPSERTED)
            TARGETING_ITEM_DELETED = 'targeting_item_deleted' unless defined?(TARGETING_ITEM_DELETED)
            TRACKING_LABEL_EVENT_UPSERTED = 'tracking_label_event_upserted' unless defined?(TRACKING_LABEL_EVENT_UPSERTED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Event')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of event directly - must use one of the specific types: attribute_upserted, attribute_deleted, catalog_upserted, catalog_deleted, subcatalog_upserted, subcatalog_deleted, catalog_item_upserted, catalog_item_deleted, subcatalog_item_upserted, subcatalog_item_deleted, rate_deleted, rate_upserted, available_promotions_upserted, available_promotions_deleted, allocation_deleted, allocation_upserted, experience_deleted, experience_upserted, item_margin_deleted, item_margin_upserted, item_sales_margin_deleted, item_sales_margin_upserted, label_format_deleted, label_format_upserted, order_deleted, order_upserted, order_identifier_deleted, order_identifier_upserted, pricing_deleted, pricing_upserted, tier_upserted, tier_deleted, hs6_code_upserted, hs6_code_deleted, hs10_code_upserted, hs10_code_deleted, item_origin_upserted, item_origin_deleted, harmonized_item_upserted, harmonized_item_deleted, snapshot_upserted, snapshot_deleted, label_upserted, notification_upserted, notification_deleted, localized_item_upserted, localized_item_deleted, localized_item_snapshot, membership_upserted, membership_deleted, organization_upserted, organization_deleted, authorization_upserted, authorization_deleted, authorization_deleted_v2, authorization_status_changed, card_authorization_upserted, card_authorization_upserted_v2, online_authorization_upserted, online_authorization_upserted_v2, capture_upserted, capture_upserted_v2, card_upserted, card_upserted_v2, card_deleted, payment_upserted, payment_deleted, refund_upserted, refund_upserted_v2, return_upserted, return_deleted, targeting_item_upserted, targeting_item_deleted, tracking_label_event_upserted'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Event.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[event] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ATTRIBUTE_UPSERTED; AttributeUpserted.new(hash)
              when Types::ATTRIBUTE_DELETED; AttributeDeleted.new(hash)
              when Types::CATALOG_UPSERTED; CatalogUpserted.new(hash)
              when Types::CATALOG_DELETED; CatalogDeleted.new(hash)
              when Types::SUBCATALOG_UPSERTED; SubcatalogUpserted.new(hash)
              when Types::SUBCATALOG_DELETED; SubcatalogDeleted.new(hash)
              when Types::CATALOG_ITEM_UPSERTED; CatalogItemUpserted.new(hash)
              when Types::CATALOG_ITEM_DELETED; CatalogItemDeleted.new(hash)
              when Types::SUBCATALOG_ITEM_UPSERTED; SubcatalogItemUpserted.new(hash)
              when Types::SUBCATALOG_ITEM_DELETED; SubcatalogItemDeleted.new(hash)
              when Types::RATE_DELETED; RateDeleted.new(hash)
              when Types::RATE_UPSERTED; RateUpserted.new(hash)
              when Types::AVAILABLE_PROMOTIONS_UPSERTED; AvailablePromotionsUpserted.new(hash)
              when Types::AVAILABLE_PROMOTIONS_DELETED; AvailablePromotionsDeleted.new(hash)
              when Types::ALLOCATION_DELETED; AllocationDeleted.new(hash)
              when Types::ALLOCATION_UPSERTED; AllocationUpserted.new(hash)
              when Types::EXPERIENCE_DELETED; ExperienceDeleted.new(hash)
              when Types::EXPERIENCE_UPSERTED; ExperienceUpserted.new(hash)
              when Types::ITEM_MARGIN_DELETED; ItemMarginDeleted.new(hash)
              when Types::ITEM_MARGIN_UPSERTED; ItemMarginUpserted.new(hash)
              when Types::ITEM_SALES_MARGIN_DELETED; ItemSalesMarginDeleted.new(hash)
              when Types::ITEM_SALES_MARGIN_UPSERTED; ItemSalesMarginUpserted.new(hash)
              when Types::LABEL_FORMAT_DELETED; LabelFormatDeleted.new(hash)
              when Types::LABEL_FORMAT_UPSERTED; LabelFormatUpserted.new(hash)
              when Types::ORDER_DELETED; OrderDeleted.new(hash)
              when Types::ORDER_UPSERTED; OrderUpserted.new(hash)
              when Types::ORDER_IDENTIFIER_DELETED; OrderIdentifierDeleted.new(hash)
              when Types::ORDER_IDENTIFIER_UPSERTED; OrderIdentifierUpserted.new(hash)
              when Types::PRICING_DELETED; PricingDeleted.new(hash)
              when Types::PRICING_UPSERTED; PricingUpserted.new(hash)
              when Types::TIER_UPSERTED; TierUpserted.new(hash)
              when Types::TIER_DELETED; TierDeleted.new(hash)
              when Types::HS6_CODE_UPSERTED; Hs6CodeUpserted.new(hash)
              when Types::HS6_CODE_DELETED; Hs6CodeDeleted.new(hash)
              when Types::HS10_CODE_UPSERTED; Hs10CodeUpserted.new(hash)
              when Types::HS10_CODE_DELETED; Hs10CodeDeleted.new(hash)
              when Types::ITEM_ORIGIN_UPSERTED; ItemOriginUpserted.new(hash)
              when Types::ITEM_ORIGIN_DELETED; ItemOriginDeleted.new(hash)
              when Types::HARMONIZED_ITEM_UPSERTED; HarmonizedItemUpserted.new(hash)
              when Types::HARMONIZED_ITEM_DELETED; HarmonizedItemDeleted.new(hash)
              when Types::SNAPSHOT_UPSERTED; SnapshotUpserted.new(hash)
              when Types::SNAPSHOT_DELETED; SnapshotDeleted.new(hash)
              when Types::LABEL_UPSERTED; LabelUpserted.new(hash)
              when Types::NOTIFICATION_UPSERTED; NotificationUpserted.new(hash)
              when Types::NOTIFICATION_DELETED; NotificationDeleted.new(hash)
              when Types::LOCALIZED_ITEM_UPSERTED; LocalizedItemUpserted.new(hash)
              when Types::LOCALIZED_ITEM_DELETED; LocalizedItemDeleted.new(hash)
              when Types::LOCALIZED_ITEM_SNAPSHOT; LocalizedItemSnapshot.new(hash)
              when Types::MEMBERSHIP_UPSERTED; MembershipUpserted.new(hash)
              when Types::MEMBERSHIP_DELETED; MembershipDeleted.new(hash)
              when Types::ORGANIZATION_UPSERTED; OrganizationUpserted.new(hash)
              when Types::ORGANIZATION_DELETED; OrganizationDeleted.new(hash)
              when Types::AUTHORIZATION_UPSERTED; AuthorizationUpserted.new(hash)
              when Types::AUTHORIZATION_DELETED; AuthorizationDeleted.new(hash)
              when Types::AUTHORIZATION_DELETED_V2; AuthorizationDeletedV2.new(hash)
              when Types::AUTHORIZATION_STATUS_CHANGED; AuthorizationStatusChanged.new(hash)
              when Types::CARD_AUTHORIZATION_UPSERTED; CardAuthorizationUpserted.new(hash)
              when Types::CARD_AUTHORIZATION_UPSERTED_V2; CardAuthorizationUpsertedV2.new(hash)
              when Types::ONLINE_AUTHORIZATION_UPSERTED; OnlineAuthorizationUpserted.new(hash)
              when Types::ONLINE_AUTHORIZATION_UPSERTED_V2; OnlineAuthorizationUpsertedV2.new(hash)
              when Types::CAPTURE_UPSERTED; CaptureUpserted.new(hash)
              when Types::CAPTURE_UPSERTED_V2; CaptureUpsertedV2.new(hash)
              when Types::CARD_UPSERTED; CardUpserted.new(hash)
              when Types::CARD_UPSERTED_V2; CardUpsertedV2.new(hash)
              when Types::CARD_DELETED; CardDeleted.new(hash)
              when Types::PAYMENT_UPSERTED; PaymentUpserted.new(hash)
              when Types::PAYMENT_DELETED; PaymentDeleted.new(hash)
              when Types::REFUND_UPSERTED; RefundUpserted.new(hash)
              when Types::REFUND_UPSERTED_V2; RefundUpsertedV2.new(hash)
              when Types::RETURN_UPSERTED; ReturnUpserted.new(hash)
              when Types::RETURN_DELETED; ReturnDeleted.new(hash)
              when Types::TARGETING_ITEM_UPSERTED; TargetingItemUpserted.new(hash)
              when Types::TARGETING_ITEM_DELETED; TargetingItemDeleted.new(hash)
              when Types::TRACKING_LABEL_EVENT_UPSERTED; TrackingLabelEventUpserted.new(hash)
              else EventUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class EventUndefinedType < Event

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableCard

          module Types
            CARD = 'card' unless defined?(CARD)
            CARD_REFERENCE = 'card_reference' unless defined?(CARD_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableCard')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_card directly - must use one of the specific types: card, card_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableCard.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_card] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CARD; Card.new(hash)
              when Types::CARD_REFERENCE; CardReference.new(hash)
              else ExpandableCardUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableCardUndefinedType < ExpandableCard

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableExperience

          module Types
            EXPERIENCE = 'experience' unless defined?(EXPERIENCE)
            EXPERIENCE_REFERENCE = 'experience_reference' unless defined?(EXPERIENCE_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableExperience')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_experience directly - must use one of the specific types: experience, experience_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableExperience.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_experience] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::EXPERIENCE; Experience.new(hash)
              when Types::EXPERIENCE_REFERENCE; ExperienceReference.new(hash)
              else ExpandableExperienceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableExperienceUndefinedType < ExpandableExperience

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # An item function can be represented with just its Id, or the entire model
        class ExpandableItemFunction

          module Types
            ITEM_FUNCTION = 'item_function' unless defined?(ITEM_FUNCTION)
            ITEM_FUNCTION_REFERENCE = 'item_function_reference' unless defined?(ITEM_FUNCTION_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableItemFunction')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_item_function directly - must use one of the specific types: item_function, item_function_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableItemFunction.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_item_function] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ITEM_FUNCTION; ItemFunction.new(hash)
              when Types::ITEM_FUNCTION_REFERENCE; ItemFunctionReference.new(hash)
              else ExpandableItemFunctionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableItemFunctionUndefinedType < ExpandableItemFunction

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableOrganization

          module Types
            ORGANIZATION = 'organization' unless defined?(ORGANIZATION)
            ORGANIZATION_REFERENCE = 'organization_reference' unless defined?(ORGANIZATION_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableOrganization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_organization directly - must use one of the specific types: organization, organization_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableOrganization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_organization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION; Organization.new(hash)
              when Types::ORGANIZATION_REFERENCE; OrganizationReference.new(hash)
              else ExpandableOrganizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableOrganizationUndefinedType < ExpandableOrganization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandablePayment

          module Types
            PAYMENT_PAYPAL = 'payment_paypal' unless defined?(PAYMENT_PAYPAL)
            PAYMENT_REFERENCE = 'payment_reference' unless defined?(PAYMENT_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandablePayment')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_payment directly - must use one of the specific types: payment_paypal, payment_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandablePayment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_payment] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::PAYMENT_PAYPAL; PaymentPaypal.new(hash)
              when Types::PAYMENT_REFERENCE; PaymentReference.new(hash)
              else ExpandablePaymentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandablePaymentUndefinedType < ExpandablePayment

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # A subcatalog can be represented with just it's ID, or the entire model
        class ExpandableSubcatalog

          module Types
            SUBCATALOG = 'subcatalog' unless defined?(SUBCATALOG)
            SUBCATALOG_REFERENCE = 'subcatalog_reference' unless defined?(SUBCATALOG_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableSubcatalog')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_subcatalog directly - must use one of the specific types: subcatalog, subcatalog_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableSubcatalog.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_subcatalog] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::SUBCATALOG; Subcatalog.new(hash)
              when Types::SUBCATALOG_REFERENCE; SubcatalogReference.new(hash)
              else ExpandableSubcatalogUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableSubcatalogUndefinedType < ExpandableSubcatalog

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class ExpandableUser

          module Types
            USER = 'user' unless defined?(USER)
            USER_REFERENCE = 'user_reference' unless defined?(USER_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExpandableUser')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of expandable_user directly - must use one of the specific types: user, user_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExpandableUser.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[expandable_user] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::USER; User.new(hash)
              when Types::USER_REFERENCE; UserReference.new(hash)
              else ExpandableUserUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExpandableUserUndefinedType < ExpandableUser

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Export deliveries represent actions to take once a requested export has
        # completed. A common pattern would be to request delivery of the export via
        # email - you will then receive an email notification once the requested export
        # is ready
        class ExportDelivery

          module Types
            EXPORT_DELIVERY_EMAIL = 'export_delivery_email' unless defined?(EXPORT_DELIVERY_EMAIL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExportDelivery')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of export_delivery directly - must use one of the specific types: export_delivery_email'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExportDelivery.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[export_delivery] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::EXPORT_DELIVERY_EMAIL; ExportDeliveryEmail.new(hash)
              else ExportDeliveryUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExportDeliveryUndefinedType < ExportDelivery

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Defines the specific export data that defines which records are exported and
        # into which format
        class ExportType

          module Types
            ACCOUNT_TRANSACTIONS_EXPORT_TYPE = 'account_transactions_export_type' unless defined?(ACCOUNT_TRANSACTIONS_EXPORT_TYPE)
            ACCOUNT_ORDERS_EXPORT_TYPE = 'account_orders_export_type' unless defined?(ACCOUNT_ORDERS_EXPORT_TYPE)
            CATALOG_ITEM_EXPORT_TYPE = 'catalog_item_export_type' unless defined?(CATALOG_ITEM_EXPORT_TYPE)
            HARMONIZATION_OVERVIEW_EXPORT_TYPE = 'harmonization_overview_export_type' unless defined?(HARMONIZATION_OVERVIEW_EXPORT_TYPE)
            HARMONIZATION_HS6_EXPORT_TYPE = 'harmonization_hs6_export_type' unless defined?(HARMONIZATION_HS6_EXPORT_TYPE)
            HARMONIZATION_HS10_EXPORT_TYPE = 'harmonization_hs10_export_type' unless defined?(HARMONIZATION_HS10_EXPORT_TYPE)
            ORDER_EXPORT_TYPE = 'order_export_type' unless defined?(ORDER_EXPORT_TYPE)
            SOLIDUS_PRODUCT_EXPORT_TYPE = 'solidus_product_export_type' unless defined?(SOLIDUS_PRODUCT_EXPORT_TYPE)
            SOLIDUS_VARIANT_EXPORT_TYPE = 'solidus_variant_export_type' unless defined?(SOLIDUS_VARIANT_EXPORT_TYPE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'ExportType')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of export_type directly - must use one of the specific types: account_transactions_export_type, account_orders_export_type, catalog_item_export_type, harmonization_overview_export_type, harmonization_hs6_export_type, harmonization_hs10_export_type, order_export_type, solidus_product_export_type, solidus_variant_export_type'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def ExportType.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[export_type] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ACCOUNT_TRANSACTIONS_EXPORT_TYPE; AccountTransactionsExportType.new(hash)
              when Types::ACCOUNT_ORDERS_EXPORT_TYPE; AccountOrdersExportType.new(hash)
              when Types::CATALOG_ITEM_EXPORT_TYPE; CatalogItemExportType.new(hash)
              when Types::HARMONIZATION_OVERVIEW_EXPORT_TYPE; HarmonizationOverviewExportType.new(hash)
              when Types::HARMONIZATION_HS6_EXPORT_TYPE; HarmonizationHs6ExportType.new(hash)
              when Types::HARMONIZATION_HS10_EXPORT_TYPE; HarmonizationHs10ExportType.new(hash)
              when Types::ORDER_EXPORT_TYPE; OrderExportType.new(hash)
              when Types::SOLIDUS_PRODUCT_EXPORT_TYPE; SolidusProductExportType.new(hash)
              when Types::SOLIDUS_VARIANT_EXPORT_TYPE; SolidusVariantExportType.new(hash)
              else ExportTypeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class ExportTypeUndefinedType < ExportType

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Describes types of feeds that may be produced by Flow.
        class Feed

          module Types
            # A localized product catalog.
            CATALOG_FEED = 'catalog_feed' unless defined?(CATALOG_FEED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Feed')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of feed directly - must use one of the specific types: catalog_feed'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Feed.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[feed] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::CATALOG_FEED; CatalogFeed.new(hash)
              else FeedUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class FeedUndefinedType < Feed

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Types of rules used to apply on inventory to calculate available quantity
        class InventoryStrategy

          module Types
            # Enables backorders, setting an optional number of units that we allow for
            # backorder. For example, a backorder w/ quantity 10 will enable selling until
            # the actual inventory quantity is -10.
            INVENTORY_BACKORDER = 'inventory_backorder' unless defined?(INVENTORY_BACKORDER)
            # Treats inventory as available as long as the actual inventory quantity is >
            # the specified quantity. A common use case is to set quantity to zero to
            # indicate availability as long as there is at least 1 unit available.
            INVENTORY_STOCK = 'inventory_stock' unless defined?(INVENTORY_STOCK)
            # Items affected with rules pursuing an unlimited strategy will always be
            # available
            INVENTORY_UNLIMITED = 'inventory_unlimited' unless defined?(INVENTORY_UNLIMITED)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'InventoryStrategy')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of inventory_strategy directly - must use one of the specific types: inventory_backorder, inventory_stock, inventory_unlimited'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def InventoryStrategy.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[inventory_strategy] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::INVENTORY_BACKORDER; InventoryBackorder.new(hash)
              when Types::INVENTORY_STOCK; InventoryStock.new(hash)
              when Types::INVENTORY_UNLIMITED; InventoryUnlimited.new(hash)
              else InventoryStrategyUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class InventoryStrategyUndefinedType < InventoryStrategy

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # The localized prices for an item are returned as a list - the key of each
        # element is defined here
        class LocalizedPrice

          module Types
            LOCALIZED_ITEM_PRICE = 'localized_item_price' unless defined?(LOCALIZED_ITEM_PRICE)
            LOCALIZED_ITEM_VAT = 'localized_item_vat' unless defined?(LOCALIZED_ITEM_VAT)
            LOCALIZED_ITEM_DUTY = 'localized_item_duty' unless defined?(LOCALIZED_ITEM_DUTY)
            LOCALIZED_TOTAL = 'localized_total' unless defined?(LOCALIZED_TOTAL)
          end

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'LocalizedPrice')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of localized_price directly - must use one of the specific types: localized_item_price, localized_item_vat, localized_item_duty, localized_total'
          end

          def to_hash
            subtype_to_hash.merge(:key => @key)
          end

          def LocalizedPrice.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:key].to_s.strip
            if discriminator.empty?
              raise "Union type[localized_price] requires a field named 'key'"
            end
            case discriminator
              when Types::LOCALIZED_ITEM_PRICE; LocalizedItemPrice.new(hash)
              when Types::LOCALIZED_ITEM_VAT; LocalizedItemVat.new(hash)
              when Types::LOCALIZED_ITEM_DUTY; LocalizedItemDuty.new(hash)
              when Types::LOCALIZED_TOTAL; LocalizedTotal.new(hash)
              else LocalizedPriceUndefinedType.new(:key => discriminator)
            end
          end

        end

        class LocalizedPriceUndefinedType < LocalizedPrice

          attr_reader :name

          def initialize(incoming={})
            super(:key => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:key), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents data for a specific online payment method
        class Payment

          module Types
            PAYMENT_PAYPAL = 'payment_paypal' unless defined?(PAYMENT_PAYPAL)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Payment')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment directly - must use one of the specific types: payment_paypal'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Payment.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::PAYMENT_PAYPAL; PaymentPaypal.new(hash)
              else PaymentUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentUndefinedType < Payment

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Represents the data needed to initiate an online payment
        class PaymentForm

          module Types
            MERCHANT_OF_RECORD_PAYMENT_FORM = 'merchant_of_record_payment_form' unless defined?(MERCHANT_OF_RECORD_PAYMENT_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'PaymentForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of payment_form directly - must use one of the specific types: merchant_of_record_payment_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def PaymentForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[payment_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::MERCHANT_OF_RECORD_PAYMENT_FORM; MerchantOfRecordPaymentForm.new(hash)
              else PaymentFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PaymentFormUndefinedType < PaymentForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Promotion

          module Types
            FREE_SHIPPING = 'free_shipping' unless defined?(FREE_SHIPPING)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Promotion')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of promotion directly - must use one of the specific types: free_shipping'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Promotion.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[promotion] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::FREE_SHIPPING; FreeShipping.new(hash)
              else PromotionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class PromotionUndefinedType < Promotion

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Session

          module Types
            SHOPIFY_SESSION = 'shopify_session' unless defined?(SHOPIFY_SESSION)
            ORGANIZATION_SESSION = 'organization_session' unless defined?(ORGANIZATION_SESSION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Session')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of session directly - must use one of the specific types: shopify_session, organization_session'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Session.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[session] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::SHOPIFY_SESSION; ShopifySession.new(hash)
              when Types::ORGANIZATION_SESSION; OrganizationSession.new(hash)
              else SessionUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class SessionUndefinedType < Session

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class SessionAuthorization

          module Types
            ORGANIZATION_SESSION_AUTHORIZATION = 'organization_session_authorization' unless defined?(ORGANIZATION_SESSION_AUTHORIZATION)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'SessionAuthorization')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of session_authorization directly - must use one of the specific types: organization_session_authorization'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def SessionAuthorization.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[session_authorization] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_SESSION_AUTHORIZATION; OrganizationSessionAuthorization.new(hash)
              else SessionAuthorizationUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class SessionAuthorizationUndefinedType < SessionAuthorization

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        # Possible outcome types from a tier rule
        class TierRuleOutcome

          module Types
            # Add a certain amount on the actual base cost
            AMOUNT_MARGIN = 'amount_margin' unless defined?(AMOUNT_MARGIN)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            FLAT_RATE = 'flat_rate' unless defined?(FLAT_RATE)
            # Add a certain percentage of the actual base cost
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TierRuleOutcome')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of tier_rule_outcome directly - must use one of the specific types: amount_margin, at_cost, flat_rate, percent_margin'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TierRuleOutcome.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[tier_rule_outcome] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AMOUNT_MARGIN; AmountMargin.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::FLAT_RATE; FlatRate.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TierRuleOutcomeUndefinedType < TierRuleOutcome

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TierRuleOutcomeForm

          module Types
            AMOUNT_MARGIN_FORM = 'amount_margin_form' unless defined?(AMOUNT_MARGIN_FORM)
            FLAT_RATE_FORM = 'flat_rate_form' unless defined?(FLAT_RATE_FORM)
            AT_COST = 'at_cost' unless defined?(AT_COST)
            PERCENT_MARGIN = 'percent_margin' unless defined?(PERCENT_MARGIN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TierRuleOutcomeForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of tier_rule_outcome_form directly - must use one of the specific types: amount_margin_form, flat_rate_form, at_cost, percent_margin'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TierRuleOutcomeForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[tier_rule_outcome_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::AMOUNT_MARGIN_FORM; AmountMarginForm.new(hash)
              when Types::FLAT_RATE_FORM; FlatRateForm.new(hash)
              when Types::AT_COST; AtCost.new(hash)
              when Types::PERCENT_MARGIN; PercentMargin.new(hash)
              else TierRuleOutcomeFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TierRuleOutcomeFormUndefinedType < TierRuleOutcomeForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class Token

          module Types
            ORGANIZATION_TOKEN = 'organization_token' unless defined?(ORGANIZATION_TOKEN)
            PARTNER_TOKEN = 'partner_token' unless defined?(PARTNER_TOKEN)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'Token')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of token directly - must use one of the specific types: organization_token, partner_token'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def Token.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[token] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_TOKEN; OrganizationToken.new(hash)
              when Types::PARTNER_TOKEN; PartnerToken.new(hash)
              else TokenUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TokenUndefinedType < Token

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TokenForm

          module Types
            ORGANIZATION_TOKEN_FORM = 'organization_token_form' unless defined?(ORGANIZATION_TOKEN_FORM)
            PARTNER_TOKEN_FORM = 'partner_token_form' unless defined?(PARTNER_TOKEN_FORM)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TokenForm')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of token_form directly - must use one of the specific types: organization_token_form, partner_token_form'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TokenForm.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[token_form] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_TOKEN_FORM; OrganizationTokenForm.new(hash)
              when Types::PARTNER_TOKEN_FORM; PartnerTokenForm.new(hash)
              else TokenFormUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TokenFormUndefinedType < TokenForm

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class TokenReference

          module Types
            ORGANIZATION_TOKEN_REFERENCE = 'organization_token_reference' unless defined?(ORGANIZATION_TOKEN_REFERENCE)
            PARTNER_TOKEN_REFERENCE = 'partner_token_reference' unless defined?(PARTNER_TOKEN_REFERENCE)
          end

          attr_reader :discriminator

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:discriminator], 'TokenReference')
            @discriminator = HttpClient::Preconditions.assert_class('discriminator', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Cannot serialize an instance of token_reference directly - must use one of the specific types: organization_token_reference, partner_token_reference'
          end

          def to_hash
            subtype_to_hash.merge(:discriminator => @discriminator)
          end

          def TokenReference.from_json(hash)
            HttpClient::Preconditions.assert_class('hash', hash, Hash)
            discriminator = HttpClient::Helper.symbolize_keys(hash)[:discriminator].to_s.strip
            if discriminator.empty?
              raise "Union type[token_reference] requires a field named 'discriminator'"
            end
            case discriminator
              when Types::ORGANIZATION_TOKEN_REFERENCE; OrganizationTokenReference.new(hash)
              when Types::PARTNER_TOKEN_REFERENCE; PartnerTokenReference.new(hash)
              else TokenReferenceUndefinedType.new(:discriminator => discriminator)
            end
          end

        end

        class TokenReferenceUndefinedType < TokenReference

          attr_reader :name

          def initialize(incoming={})
            super(:discriminator => 'undefined_type')
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:discriminator), String)
          end

          def subtype_to_hash
            raise 'Unable to serialize undefined type to json'
          end

          def copy(incoming={})
            raise 'Operation not supported for undefined type'
          end

          def to_hash
            raise 'Operation not supported for undefined type'
          end

        end

        class AdjustmentReasonKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AdjustmentReasonKey for this value, creating a new instance for an unknown value
          def AdjustmentReasonKey.apply(value)
            if value.instance_of?(AdjustmentReasonKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AdjustmentReasonKey.new(value))
            end
          end

          # Returns the instance of AdjustmentReasonKey for this value, or nil if not found
          def AdjustmentReasonKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AdjustmentReasonKey.ALL.find { |v| v.value == value }
          end

          def AdjustmentReasonKey.ALL
            @@all ||= [AdjustmentReasonKey.duty_deminimis, AdjustmentReasonKey.vat_deminimis]
          end

          # If the duty de minimis value has not been met, an adjustment may be made to
          # offset any previously calculated duty.
          def AdjustmentReasonKey.duty_deminimis
            @@_duty_deminimis ||= AdjustmentReasonKey.new('duty_deminimis')
          end

          # If the VAT de minimis value has not been met, an adjustment may be made to
          # offset any previously calculated VAT.
          def AdjustmentReasonKey.vat_deminimis
            @@_vat_deminimis ||= AdjustmentReasonKey.new('vat_deminimis')
          end

          def to_hash
            value
          end

        end

        class AttributeDataType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AttributeDataType for this value, creating a new instance for an unknown value
          def AttributeDataType.apply(value)
            if value.instance_of?(AttributeDataType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AttributeDataType.new(value))
            end
          end

          # Returns the instance of AttributeDataType for this value, or nil if not found
          def AttributeDataType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AttributeDataType.ALL.find { |v| v.value == value }
          end

          def AttributeDataType.ALL
            @@all ||= [AttributeDataType.decimal, AttributeDataType.string]
          end

          # Decimal datatype without size or precision restrictions. Commonly used for
          # currency values.
          def AttributeDataType.decimal
            @@_decimal ||= AttributeDataType.new('decimal')
          end

          # Unvalidated string of characters.
          def AttributeDataType.string
            @@_string ||= AttributeDataType.new('string')
          end

          def to_hash
            value
          end

        end

        class AttributeIntent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AttributeIntent for this value, creating a new instance for an unknown value
          def AttributeIntent.apply(value)
            if value.instance_of?(AttributeIntent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AttributeIntent.new(value))
            end
          end

          # Returns the instance of AttributeIntent for this value, or nil if not found
          def AttributeIntent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AttributeIntent.ALL.find { |v| v.value == value }
          end

          def AttributeIntent.ALL
            @@all ||= [AttributeIntent.price]
          end

          # Attributes with this data type are inferred to be prices in the organization's
          # base currency and will be localized based on each Experience's pricing policy.
          def AttributeIntent.price
            @@_price ||= AttributeIntent.new('price')
          end

          def to_hash
            value
          end

        end

        class AuthorizationDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationDeclineCode for this value, creating a new instance for an unknown value
          def AuthorizationDeclineCode.apply(value)
            if value.instance_of?(AuthorizationDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationDeclineCode.new(value))
            end
          end

          # Returns the instance of AuthorizationDeclineCode for this value, or nil if not found
          def AuthorizationDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationDeclineCode.ALL.find { |v| v.value == value }
          end

          def AuthorizationDeclineCode.ALL
            @@all ||= [AuthorizationDeclineCode.expired, AuthorizationDeclineCode.invalid_name, AuthorizationDeclineCode.invalid_number, AuthorizationDeclineCode.invalid_expiration, AuthorizationDeclineCode.no_account, AuthorizationDeclineCode.avs, AuthorizationDeclineCode.cvv, AuthorizationDeclineCode.fraud, AuthorizationDeclineCode.duplicate, AuthorizationDeclineCode.not_supported, AuthorizationDeclineCode.unknown]
          end

          # Payment method has expired
          def AuthorizationDeclineCode.expired
            @@_expired ||= AuthorizationDeclineCode.new('expired')
          end

          # Invalid card holder name
          def AuthorizationDeclineCode.invalid_name
            @@_invalid_name ||= AuthorizationDeclineCode.new('invalid_name')
          end

          # Invalid payment number
          def AuthorizationDeclineCode.invalid_number
            @@_invalid_number ||= AuthorizationDeclineCode.new('invalid_number')
          end

          # Invalid expiration date
          def AuthorizationDeclineCode.invalid_expiration
            @@_invalid_expiration ||= AuthorizationDeclineCode.new('invalid_expiration')
          end

          # The provided payment method is not known by the issuing bank (the account does
          # not exist)
          def AuthorizationDeclineCode.no_account
            @@_no_account ||= AuthorizationDeclineCode.new('no_account')
          end

          # Declined due to avs mismatch)
          def AuthorizationDeclineCode.avs
            @@_avs ||= AuthorizationDeclineCode.new('avs')
          end

          # Declined due to cvv mismatch)
          def AuthorizationDeclineCode.cvv
            @@_cvv ||= AuthorizationDeclineCode.new('cvv')
          end

          # Declined due to suspected fraud
          def AuthorizationDeclineCode.fraud
            @@_fraud ||= AuthorizationDeclineCode.new('fraud')
          end

          # Declined due to suspected duplicate transaction
          def AuthorizationDeclineCode.duplicate
            @@_duplicate ||= AuthorizationDeclineCode.new('duplicate')
          end

          # Declined as payment method is not supported
          def AuthorizationDeclineCode.not_supported
            @@_not_supported ||= AuthorizationDeclineCode.new('not_supported')
          end

          # Declined due to another reason (details not known)
          def AuthorizationDeclineCode.unknown
            @@_unknown ||= AuthorizationDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class AuthorizationDeleteErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationDeleteErrorCode for this value, creating a new instance for an unknown value
          def AuthorizationDeleteErrorCode.apply(value)
            if value.instance_of?(AuthorizationDeleteErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationDeleteErrorCode.new(value))
            end
          end

          # Returns the instance of AuthorizationDeleteErrorCode for this value, or nil if not found
          def AuthorizationDeleteErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationDeleteErrorCode.ALL.find { |v| v.value == value }
          end

          def AuthorizationDeleteErrorCode.ALL
            @@all ||= [AuthorizationDeleteErrorCode.expired, AuthorizationDeleteErrorCode.captured, AuthorizationDeleteErrorCode.unknown]
          end

          # Payment authorization has expired
          def AuthorizationDeleteErrorCode.expired
            @@_expired ||= AuthorizationDeleteErrorCode.new('expired')
          end

          # Payment authorization has already been captured. Please create a refund.
          def AuthorizationDeleteErrorCode.captured
            @@_captured ||= AuthorizationDeleteErrorCode.new('captured')
          end

          # Failed due to another reason (details not known)
          def AuthorizationDeleteErrorCode.unknown
            @@_unknown ||= AuthorizationDeleteErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class AuthorizationOption

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationOption for this value, creating a new instance for an unknown value
          def AuthorizationOption.apply(value)
            if value.instance_of?(AuthorizationOption)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationOption.new(value))
            end
          end

          # Returns the instance of AuthorizationOption for this value, or nil if not found
          def AuthorizationOption.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationOption.ALL.find { |v| v.value == value }
          end

          def AuthorizationOption.ALL
            @@all ||= [AuthorizationOption.store_card]
          end

          # If set, and the authorization is created using a one time nonce, we
          # automatically tokenize and store the card. In these cases you will want to
          # store the new card token in the authorization response (card object)
          def AuthorizationOption.store_card
            @@_store_card ||= AuthorizationOption.new('store_card')
          end

          def to_hash
            value
          end

        end

        class AuthorizationStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AuthorizationStatus for this value, creating a new instance for an unknown value
          def AuthorizationStatus.apply(value)
            if value.instance_of?(AuthorizationStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AuthorizationStatus.new(value))
            end
          end

          # Returns the instance of AuthorizationStatus for this value, or nil if not found
          def AuthorizationStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AuthorizationStatus.ALL.find { |v| v.value == value }
          end

          def AuthorizationStatus.ALL
            @@all ||= [AuthorizationStatus.pending, AuthorizationStatus.pending_call_bank, AuthorizationStatus.authorized, AuthorizationStatus.declined, AuthorizationStatus.voided]
          end

          # If an immediate response is not available, the state will be 'pending' - this
          # usually indicates fraud review requires additional time / verification (or a
          # potential network issue with the issuing bank)
          def AuthorizationStatus.pending
            @@_pending ||= AuthorizationStatus.new('pending')
          end

          # Bank is requesting consumer contact them directly to authorize the transaction
          def AuthorizationStatus.pending_call_bank
            @@_pending_call_bank ||= AuthorizationStatus.new('pending_call_bank')
          end

          # Authorization was successful
          def AuthorizationStatus.authorized
            @@_authorized ||= AuthorizationStatus.new('authorized')
          end

          # Indicates the authorization has been declined by the issuing bank. See the
          # authorization decline code for more details as to the reason for decline.
          def AuthorizationStatus.declined
            @@_declined ||= AuthorizationStatus.new('declined')
          end

          # Indicates the authorization has been voided. You can void an authorization up
          # until the moment you capture funds; once you have captured funds you must
          # create refunds.
          def AuthorizationStatus.voided
            @@_voided ||= AuthorizationStatus.new('voided')
          end

          def to_hash
            value
          end

        end

        class AvsCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of AvsCode for this value, creating a new instance for an unknown value
          def AvsCode.apply(value)
            if value.instance_of?(AvsCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || AvsCode.new(value))
            end
          end

          # Returns the instance of AvsCode for this value, or nil if not found
          def AvsCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            AvsCode.ALL.find { |v| v.value == value }
          end

          def AvsCode.ALL
            @@all ||= [AvsCode.match, AvsCode.partial, AvsCode.unsupported, AvsCode.no_match]
          end

          # Full match
          def AvsCode.match
            @@_match ||= AvsCode.new('match')
          end

          # Partial match; see details in 'avs' model to undestand which components
          # matched
          def AvsCode.partial
            @@_partial ||= AvsCode.new('partial')
          end

          # Issuer does not support address verification
          def AvsCode.unsupported
            @@_unsupported ||= AvsCode.new('unsupported')
          end

          # Address does not match expected card values
          def AvsCode.no_match
            @@_no_match ||= AvsCode.new('no_match')
          end

          def to_hash
            value
          end

        end

        class Calendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Calendar for this value, creating a new instance for an unknown value
          def Calendar.apply(value)
            if value.instance_of?(Calendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Calendar.new(value))
            end
          end

          # Returns the instance of Calendar for this value, or nil if not found
          def Calendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Calendar.ALL.find { |v| v.value == value }
          end

          def Calendar.ALL
            @@all ||= [Calendar.weekdays, Calendar.everyday]
          end

          # Mon - Fri
          def Calendar.weekdays
            @@_weekdays ||= Calendar.new('weekdays')
          end

          # 7 days per week
          def Calendar.everyday
            @@_everyday ||= Calendar.new('everyday')
          end

          def to_hash
            value
          end

        end

        class Capability

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Capability for this value, creating a new instance for an unknown value
          def Capability.apply(value)
            if value.instance_of?(Capability)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Capability.new(value))
            end
          end

          # Returns the instance of Capability for this value, or nil if not found
          def Capability.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Capability.ALL.find { |v| v.value == value }
          end

          def Capability.ALL
            @@all ||= [Capability.crossdock]
          end

          def Capability.crossdock
            @@_crossdock ||= Capability.new('crossdock')
          end

          def to_hash
            value
          end

        end

        class CaptureDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CaptureDeclineCode for this value, creating a new instance for an unknown value
          def CaptureDeclineCode.apply(value)
            if value.instance_of?(CaptureDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CaptureDeclineCode.new(value))
            end
          end

          # Returns the instance of CaptureDeclineCode for this value, or nil if not found
          def CaptureDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CaptureDeclineCode.ALL.find { |v| v.value == value }
          end

          def CaptureDeclineCode.ALL
            @@all ||= [CaptureDeclineCode.expired, CaptureDeclineCode.insufficient_funds, CaptureDeclineCode.unknown]
          end

          # Payment authorization has expired
          def CaptureDeclineCode.expired
            @@_expired ||= CaptureDeclineCode.new('expired')
          end

          # The amount to capture exceeded the amount authorized and not yet captured
          def CaptureDeclineCode.insufficient_funds
            @@_insufficient_funds ||= CaptureDeclineCode.new('insufficient_funds')
          end

          # Failed due to another reason (details not known)
          def CaptureDeclineCode.unknown
            @@_unknown ||= CaptureDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class CardErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardErrorCode for this value, creating a new instance for an unknown value
          def CardErrorCode.apply(value)
            if value.instance_of?(CardErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardErrorCode.new(value))
            end
          end

          # Returns the instance of CardErrorCode for this value, or nil if not found
          def CardErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardErrorCode.ALL.find { |v| v.value == value }
          end

          def CardErrorCode.ALL
            @@all ||= [CardErrorCode.invalid_address, CardErrorCode.invalid_name, CardErrorCode.invalid_number, CardErrorCode.invalid_expiration, CardErrorCode.avs, CardErrorCode.cvv, CardErrorCode.fraud, CardErrorCode.unknown]
          end

          # Invalid billing address
          def CardErrorCode.invalid_address
            @@_invalid_address ||= CardErrorCode.new('invalid_address')
          end

          # Invalid cardholder name
          def CardErrorCode.invalid_name
            @@_invalid_name ||= CardErrorCode.new('invalid_name')
          end

          # Invalid payment number
          def CardErrorCode.invalid_number
            @@_invalid_number ||= CardErrorCode.new('invalid_number')
          end

          # Invalid expiration date
          def CardErrorCode.invalid_expiration
            @@_invalid_expiration ||= CardErrorCode.new('invalid_expiration')
          end

          # Declined due to avs mismatch
          def CardErrorCode.avs
            @@_avs ||= CardErrorCode.new('avs')
          end

          # Declined due to cvv mismatch
          def CardErrorCode.cvv
            @@_cvv ||= CardErrorCode.new('cvv')
          end

          # Declined due to suspected fraud
          def CardErrorCode.fraud
            @@_fraud ||= CardErrorCode.new('fraud')
          end

          # Declined due to another reason (details not known)
          def CardErrorCode.unknown
            @@_unknown ||= CardErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class CardType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CardType for this value, creating a new instance for an unknown value
          def CardType.apply(value)
            if value.instance_of?(CardType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CardType.new(value))
            end
          end

          # Returns the instance of CardType for this value, or nil if not found
          def CardType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CardType.ALL.find { |v| v.value == value }
          end

          def CardType.ALL
            @@all ||= [CardType.american_express, CardType.cartes_bancaires, CardType.china_union_pay, CardType.dankort, CardType.diners_club, CardType.discover, CardType.jcb, CardType.maestro, CardType.mastercard, CardType.visa]
          end

          def CardType.american_express
            @@_american_express ||= CardType.new('american_express')
          end

          def CardType.cartes_bancaires
            @@_cartes_bancaires ||= CardType.new('cartes_bancaires')
          end

          def CardType.china_union_pay
            @@_china_union_pay ||= CardType.new('china_union_pay')
          end

          def CardType.dankort
            @@_dankort ||= CardType.new('dankort')
          end

          def CardType.diners_club
            @@_diners_club ||= CardType.new('diners_club')
          end

          def CardType.discover
            @@_discover ||= CardType.new('discover')
          end

          def CardType.jcb
            @@_jcb ||= CardType.new('jcb')
          end

          def CardType.maestro
            @@_maestro ||= CardType.new('maestro')
          end

          def CardType.mastercard
            @@_mastercard ||= CardType.new('mastercard')
          end

          def CardType.visa
            @@_visa ||= CardType.new('visa')
          end

          def to_hash
            value
          end

        end

        class ChangeType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ChangeType for this value, creating a new instance for an unknown value
          def ChangeType.apply(value)
            if value.instance_of?(ChangeType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ChangeType.new(value))
            end
          end

          # Returns the instance of ChangeType for this value, or nil if not found
          def ChangeType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ChangeType.ALL.find { |v| v.value == value }
          end

          def ChangeType.ALL
            @@all ||= [ChangeType.insert, ChangeType.update, ChangeType.delete]
          end

          def ChangeType.insert
            @@_insert ||= ChangeType.new('insert')
          end

          def ChangeType.update
            @@_update ||= ChangeType.new('update')
          end

          def ChangeType.delete
            @@_delete ||= ChangeType.new('delete')
          end

          def to_hash
            value
          end

        end

        class CvvCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of CvvCode for this value, creating a new instance for an unknown value
          def CvvCode.apply(value)
            if value.instance_of?(CvvCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || CvvCode.new(value))
            end
          end

          # Returns the instance of CvvCode for this value, or nil if not found
          def CvvCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            CvvCode.ALL.find { |v| v.value == value }
          end

          def CvvCode.ALL
            @@all ||= [CvvCode.match, CvvCode.suspicious, CvvCode.unsupported, CvvCode.no_match]
          end

          # CVV matches
          def CvvCode.match
            @@_match ||= CvvCode.new('match')
          end

          # CVV did not match; Transaction is possibly fraudulent
          def CvvCode.suspicious
            @@_suspicious ||= CvvCode.new('suspicious')
          end

          # CVV did not match; Issuer does not support card verification numbers
          def CvvCode.unsupported
            @@_unsupported ||= CvvCode.new('unsupported')
          end

          # CVV did not match; Specific reason not available
          def CvvCode.no_match
            @@_no_match ||= CvvCode.new('no_match')
          end

          def to_hash
            value
          end

        end

        class DayOfWeek

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DayOfWeek for this value, creating a new instance for an unknown value
          def DayOfWeek.apply(value)
            if value.instance_of?(DayOfWeek)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DayOfWeek.new(value))
            end
          end

          # Returns the instance of DayOfWeek for this value, or nil if not found
          def DayOfWeek.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DayOfWeek.ALL.find { |v| v.value == value }
          end

          def DayOfWeek.ALL
            @@all ||= [DayOfWeek.sunday, DayOfWeek.monday, DayOfWeek.tuesday, DayOfWeek.wednesday, DayOfWeek.thursday, DayOfWeek.friday, DayOfWeek.saturday]
          end

          def DayOfWeek.sunday
            @@_sunday ||= DayOfWeek.new('sunday')
          end

          def DayOfWeek.monday
            @@_monday ||= DayOfWeek.new('monday')
          end

          def DayOfWeek.tuesday
            @@_tuesday ||= DayOfWeek.new('tuesday')
          end

          def DayOfWeek.wednesday
            @@_wednesday ||= DayOfWeek.new('wednesday')
          end

          def DayOfWeek.thursday
            @@_thursday ||= DayOfWeek.new('thursday')
          end

          def DayOfWeek.friday
            @@_friday ||= DayOfWeek.new('friday')
          end

          def DayOfWeek.saturday
            @@_saturday ||= DayOfWeek.new('saturday')
          end

          def to_hash
            value
          end

        end

        class DeliveredDuty

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of DeliveredDuty for this value, creating a new instance for an unknown value
          def DeliveredDuty.apply(value)
            if value.instance_of?(DeliveredDuty)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || DeliveredDuty.new(value))
            end
          end

          # Returns the instance of DeliveredDuty for this value, or nil if not found
          def DeliveredDuty.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            DeliveredDuty.ALL.find { |v| v.value == value }
          end

          def DeliveredDuty.ALL
            @@all ||= [DeliveredDuty.paid, DeliveredDuty.unpaid]
          end

          # Delivered Duty Paid (DDP). See https://en.wikipedia.org/wiki/Incoterms for
          # more information
          def DeliveredDuty.paid
            @@_paid ||= DeliveredDuty.new('paid')
          end

          # Delivered Duty Unpaid (DDU). See https://en.wikipedia.org/wiki/Incoterms for
          # more information
          def DeliveredDuty.unpaid
            @@_unpaid ||= DeliveredDuty.new('unpaid')
          end

          def to_hash
            value
          end

        end

        class Direction

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Direction for this value, creating a new instance for an unknown value
          def Direction.apply(value)
            if value.instance_of?(Direction)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Direction.new(value))
            end
          end

          # Returns the instance of Direction for this value, or nil if not found
          def Direction.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Direction.ALL.find { |v| v.value == value }
          end

          def Direction.ALL
            @@all ||= [Direction.outbound, Direction.return]
          end

          # Outbound shipment to typically fulfill a customer order
          def Direction.outbound
            @@_outbound ||= Direction.new('outbound')
          end

          # Inbound or return shipment
          def Direction.return
            @@_return ||= Direction.new('return')
          end

          def to_hash
            value
          end

        end

        class Environment

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Environment for this value, creating a new instance for an unknown value
          def Environment.apply(value)
            if value.instance_of?(Environment)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Environment.new(value))
            end
          end

          # Returns the instance of Environment for this value, or nil if not found
          def Environment.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Environment.ALL.find { |v| v.value == value }
          end

          def Environment.ALL
            @@all ||= [Environment.sandbox, Environment.production]
          end

          # In sandbox, no external services (e.g. orders, payments, logistics) will
          # generate real transactions
          def Environment.sandbox
            @@_sandbox ||= Environment.new('sandbox')
          end

          # In production, all external services are live and will generate real
          # transactions
          def Environment.production
            @@_production ||= Environment.new('production')
          end

          def to_hash
            value
          end

        end

        class EventType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of EventType for this value, creating a new instance for an unknown value
          def EventType.apply(value)
            if value.instance_of?(EventType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || EventType.new(value))
            end
          end

          # Returns the instance of EventType for this value, or nil if not found
          def EventType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            EventType.ALL.find { |v| v.value == value }
          end

          def EventType.ALL
            @@all ||= [EventType.attribute_upserted, EventType.attribute_deleted, EventType.catalog_upserted, EventType.catalog_deleted, EventType.subcatalog_upserted, EventType.subcatalog_deleted, EventType.catalog_item_upserted, EventType.catalog_item_deleted, EventType.subcatalog_item_upserted, EventType.subcatalog_item_deleted, EventType.rate_deleted, EventType.rate_upserted, EventType.available_promotions_upserted, EventType.available_promotions_deleted, EventType.allocation_deleted, EventType.allocation_upserted, EventType.experience_deleted, EventType.experience_upserted, EventType.item_margin_deleted, EventType.item_margin_upserted, EventType.item_sales_margin_deleted, EventType.item_sales_margin_upserted, EventType.label_format_deleted, EventType.label_format_upserted, EventType.order_deleted, EventType.order_upserted, EventType.order_identifier_deleted, EventType.order_identifier_upserted, EventType.pricing_deleted, EventType.pricing_upserted, EventType.tier_upserted, EventType.tier_deleted, EventType.hs6_code_upserted, EventType.hs6_code_deleted, EventType.hs10_code_upserted, EventType.hs10_code_deleted, EventType.item_origin_upserted, EventType.item_origin_deleted, EventType.harmonized_item_upserted, EventType.harmonized_item_deleted, EventType.snapshot_upserted, EventType.snapshot_deleted, EventType.label_upserted, EventType.notification_upserted, EventType.notification_deleted, EventType.localized_item_upserted, EventType.localized_item_deleted, EventType.localized_item_snapshot, EventType.membership_upserted, EventType.membership_deleted, EventType.organization_upserted, EventType.organization_deleted, EventType.authorization_upserted, EventType.authorization_deleted, EventType.authorization_deleted_v2, EventType.authorization_status_changed, EventType.card_authorization_upserted, EventType.card_authorization_upserted_v2, EventType.online_authorization_upserted, EventType.online_authorization_upserted_v2, EventType.capture_upserted, EventType.capture_upserted_v2, EventType.card_upserted, EventType.card_upserted_v2, EventType.card_deleted, EventType.payment_upserted, EventType.payment_deleted, EventType.refund_upserted, EventType.refund_upserted_v2, EventType.return_upserted, EventType.return_deleted, EventType.targeting_item_upserted, EventType.targeting_item_deleted, EventType.tracking_label_event_upserted]
          end

          def EventType.attribute_upserted
            @@_attribute_upserted ||= EventType.new('attribute_upserted')
          end

          def EventType.attribute_deleted
            @@_attribute_deleted ||= EventType.new('attribute_deleted')
          end

          def EventType.catalog_upserted
            @@_catalog_upserted ||= EventType.new('catalog_upserted')
          end

          def EventType.catalog_deleted
            @@_catalog_deleted ||= EventType.new('catalog_deleted')
          end

          def EventType.subcatalog_upserted
            @@_subcatalog_upserted ||= EventType.new('subcatalog_upserted')
          end

          def EventType.subcatalog_deleted
            @@_subcatalog_deleted ||= EventType.new('subcatalog_deleted')
          end

          def EventType.catalog_item_upserted
            @@_catalog_item_upserted ||= EventType.new('catalog_item_upserted')
          end

          def EventType.catalog_item_deleted
            @@_catalog_item_deleted ||= EventType.new('catalog_item_deleted')
          end

          def EventType.subcatalog_item_upserted
            @@_subcatalog_item_upserted ||= EventType.new('subcatalog_item_upserted')
          end

          def EventType.subcatalog_item_deleted
            @@_subcatalog_item_deleted ||= EventType.new('subcatalog_item_deleted')
          end

          def EventType.rate_deleted
            @@_rate_deleted ||= EventType.new('rate_deleted')
          end

          def EventType.rate_upserted
            @@_rate_upserted ||= EventType.new('rate_upserted')
          end

          def EventType.available_promotions_upserted
            @@_available_promotions_upserted ||= EventType.new('available_promotions_upserted')
          end

          def EventType.available_promotions_deleted
            @@_available_promotions_deleted ||= EventType.new('available_promotions_deleted')
          end

          def EventType.allocation_deleted
            @@_allocation_deleted ||= EventType.new('allocation_deleted')
          end

          def EventType.allocation_upserted
            @@_allocation_upserted ||= EventType.new('allocation_upserted')
          end

          def EventType.experience_deleted
            @@_experience_deleted ||= EventType.new('experience_deleted')
          end

          def EventType.experience_upserted
            @@_experience_upserted ||= EventType.new('experience_upserted')
          end

          def EventType.item_margin_deleted
            @@_item_margin_deleted ||= EventType.new('item_margin_deleted')
          end

          def EventType.item_margin_upserted
            @@_item_margin_upserted ||= EventType.new('item_margin_upserted')
          end

          def EventType.item_sales_margin_deleted
            @@_item_sales_margin_deleted ||= EventType.new('item_sales_margin_deleted')
          end

          def EventType.item_sales_margin_upserted
            @@_item_sales_margin_upserted ||= EventType.new('item_sales_margin_upserted')
          end

          def EventType.label_format_deleted
            @@_label_format_deleted ||= EventType.new('label_format_deleted')
          end

          def EventType.label_format_upserted
            @@_label_format_upserted ||= EventType.new('label_format_upserted')
          end

          def EventType.order_deleted
            @@_order_deleted ||= EventType.new('order_deleted')
          end

          def EventType.order_upserted
            @@_order_upserted ||= EventType.new('order_upserted')
          end

          def EventType.order_identifier_deleted
            @@_order_identifier_deleted ||= EventType.new('order_identifier_deleted')
          end

          def EventType.order_identifier_upserted
            @@_order_identifier_upserted ||= EventType.new('order_identifier_upserted')
          end

          def EventType.pricing_deleted
            @@_pricing_deleted ||= EventType.new('pricing_deleted')
          end

          def EventType.pricing_upserted
            @@_pricing_upserted ||= EventType.new('pricing_upserted')
          end

          def EventType.tier_upserted
            @@_tier_upserted ||= EventType.new('tier_upserted')
          end

          def EventType.tier_deleted
            @@_tier_deleted ||= EventType.new('tier_deleted')
          end

          def EventType.hs6_code_upserted
            @@_hs6_code_upserted ||= EventType.new('hs6_code_upserted')
          end

          def EventType.hs6_code_deleted
            @@_hs6_code_deleted ||= EventType.new('hs6_code_deleted')
          end

          def EventType.hs10_code_upserted
            @@_hs10_code_upserted ||= EventType.new('hs10_code_upserted')
          end

          def EventType.hs10_code_deleted
            @@_hs10_code_deleted ||= EventType.new('hs10_code_deleted')
          end

          def EventType.item_origin_upserted
            @@_item_origin_upserted ||= EventType.new('item_origin_upserted')
          end

          def EventType.item_origin_deleted
            @@_item_origin_deleted ||= EventType.new('item_origin_deleted')
          end

          def EventType.harmonized_item_upserted
            @@_harmonized_item_upserted ||= EventType.new('harmonized_item_upserted')
          end

          def EventType.harmonized_item_deleted
            @@_harmonized_item_deleted ||= EventType.new('harmonized_item_deleted')
          end

          def EventType.snapshot_upserted
            @@_snapshot_upserted ||= EventType.new('snapshot_upserted')
          end

          def EventType.snapshot_deleted
            @@_snapshot_deleted ||= EventType.new('snapshot_deleted')
          end

          def EventType.label_upserted
            @@_label_upserted ||= EventType.new('label_upserted')
          end

          def EventType.notification_upserted
            @@_notification_upserted ||= EventType.new('notification_upserted')
          end

          def EventType.notification_deleted
            @@_notification_deleted ||= EventType.new('notification_deleted')
          end

          def EventType.localized_item_upserted
            @@_localized_item_upserted ||= EventType.new('localized_item_upserted')
          end

          def EventType.localized_item_deleted
            @@_localized_item_deleted ||= EventType.new('localized_item_deleted')
          end

          def EventType.localized_item_snapshot
            @@_localized_item_snapshot ||= EventType.new('localized_item_snapshot')
          end

          def EventType.membership_upserted
            @@_membership_upserted ||= EventType.new('membership_upserted')
          end

          def EventType.membership_deleted
            @@_membership_deleted ||= EventType.new('membership_deleted')
          end

          def EventType.organization_upserted
            @@_organization_upserted ||= EventType.new('organization_upserted')
          end

          def EventType.organization_deleted
            @@_organization_deleted ||= EventType.new('organization_deleted')
          end

          def EventType.authorization_upserted
            @@_authorization_upserted ||= EventType.new('authorization_upserted')
          end

          def EventType.authorization_deleted
            @@_authorization_deleted ||= EventType.new('authorization_deleted')
          end

          def EventType.authorization_deleted_v2
            @@_authorization_deleted_v2 ||= EventType.new('authorization_deleted_v2')
          end

          def EventType.authorization_status_changed
            @@_authorization_status_changed ||= EventType.new('authorization_status_changed')
          end

          def EventType.card_authorization_upserted
            @@_card_authorization_upserted ||= EventType.new('card_authorization_upserted')
          end

          def EventType.card_authorization_upserted_v2
            @@_card_authorization_upserted_v2 ||= EventType.new('card_authorization_upserted_v2')
          end

          def EventType.online_authorization_upserted
            @@_online_authorization_upserted ||= EventType.new('online_authorization_upserted')
          end

          def EventType.online_authorization_upserted_v2
            @@_online_authorization_upserted_v2 ||= EventType.new('online_authorization_upserted_v2')
          end

          def EventType.capture_upserted
            @@_capture_upserted ||= EventType.new('capture_upserted')
          end

          def EventType.capture_upserted_v2
            @@_capture_upserted_v2 ||= EventType.new('capture_upserted_v2')
          end

          def EventType.card_upserted
            @@_card_upserted ||= EventType.new('card_upserted')
          end

          def EventType.card_upserted_v2
            @@_card_upserted_v2 ||= EventType.new('card_upserted_v2')
          end

          def EventType.card_deleted
            @@_card_deleted ||= EventType.new('card_deleted')
          end

          def EventType.payment_upserted
            @@_payment_upserted ||= EventType.new('payment_upserted')
          end

          def EventType.payment_deleted
            @@_payment_deleted ||= EventType.new('payment_deleted')
          end

          def EventType.refund_upserted
            @@_refund_upserted ||= EventType.new('refund_upserted')
          end

          def EventType.refund_upserted_v2
            @@_refund_upserted_v2 ||= EventType.new('refund_upserted_v2')
          end

          def EventType.return_upserted
            @@_return_upserted ||= EventType.new('return_upserted')
          end

          def EventType.return_deleted
            @@_return_deleted ||= EventType.new('return_deleted')
          end

          def EventType.targeting_item_upserted
            @@_targeting_item_upserted ||= EventType.new('targeting_item_upserted')
          end

          def EventType.targeting_item_deleted
            @@_targeting_item_deleted ||= EventType.new('targeting_item_deleted')
          end

          def EventType.tracking_label_event_upserted
            @@_tracking_label_event_upserted ||= EventType.new('tracking_label_event_upserted')
          end

          def to_hash
            value
          end

        end

        class ExceptionType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExceptionType for this value, creating a new instance for an unknown value
          def ExceptionType.apply(value)
            if value.instance_of?(ExceptionType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExceptionType.new(value))
            end
          end

          # Returns the instance of ExceptionType for this value, or nil if not found
          def ExceptionType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExceptionType.ALL.find { |v| v.value == value }
          end

          def ExceptionType.ALL
            @@all ||= [ExceptionType.open, ExceptionType.closed]
          end

          def ExceptionType.open
            @@_open ||= ExceptionType.new('open')
          end

          def ExceptionType.closed
            @@_closed ||= ExceptionType.new('closed')
          end

          def to_hash
            value
          end

        end

        class ExportStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ExportStatus for this value, creating a new instance for an unknown value
          def ExportStatus.apply(value)
            if value.instance_of?(ExportStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ExportStatus.new(value))
            end
          end

          # Returns the instance of ExportStatus for this value, or nil if not found
          def ExportStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ExportStatus.ALL.find { |v| v.value == value }
          end

          def ExportStatus.ALL
            @@all ||= [ExportStatus.created, ExportStatus.processing, ExportStatus.completed, ExportStatus.failed]
          end

          def ExportStatus.created
            @@_created ||= ExportStatus.new('created')
          end

          def ExportStatus.processing
            @@_processing ||= ExportStatus.new('processing')
          end

          def ExportStatus.completed
            @@_completed ||= ExportStatus.new('completed')
          end

          def ExportStatus.failed
            @@_failed ||= ExportStatus.new('failed')
          end

          def to_hash
            value
          end

        end

        class FlowFieldName

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of FlowFieldName for this value, creating a new instance for an unknown value
          def FlowFieldName.apply(value)
            if value.instance_of?(FlowFieldName)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || FlowFieldName.new(value))
            end
          end

          # Returns the instance of FlowFieldName for this value, or nil if not found
          def FlowFieldName.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            FlowFieldName.ALL.find { |v| v.value == value }
          end

          def FlowFieldName.ALL
            @@all ||= [FlowFieldName.item_number, FlowFieldName.sku_attribute, FlowFieldName.product_id_attribute]
          end

          # The Flow catalog item number
          def FlowFieldName.item_number
            @@_item_number ||= FlowFieldName.new('item-number')
          end

          # A Flow catalog attribute named 'sku'
          def FlowFieldName.sku_attribute
            @@_sku_attribute ||= FlowFieldName.new('sku-attribute')
          end

          # A Flow catalog attribute named 'product_id'
          def FlowFieldName.product_id_attribute
            @@_product_id_attribute ||= FlowFieldName.new('product_id-attribute')
          end

          def to_hash
            value
          end

        end

        class GenericErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of GenericErrorCode for this value, creating a new instance for an unknown value
          def GenericErrorCode.apply(value)
            if value.instance_of?(GenericErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || GenericErrorCode.new(value))
            end
          end

          # Returns the instance of GenericErrorCode for this value, or nil if not found
          def GenericErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            GenericErrorCode.ALL.find { |v| v.value == value }
          end

          def GenericErrorCode.ALL
            @@all ||= [GenericErrorCode.generic_error, GenericErrorCode.client_error, GenericErrorCode.server_error]
          end

          # Generic errors are the default type. The accompanying message will provide
          # details on the failure.
          def GenericErrorCode.generic_error
            @@_generic_error ||= GenericErrorCode.new('generic_error')
          end

          # A client error has occurred. This represents a misconfiguration of the client
          def GenericErrorCode.client_error
            @@_client_error ||= GenericErrorCode.new('client_error')
          end

          # A server error has occurred. The Flow tech team is automatically notified of
          # all server errors
          def GenericErrorCode.server_error
            @@_server_error ||= GenericErrorCode.new('server_error')
          end

          def to_hash
            value
          end

        end

        class HolidayCalendar

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of HolidayCalendar for this value, creating a new instance for an unknown value
          def HolidayCalendar.apply(value)
            if value.instance_of?(HolidayCalendar)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || HolidayCalendar.new(value))
            end
          end

          # Returns the instance of HolidayCalendar for this value, or nil if not found
          def HolidayCalendar.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            HolidayCalendar.ALL.find { |v| v.value == value }
          end

          def HolidayCalendar.ALL
            @@all ||= [HolidayCalendar.us_bank_holidays, HolidayCalendar.jewish_holidays]
          end

          def HolidayCalendar.us_bank_holidays
            @@_us_bank_holidays ||= HolidayCalendar.new('us_bank_holidays')
          end

          def HolidayCalendar.jewish_holidays
            @@_jewish_holidays ||= HolidayCalendar.new('jewish_holidays')
          end

          def to_hash
            value
          end

        end

        class ImportType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ImportType for this value, creating a new instance for an unknown value
          def ImportType.apply(value)
            if value.instance_of?(ImportType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ImportType.new(value))
            end
          end

          # Returns the instance of ImportType for this value, or nil if not found
          def ImportType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ImportType.ALL.find { |v| v.value == value }
          end

          def ImportType.ALL
            @@all ||= [ImportType.harmonization_codes]
          end

          # Provides upload of HS-6 and HS-10 codes for the items in a catalog
          def ImportType.harmonization_codes
            @@_harmonization_codes ||= ImportType.new('harmonization_codes')
          end

          def to_hash
            value
          end

        end

        class IncludedLevyKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of IncludedLevyKey for this value, creating a new instance for an unknown value
          def IncludedLevyKey.apply(value)
            if value.instance_of?(IncludedLevyKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || IncludedLevyKey.new(value))
            end
          end

          # Returns the instance of IncludedLevyKey for this value, or nil if not found
          def IncludedLevyKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            IncludedLevyKey.ALL.find { |v| v.value == value }
          end

          def IncludedLevyKey.ALL
            @@all ||= [IncludedLevyKey.duty, IncludedLevyKey.vat, IncludedLevyKey.vat_and_duty]
          end

          def IncludedLevyKey.duty
            @@_duty ||= IncludedLevyKey.new('duty')
          end

          def IncludedLevyKey.vat
            @@_vat ||= IncludedLevyKey.new('vat')
          end

          def IncludedLevyKey.vat_and_duty
            @@_vat_and_duty ||= IncludedLevyKey.new('vat_and_duty')
          end

          def to_hash
            value
          end

        end

        class IncomingFeedFormat

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of IncomingFeedFormat for this value, creating a new instance for an unknown value
          def IncomingFeedFormat.apply(value)
            if value.instance_of?(IncomingFeedFormat)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || IncomingFeedFormat.new(value))
            end
          end

          # Returns the instance of IncomingFeedFormat for this value, or nil if not found
          def IncomingFeedFormat.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            IncomingFeedFormat.ALL.find { |v| v.value == value }
          end

          def IncomingFeedFormat.ALL
            @@all ||= [IncomingFeedFormat.google_xml, IncomingFeedFormat.google_sheet]
          end

          # Google RSS-like product catalog feed
          def IncomingFeedFormat.google_xml
            @@_google_xml ||= IncomingFeedFormat.new('google-xml')
          end

          # Google Sheet-based product catalog feed
          def IncomingFeedFormat.google_sheet
            @@_google_sheet ||= IncomingFeedFormat.new('google-sheet')
          end

          def to_hash
            value
          end

        end

        class IncomingFieldName

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of IncomingFieldName for this value, creating a new instance for an unknown value
          def IncomingFieldName.apply(value)
            if value.instance_of?(IncomingFieldName)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || IncomingFieldName.new(value))
            end
          end

          # Returns the instance of IncomingFieldName for this value, or nil if not found
          def IncomingFieldName.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            IncomingFieldName.ALL.find { |v| v.value == value }
          end

          def IncomingFieldName.ALL
            @@all ||= [IncomingFieldName.id, IncomingFieldName.mpn]
          end

          # The id field of the incoming feed
          def IncomingFieldName.id
            @@_id ||= IncomingFieldName.new('id')
          end

          # The Manufacturer's Product Number (MPN) field of the incoming feed
          def IncomingFieldName.mpn
            @@_mpn ||= IncomingFieldName.new('mpn')
          end

          def to_hash
            value
          end

        end

        class InvitationErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of InvitationErrorCode for this value, creating a new instance for an unknown value
          def InvitationErrorCode.apply(value)
            if value.instance_of?(InvitationErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || InvitationErrorCode.new(value))
            end
          end

          # Returns the instance of InvitationErrorCode for this value, or nil if not found
          def InvitationErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            InvitationErrorCode.ALL.find { |v| v.value == value }
          end

          def InvitationErrorCode.ALL
            @@all ||= [InvitationErrorCode.expired, InvitationErrorCode.invalid_email]
          end

          def InvitationErrorCode.expired
            @@_expired ||= InvitationErrorCode.new('expired')
          end

          def InvitationErrorCode.invalid_email
            @@_invalid_email ||= InvitationErrorCode.new('invalid_email')
          end

          def to_hash
            value
          end

        end

        class LevyComponent

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyComponent for this value, creating a new instance for an unknown value
          def LevyComponent.apply(value)
            if value.instance_of?(LevyComponent)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyComponent.new(value))
            end
          end

          # Returns the instance of LevyComponent for this value, or nil if not found
          def LevyComponent.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyComponent.ALL.find { |v| v.value == value }
          end

          def LevyComponent.ALL
            @@all ||= [LevyComponent.goods, LevyComponent.duty, LevyComponent.insurance, LevyComponent.freight, LevyComponent.vat]
          end

          # The value of goods
          def LevyComponent.goods
            @@_goods ||= LevyComponent.new('goods')
          end

          def LevyComponent.duty
            @@_duty ||= LevyComponent.new('duty')
          end

          def LevyComponent.insurance
            @@_insurance ||= LevyComponent.new('insurance')
          end

          def LevyComponent.freight
            @@_freight ||= LevyComponent.new('freight')
          end

          # Value-Added Tax
          def LevyComponent.vat
            @@_vat ||= LevyComponent.new('vat')
          end

          def to_hash
            value
          end

        end

        class LevyStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of LevyStrategy for this value, creating a new instance for an unknown value
          def LevyStrategy.apply(value)
            if value.instance_of?(LevyStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || LevyStrategy.new(value))
            end
          end

          # Returns the instance of LevyStrategy for this value, or nil if not found
          def LevyStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            LevyStrategy.ALL.find { |v| v.value == value }
          end

          def LevyStrategy.ALL
            @@all ||= [LevyStrategy.minimum, LevyStrategy.average, LevyStrategy.maximum]
          end

          def LevyStrategy.minimum
            @@_minimum ||= LevyStrategy.new('minimum')
          end

          def LevyStrategy.average
            @@_average ||= LevyStrategy.new('average')
          end

          def LevyStrategy.maximum
            @@_maximum ||= LevyStrategy.new('maximum')
          end

          def to_hash
            value
          end

        end

        class MarginType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MarginType for this value, creating a new instance for an unknown value
          def MarginType.apply(value)
            if value.instance_of?(MarginType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MarginType.new(value))
            end
          end

          # Returns the instance of MarginType for this value, or nil if not found
          def MarginType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MarginType.ALL.find { |v| v.value == value }
          end

          def MarginType.ALL
            @@all ||= [MarginType.fixed, MarginType.percent]
          end

          # A fixed amount to add, e.g 2.5 would add an absolute margin of 2.5 in the base
          # currency of your item.
          def MarginType.fixed
            @@_fixed ||= MarginType.new('fixed')
          end

          # A percent of the base cost to add, e.g. 1.2 would represent a 1.2% increase.
          def MarginType.percent
            @@_percent ||= MarginType.new('percent')
          end

          def to_hash
            value
          end

        end

        class MeasurementSystem

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of MeasurementSystem for this value, creating a new instance for an unknown value
          def MeasurementSystem.apply(value)
            if value.instance_of?(MeasurementSystem)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || MeasurementSystem.new(value))
            end
          end

          # Returns the instance of MeasurementSystem for this value, or nil if not found
          def MeasurementSystem.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            MeasurementSystem.ALL.find { |v| v.value == value }
          end

          def MeasurementSystem.ALL
            @@all ||= [MeasurementSystem.imperial, MeasurementSystem.metric]
          end

          def MeasurementSystem.imperial
            @@_imperial ||= MeasurementSystem.new('imperial')
          end

          def MeasurementSystem.metric
            @@_metric ||= MeasurementSystem.new('metric')
          end

          def to_hash
            value
          end

        end

        class Method

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Method for this value, creating a new instance for an unknown value
          def Method.apply(value)
            if value.instance_of?(Method)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Method.new(value))
            end
          end

          # Returns the instance of Method for this value, or nil if not found
          def Method.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Method.ALL.find { |v| v.value == value }
          end

          def Method.ALL
            @@all ||= [Method.post]
          end

          def Method.post
            @@_post ||= Method.new('post')
          end

          def to_hash
            value
          end

        end

        class OrderErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderErrorCode for this value, creating a new instance for an unknown value
          def OrderErrorCode.apply(value)
            if value.instance_of?(OrderErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderErrorCode.new(value))
            end
          end

          # Returns the instance of OrderErrorCode for this value, or nil if not found
          def OrderErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderErrorCode.ALL.find { |v| v.value == value }
          end

          def OrderErrorCode.ALL
            @@all ||= [OrderErrorCode.generic_error, OrderErrorCode.order_item_not_available, OrderErrorCode.order_identifier_error]
          end

          def OrderErrorCode.generic_error
            @@_generic_error ||= OrderErrorCode.new('generic_error')
          end

          # When creating an order, if a particular item is not available in the country /
          # destination (either because it was restricted or excluded from that country),
          # we return this error code and list the specific item numbers which are not
          # available in the 'numbers' field.
          def OrderErrorCode.order_item_not_available
            @@_order_item_not_available ||= OrderErrorCode.new('order_item_not_available')
          end

          def OrderErrorCode.order_identifier_error
            @@_order_identifier_error ||= OrderErrorCode.new('order_identifier_error')
          end

          def to_hash
            value
          end

        end

        class OrderPriceDetailComponentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderPriceDetailComponentKey for this value, creating a new instance for an unknown value
          def OrderPriceDetailComponentKey.apply(value)
            if value.instance_of?(OrderPriceDetailComponentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderPriceDetailComponentKey.new(value))
            end
          end

          # Returns the instance of OrderPriceDetailComponentKey for this value, or nil if not found
          def OrderPriceDetailComponentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderPriceDetailComponentKey.ALL.find { |v| v.value == value }
          end

          def OrderPriceDetailComponentKey.ALL
            @@all ||= [OrderPriceDetailComponentKey.adjustment, OrderPriceDetailComponentKey.vat_deminimis, OrderPriceDetailComponentKey.duty_deminimis, OrderPriceDetailComponentKey.duties_item_price, OrderPriceDetailComponentKey.duties_freight, OrderPriceDetailComponentKey.duties_insurance, OrderPriceDetailComponentKey.vat_item_price, OrderPriceDetailComponentKey.vat_freight, OrderPriceDetailComponentKey.vat_insurance, OrderPriceDetailComponentKey.vat_duties_item_price, OrderPriceDetailComponentKey.vat_duties_freight, OrderPriceDetailComponentKey.vat_duties_insurance, OrderPriceDetailComponentKey.item_price, OrderPriceDetailComponentKey.rounding, OrderPriceDetailComponentKey.insurance, OrderPriceDetailComponentKey.shipping, OrderPriceDetailComponentKey.order_discount, OrderPriceDetailComponentKey.subtotal_percent_sales_margin, OrderPriceDetailComponentKey.subtotal_vat_percent_sales_margin, OrderPriceDetailComponentKey.subtotal_duty_percent_sales_margin, OrderPriceDetailComponentKey.vat_subsidy, OrderPriceDetailComponentKey.duty_subsidy]
          end

          # A general purpose adjustment applied to the order.
          def OrderPriceDetailComponentKey.adjustment
            @@_adjustment ||= OrderPriceDetailComponentKey.new('adjustment')
          end

          # An adjustment based on whether the VAT de minimis applies to the order.
          def OrderPriceDetailComponentKey.vat_deminimis
            @@_vat_deminimis ||= OrderPriceDetailComponentKey.new('vat_deminimis')
          end

          # An adjustment based on whether the duty de minimis applies to the order.
          def OrderPriceDetailComponentKey.duty_deminimis
            @@_duty_deminimis ||= OrderPriceDetailComponentKey.new('duty_deminimis')
          end

          # The VAT owed on the price of the order's items, including any added margins
          # and rounding.
          def OrderPriceDetailComponentKey.duties_item_price
            @@_duties_item_price ||= OrderPriceDetailComponentKey.new('duties_item_price')
          end

          # The duty owed on the freight cost of the order.
          def OrderPriceDetailComponentKey.duties_freight
            @@_duties_freight ||= OrderPriceDetailComponentKey.new('duties_freight')
          end

          # The duty owed on the insurance cost of the order.
          def OrderPriceDetailComponentKey.duties_insurance
            @@_duties_insurance ||= OrderPriceDetailComponentKey.new('duties_insurance')
          end

          # The VAT owed on the price of the order's items, including any added margins
          # and rounding.
          def OrderPriceDetailComponentKey.vat_item_price
            @@_vat_item_price ||= OrderPriceDetailComponentKey.new('vat_item_price')
          end

          # The VAT owed on the freight cost of the order.
          def OrderPriceDetailComponentKey.vat_freight
            @@_vat_freight ||= OrderPriceDetailComponentKey.new('vat_freight')
          end

          # The VAT owed on the insurance cost of the order.
          def OrderPriceDetailComponentKey.vat_insurance
            @@_vat_insurance ||= OrderPriceDetailComponentKey.new('vat_insurance')
          end

          # The VAT owed on the duties on the price of the order's items, including any
          # added margins and rounding.
          def OrderPriceDetailComponentKey.vat_duties_item_price
            @@_vat_duties_item_price ||= OrderPriceDetailComponentKey.new('vat_duties_item_price')
          end

          # The VAT owed on the duties on the freight cost of the order.
          def OrderPriceDetailComponentKey.vat_duties_freight
            @@_vat_duties_freight ||= OrderPriceDetailComponentKey.new('vat_duties_freight')
          end

          # The VAT owed on the duties on the insurance cost of the order.
          def OrderPriceDetailComponentKey.vat_duties_insurance
            @@_vat_duties_insurance ||= OrderPriceDetailComponentKey.new('vat_duties_insurance')
          end

          # The sum of the price of the order's items with their currency margins, percent
          # margins, and fixed margins included.
          def OrderPriceDetailComponentKey.item_price
            @@_item_price ||= OrderPriceDetailComponentKey.new('item_price')
          end

          # The sum of any rounding applied to the order's items.
          def OrderPriceDetailComponentKey.rounding
            @@_rounding ||= OrderPriceDetailComponentKey.new('rounding')
          end

          # The insurance cost for the order.
          def OrderPriceDetailComponentKey.insurance
            @@_insurance ||= OrderPriceDetailComponentKey.new('insurance')
          end

          # The shipping cost for the order.
          def OrderPriceDetailComponentKey.shipping
            @@_shipping ||= OrderPriceDetailComponentKey.new('shipping')
          end

          # A discount applied to the entire order.
          def OrderPriceDetailComponentKey.order_discount
            @@_order_discount ||= OrderPriceDetailComponentKey.new('order_discount')
          end

          # The sum of adjustments to item price, margin and rounding made due to
          # percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_percent_sales_margin
            @@_subtotal_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_percent_sales_margin')
          end

          # The sum of adjustments to VAT owed made due to percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_vat_percent_sales_margin
            @@_subtotal_vat_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_vat_percent_sales_margin')
          end

          # The sum of adjustments to duty owed made due to percentage sales margins.
          def OrderPriceDetailComponentKey.subtotal_duty_percent_sales_margin
            @@_subtotal_duty_percent_sales_margin ||= OrderPriceDetailComponentKey.new('subtotal_duty_percent_sales_margin')
          end

          # An offset to account for any VAT subsidized by the organization. For example,
          # if VAT is included in an item price and changes at the order level (due to
          # passing de minimis threshold, or the destination having a more specific VAT
          # rate), the difference will be represented here.
          def OrderPriceDetailComponentKey.vat_subsidy
            @@_vat_subsidy ||= OrderPriceDetailComponentKey.new('vat_subsidy')
          end

          # An offset to account for any duty subsidized by the organization. For example,
          # if duty is included in an item price and changes at the order level (due to
          # passing de minimis threshold, or the destination having a more specific duty
          # rate), the difference will be represented here.
          def OrderPriceDetailComponentKey.duty_subsidy
            @@_duty_subsidy ||= OrderPriceDetailComponentKey.new('duty_subsidy')
          end

          def to_hash
            value
          end

        end

        class OrderPriceDetailKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderPriceDetailKey for this value, creating a new instance for an unknown value
          def OrderPriceDetailKey.apply(value)
            if value.instance_of?(OrderPriceDetailKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderPriceDetailKey.new(value))
            end
          end

          # Returns the instance of OrderPriceDetailKey for this value, or nil if not found
          def OrderPriceDetailKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderPriceDetailKey.ALL.find { |v| v.value == value }
          end

          def OrderPriceDetailKey.ALL
            @@all ||= [OrderPriceDetailKey.adjustment, OrderPriceDetailKey.subtotal, OrderPriceDetailKey.vat, OrderPriceDetailKey.duty, OrderPriceDetailKey.shipping, OrderPriceDetailKey.insurance, OrderPriceDetailKey.discount]
          end

          # The details of any adjustments made to the order.
          def OrderPriceDetailKey.adjustment
            @@_adjustment ||= OrderPriceDetailKey.new('adjustment')
          end

          # The details of the subtotal for the order, including item prices, margins, and
          # rounding.
          def OrderPriceDetailKey.subtotal
            @@_subtotal ||= OrderPriceDetailKey.new('subtotal')
          end

          # The details of any VAT owed on the order.
          def OrderPriceDetailKey.vat
            @@_vat ||= OrderPriceDetailKey.new('vat')
          end

          # The details of any duties owed on the order.
          def OrderPriceDetailKey.duty
            @@_duty ||= OrderPriceDetailKey.new('duty')
          end

          # The details of shipping costs for the order.
          def OrderPriceDetailKey.shipping
            @@_shipping ||= OrderPriceDetailKey.new('shipping')
          end

          # The details of insurance costs for the order.
          def OrderPriceDetailKey.insurance
            @@_insurance ||= OrderPriceDetailKey.new('insurance')
          end

          # The details of any discount applied to the order.
          def OrderPriceDetailKey.discount
            @@_discount ||= OrderPriceDetailKey.new('discount')
          end

          def to_hash
            value
          end

        end

        class OrderStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OrderStatus for this value, creating a new instance for an unknown value
          def OrderStatus.apply(value)
            if value.instance_of?(OrderStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OrderStatus.new(value))
            end
          end

          # Returns the instance of OrderStatus for this value, or nil if not found
          def OrderStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OrderStatus.ALL.find { |v| v.value == value }
          end

          def OrderStatus.ALL
            @@all ||= [OrderStatus.open, OrderStatus.submitted]
          end

          def OrderStatus.open
            @@_open ||= OrderStatus.new('open')
          end

          def OrderStatus.submitted
            @@_submitted ||= OrderStatus.new('submitted')
          end

          def to_hash
            value
          end

        end

        class OutgoingFeedFormat

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of OutgoingFeedFormat for this value, creating a new instance for an unknown value
          def OutgoingFeedFormat.apply(value)
            if value.instance_of?(OutgoingFeedFormat)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || OutgoingFeedFormat.new(value))
            end
          end

          # Returns the instance of OutgoingFeedFormat for this value, or nil if not found
          def OutgoingFeedFormat.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            OutgoingFeedFormat.ALL.find { |v| v.value == value }
          end

          def OutgoingFeedFormat.ALL
            @@all ||= [OutgoingFeedFormat.facebook_xml, OutgoingFeedFormat.google_tsv, OutgoingFeedFormat.google_xml, OutgoingFeedFormat.criteo_xml]
          end

          # Facebook RSS XML product catalog feed
          def OutgoingFeedFormat.facebook_xml
            @@_facebook_xml ||= OutgoingFeedFormat.new('facebook-xml')
          end

          # Google Tab Seperated Values product catalog feed
          def OutgoingFeedFormat.google_tsv
            @@_google_tsv ||= OutgoingFeedFormat.new('google-tsv')
          end

          # Google RSS XML product catalog feed
          def OutgoingFeedFormat.google_xml
            @@_google_xml ||= OutgoingFeedFormat.new('google-xml')
          end

          # Criteo RSS XML product catalog feed
          def OutgoingFeedFormat.criteo_xml
            @@_criteo_xml ||= OutgoingFeedFormat.new('criteo-xml')
          end

          def to_hash
            value
          end

        end

        class PaymentErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentErrorCode for this value, creating a new instance for an unknown value
          def PaymentErrorCode.apply(value)
            if value.instance_of?(PaymentErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentErrorCode.new(value))
            end
          end

          # Returns the instance of PaymentErrorCode for this value, or nil if not found
          def PaymentErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentErrorCode.ALL.find { |v| v.value == value }
          end

          def PaymentErrorCode.ALL
            @@all ||= [PaymentErrorCode.duplicate, PaymentErrorCode.invalid_amount, PaymentErrorCode.invalid_currency, PaymentErrorCode.invalid_method, PaymentErrorCode.invalid_order, PaymentErrorCode.invalid_customer, PaymentErrorCode.invalid_destination, PaymentErrorCode.unknown]
          end

          def PaymentErrorCode.duplicate
            @@_duplicate ||= PaymentErrorCode.new('duplicate')
          end

          # Amount is not valid (e.g. for merchant of record payments, the amount
          # specified must match the order). This typically is handled by refreshing the
          # order amount and reconfirming with the user as something has changed.
          def PaymentErrorCode.invalid_amount
            @@_invalid_amount ||= PaymentErrorCode.new('invalid_amount')
          end

          # Currency is either not known or invalid (e.g. for merchant of record payments,
          # the currency specified must match the order).
          def PaymentErrorCode.invalid_currency
            @@_invalid_currency ||= PaymentErrorCode.new('invalid_currency')
          end

          # Invalid payment method
          def PaymentErrorCode.invalid_method
            @@_invalid_method ||= PaymentErrorCode.new('invalid_method')
          end

          # The specified order number was not found
          def PaymentErrorCode.invalid_order
            @@_invalid_order ||= PaymentErrorCode.new('invalid_order')
          end

          # Customer information is invalid (e.g. email specified but not a valid email)
          def PaymentErrorCode.invalid_customer
            @@_invalid_customer ||= PaymentErrorCode.new('invalid_customer')
          end

          # Destination/shipping address is not valid
          def PaymentErrorCode.invalid_destination
            @@_invalid_destination ||= PaymentErrorCode.new('invalid_destination')
          end

          # Failed due to another reason (details not known)
          def PaymentErrorCode.unknown
            @@_unknown ||= PaymentErrorCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class PaymentMethodType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PaymentMethodType for this value, creating a new instance for an unknown value
          def PaymentMethodType.apply(value)
            if value.instance_of?(PaymentMethodType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PaymentMethodType.new(value))
            end
          end

          # Returns the instance of PaymentMethodType for this value, or nil if not found
          def PaymentMethodType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PaymentMethodType.ALL.find { |v| v.value == value }
          end

          def PaymentMethodType.ALL
            @@all ||= [PaymentMethodType.card, PaymentMethodType.online, PaymentMethodType.offline]
          end

          # Represents all form of card payment (e.g. credit, debit, etc.)
          def PaymentMethodType.card
            @@_card ||= PaymentMethodType.new('card')
          end

          # Represents the most common form of alternative payment methods which require
          # some degree of integration online (e.g. a redirect) to complete payment.
          def PaymentMethodType.online
            @@_online ||= PaymentMethodType.new('online')
          end

          # Offline payment method types represent payments like Cash On Delivery which
          # require offline collection
          def PaymentMethodType.offline
            @@_offline ||= PaymentMethodType.new('offline')
          end

          def to_hash
            value
          end

        end

        class PriceDetailComponentKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceDetailComponentKey for this value, creating a new instance for an unknown value
          def PriceDetailComponentKey.apply(value)
            if value.instance_of?(PriceDetailComponentKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceDetailComponentKey.new(value))
            end
          end

          # Returns the instance of PriceDetailComponentKey for this value, or nil if not found
          def PriceDetailComponentKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceDetailComponentKey.ALL.find { |v| v.value == value }
          end

          def PriceDetailComponentKey.ALL
            @@all ||= [PriceDetailComponentKey.base_price, PriceDetailComponentKey.discount, PriceDetailComponentKey.currency_margin, PriceDetailComponentKey.percent_item_margin, PriceDetailComponentKey.fixed_item_margin, PriceDetailComponentKey.duties_item_price, PriceDetailComponentKey.duties_added_margin, PriceDetailComponentKey.duties_rounding, PriceDetailComponentKey.duties_deminimis, PriceDetailComponentKey.vat_item_price, PriceDetailComponentKey.vat_added_margin, PriceDetailComponentKey.vat_rounding, PriceDetailComponentKey.vat_duties_item_price, PriceDetailComponentKey.vat_duties_added_margin, PriceDetailComponentKey.vat_duties_rounding, PriceDetailComponentKey.vat_deminimis, PriceDetailComponentKey.item_price_percent_sales_margin, PriceDetailComponentKey.margins_percent_sales_margin, PriceDetailComponentKey.rounding_percent_sales_margin, PriceDetailComponentKey.vat_percent_sales_margin, PriceDetailComponentKey.vat_duty_percent_sales_margin, PriceDetailComponentKey.duty_percent_sales_margin]
          end

          # The base price of the item.
          def PriceDetailComponentKey.base_price
            @@_base_price ||= PriceDetailComponentKey.new('base_price')
          end

          # A discount applied to the base price of the item.
          def PriceDetailComponentKey.discount
            @@_discount ||= PriceDetailComponentKey.new('discount')
          end

          # The amount added to the post-discount item price due to FX markup, as
          # configured in the organization's currency settings.
          def PriceDetailComponentKey.currency_margin
            @@_currency_margin ||= PriceDetailComponentKey.new('currency_margin')
          end

          # The amount added to the post-discount item price from a percent item margin.
          # Negative amounts represent discounts.
          def PriceDetailComponentKey.percent_item_margin
            @@_percent_item_margin ||= PriceDetailComponentKey.new('percent_item_margin')
          end

          # The amount added to the post-discount item price from a fixed item margin.
          # Negative amounts represent discounts.
          def PriceDetailComponentKey.fixed_item_margin
            @@_fixed_item_margin ||= PriceDetailComponentKey.new('fixed_item_margin')
          end

          # The duty owed on the post-discount base item price.
          def PriceDetailComponentKey.duties_item_price
            @@_duties_item_price ||= PriceDetailComponentKey.new('duties_item_price')
          end

          # The duty owed on the sum of the currency margin, percent item margin, and
          # fixed item margin.
          def PriceDetailComponentKey.duties_added_margin
            @@_duties_added_margin ||= PriceDetailComponentKey.new('duties_added_margin')
          end

          # The duty owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.duties_rounding
            @@_duties_rounding ||= PriceDetailComponentKey.new('duties_rounding')
          end

          # An adjustment made if the item does not meet the duty de minimis rule.
          def PriceDetailComponentKey.duties_deminimis
            @@_duties_deminimis ||= PriceDetailComponentKey.new('duties_deminimis')
          end

          # The VAT owed on the post-discount base item price.
          def PriceDetailComponentKey.vat_item_price
            @@_vat_item_price ||= PriceDetailComponentKey.new('vat_item_price')
          end

          # The VAT owed on the sum of the currency margin, percent item margin, and fixed
          # item margin.
          def PriceDetailComponentKey.vat_added_margin
            @@_vat_added_margin ||= PriceDetailComponentKey.new('vat_added_margin')
          end

          # The VAT owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.vat_rounding
            @@_vat_rounding ||= PriceDetailComponentKey.new('vat_rounding')
          end

          # The VAT owed on the duty owed on the post-discount base item price.
          def PriceDetailComponentKey.vat_duties_item_price
            @@_vat_duties_item_price ||= PriceDetailComponentKey.new('vat_duties_item_price')
          end

          # The VAT owed on the duty owed on the sum of the currency margin, percent item
          # margin, and fixed item margin.
          def PriceDetailComponentKey.vat_duties_added_margin
            @@_vat_duties_added_margin ||= PriceDetailComponentKey.new('vat_duties_added_margin')
          end

          # The VAT owed on the duty owed on any rounding applied to the total item price.
          def PriceDetailComponentKey.vat_duties_rounding
            @@_vat_duties_rounding ||= PriceDetailComponentKey.new('vat_duties_rounding')
          end

          # An adjustment made if the item does not meet the VAT de minimis rule.
          def PriceDetailComponentKey.vat_deminimis
            @@_vat_deminimis ||= PriceDetailComponentKey.new('vat_deminimis')
          end

          # An adjustment made to the item price as a result of a percent sales margin.
          def PriceDetailComponentKey.item_price_percent_sales_margin
            @@_item_price_percent_sales_margin ||= PriceDetailComponentKey.new('item_price_percent_sales_margin')
          end

          # An adjustment made to the item margins as a result of a percent sales margin.
          def PriceDetailComponentKey.margins_percent_sales_margin
            @@_margins_percent_sales_margin ||= PriceDetailComponentKey.new('margins_percent_sales_margin')
          end

          # An adjustment made to rounding as a result of a percent sales margin.
          def PriceDetailComponentKey.rounding_percent_sales_margin
            @@_rounding_percent_sales_margin ||= PriceDetailComponentKey.new('rounding_percent_sales_margin')
          end

          # An adjustment made to VAT owed as a result of a percent sales margin.
          def PriceDetailComponentKey.vat_percent_sales_margin
            @@_vat_percent_sales_margin ||= PriceDetailComponentKey.new('vat_percent_sales_margin')
          end

          # An adjustment made to VAT on duties (e.g. VAT on duties on item price) owed as
          # a result of a percent sales margin.
          def PriceDetailComponentKey.vat_duty_percent_sales_margin
            @@_vat_duty_percent_sales_margin ||= PriceDetailComponentKey.new('vat_duty_percent_sales_margin')
          end

          # An adjustment made to duty owed as a result of a percent sales margin.
          def PriceDetailComponentKey.duty_percent_sales_margin
            @@_duty_percent_sales_margin ||= PriceDetailComponentKey.new('duty_percent_sales_margin')
          end

          def to_hash
            value
          end

        end

        class PriceDetailKey

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PriceDetailKey for this value, creating a new instance for an unknown value
          def PriceDetailKey.apply(value)
            if value.instance_of?(PriceDetailKey)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PriceDetailKey.new(value))
            end
          end

          # Returns the instance of PriceDetailKey for this value, or nil if not found
          def PriceDetailKey.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PriceDetailKey.ALL.find { |v| v.value == value }
          end

          def PriceDetailKey.ALL
            @@all ||= [PriceDetailKey.item_price, PriceDetailKey.margins, PriceDetailKey.vat, PriceDetailKey.duty, PriceDetailKey.rounding, PriceDetailKey.adjustment]
          end

          # The details of the item price.
          def PriceDetailKey.item_price
            @@_item_price ||= PriceDetailKey.new('item_price')
          end

          # The details of any margins added to the item price.
          def PriceDetailKey.margins
            @@_margins ||= PriceDetailKey.new('margins')
          end

          # The details of any VAT owed on the item.
          def PriceDetailKey.vat
            @@_vat ||= PriceDetailKey.new('vat')
          end

          # The details of any duties owed on the item.
          def PriceDetailKey.duty
            @@_duty ||= PriceDetailKey.new('duty')
          end

          # The details of any rounding added to the item.
          def PriceDetailKey.rounding
            @@_rounding ||= PriceDetailKey.new('rounding')
          end

          # The details of any price adjustments due to sales margins. A negative value
          # indicates a discount.
          def PriceDetailKey.adjustment
            @@_adjustment ||= PriceDetailKey.new('adjustment')
          end

          def to_hash
            value
          end

        end

        class PricingLevySetting

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PricingLevySetting for this value, creating a new instance for an unknown value
          def PricingLevySetting.apply(value)
            if value.instance_of?(PricingLevySetting)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PricingLevySetting.new(value))
            end
          end

          # Returns the instance of PricingLevySetting for this value, or nil if not found
          def PricingLevySetting.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PricingLevySetting.ALL.find { |v| v.value == value }
          end

          def PricingLevySetting.ALL
            @@all ||= [PricingLevySetting.included, PricingLevySetting.displayed, PricingLevySetting.ignored]
          end

          def PricingLevySetting.included
            @@_included ||= PricingLevySetting.new('included')
          end

          def PricingLevySetting.displayed
            @@_displayed ||= PricingLevySetting.new('displayed')
          end

          def PricingLevySetting.ignored
            @@_ignored ||= PricingLevySetting.new('ignored')
          end

          def to_hash
            value
          end

        end

        class PromotionTriggerType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of PromotionTriggerType for this value, creating a new instance for an unknown value
          def PromotionTriggerType.apply(value)
            if value.instance_of?(PromotionTriggerType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || PromotionTriggerType.new(value))
            end
          end

          # Returns the instance of PromotionTriggerType for this value, or nil if not found
          def PromotionTriggerType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            PromotionTriggerType.ALL.find { |v| v.value == value }
          end

          def PromotionTriggerType.ALL
            @@all ||= [PromotionTriggerType.order_subtotal]
          end

          def PromotionTriggerType.order_subtotal
            @@_order_subtotal ||= PromotionTriggerType.new('order_subtotal')
          end

          def to_hash
            value
          end

        end

        class ProvinceType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ProvinceType for this value, creating a new instance for an unknown value
          def ProvinceType.apply(value)
            if value.instance_of?(ProvinceType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ProvinceType.new(value))
            end
          end

          # Returns the instance of ProvinceType for this value, or nil if not found
          def ProvinceType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ProvinceType.ALL.find { |v| v.value == value }
          end

          def ProvinceType.ALL
            @@all ||= [ProvinceType.city, ProvinceType.dependency, ProvinceType.district, ProvinceType.emirate, ProvinceType.entity, ProvinceType.municipality, ProvinceType.outlying_area, ProvinceType.parish, ProvinceType.province, ProvinceType.state, ProvinceType.territory, ProvinceType.other]
          end

          def ProvinceType.city
            @@_city ||= ProvinceType.new('city')
          end

          def ProvinceType.dependency
            @@_dependency ||= ProvinceType.new('dependency')
          end

          def ProvinceType.district
            @@_district ||= ProvinceType.new('district')
          end

          def ProvinceType.emirate
            @@_emirate ||= ProvinceType.new('emirate')
          end

          def ProvinceType.entity
            @@_entity ||= ProvinceType.new('entity')
          end

          def ProvinceType.municipality
            @@_municipality ||= ProvinceType.new('municipality')
          end

          def ProvinceType.outlying_area
            @@_outlying_area ||= ProvinceType.new('outlying_area')
          end

          def ProvinceType.parish
            @@_parish ||= ProvinceType.new('parish')
          end

          def ProvinceType.province
            @@_province ||= ProvinceType.new('province')
          end

          def ProvinceType.state
            @@_state ||= ProvinceType.new('state')
          end

          def ProvinceType.territory
            @@_territory ||= ProvinceType.new('territory')
          end

          def ProvinceType.other
            @@_other ||= ProvinceType.new('other')
          end

          def to_hash
            value
          end

        end

        class QueryType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QueryType for this value, creating a new instance for an unknown value
          def QueryType.apply(value)
            if value.instance_of?(QueryType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QueryType.new(value))
            end
          end

          # Returns the instance of QueryType for this value, or nil if not found
          def QueryType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QueryType.ALL.find { |v| v.value == value }
          end

          def QueryType.ALL
            @@all ||= [QueryType.exclusion, QueryType.inclusion]
          end

          # Exclude items satisfied by the associated query
          def QueryType.exclusion
            @@_exclusion ||= QueryType.new('exclusion')
          end

          # Include items satisfied by the associated query
          def QueryType.inclusion
            @@_inclusion ||= QueryType.new('inclusion')
          end

          def to_hash
            value
          end

        end

        class QuoteErrorCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of QuoteErrorCode for this value, creating a new instance for an unknown value
          def QuoteErrorCode.apply(value)
            if value.instance_of?(QuoteErrorCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || QuoteErrorCode.new(value))
            end
          end

          # Returns the instance of QuoteErrorCode for this value, or nil if not found
          def QuoteErrorCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            QuoteErrorCode.ALL.find { |v| v.value == value }
          end

          def QuoteErrorCode.ALL
            @@all ||= [QuoteErrorCode.generic_error, QuoteErrorCode.items_not_available]
          end

          def QuoteErrorCode.generic_error
            @@_generic_error ||= QuoteErrorCode.new('generic_error')
          end

          # Item numbers are not available in inventory
          def QuoteErrorCode.items_not_available
            @@_items_not_available ||= QuoteErrorCode.new('items_not_available')
          end

          def to_hash
            value
          end

        end

        class RefundDeclineCode

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RefundDeclineCode for this value, creating a new instance for an unknown value
          def RefundDeclineCode.apply(value)
            if value.instance_of?(RefundDeclineCode)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RefundDeclineCode.new(value))
            end
          end

          # Returns the instance of RefundDeclineCode for this value, or nil if not found
          def RefundDeclineCode.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RefundDeclineCode.ALL.find { |v| v.value == value }
          end

          def RefundDeclineCode.ALL
            @@all ||= [RefundDeclineCode.expired, RefundDeclineCode.insufficient_funds, RefundDeclineCode.unknown]
          end

          # All associated payment captures have expired; refunds can no longer be issued
          def RefundDeclineCode.expired
            @@_expired ||= RefundDeclineCode.new('expired')
          end

          # The requested refund amount exceeded the amount of remaining unrefunded funds
          def RefundDeclineCode.insufficient_funds
            @@_insufficient_funds ||= RefundDeclineCode.new('insufficient_funds')
          end

          # Failed due to another reason (details not known)
          def RefundDeclineCode.unknown
            @@_unknown ||= RefundDeclineCode.new('unknown')
          end

          def to_hash
            value
          end

        end

        class ReturnStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ReturnStatus for this value, creating a new instance for an unknown value
          def ReturnStatus.apply(value)
            if value.instance_of?(ReturnStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ReturnStatus.new(value))
            end
          end

          # Returns the instance of ReturnStatus for this value, or nil if not found
          def ReturnStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ReturnStatus.ALL.find { |v| v.value == value }
          end

          def ReturnStatus.ALL
            @@all ||= [ReturnStatus.open, ReturnStatus.refunded]
          end

          def ReturnStatus.open
            @@_open ||= ReturnStatus.new('open')
          end

          def ReturnStatus.refunded
            @@_refunded ||= ReturnStatus.new('refunded')
          end

          def to_hash
            value
          end

        end

        class Role

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Role for this value, creating a new instance for an unknown value
          def Role.apply(value)
            if value.instance_of?(Role)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Role.new(value))
            end
          end

          # Returns the instance of Role for this value, or nil if not found
          def Role.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Role.ALL.find { |v| v.value == value }
          end

          def Role.ALL
            @@all ||= [Role.admin, Role.member]
          end

          def Role.admin
            @@_admin ||= Role.new('admin')
          end

          def Role.member
            @@_member ||= Role.new('member')
          end

          def to_hash
            value
          end

        end

        class RoundingMethod

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingMethod for this value, creating a new instance for an unknown value
          def RoundingMethod.apply(value)
            if value.instance_of?(RoundingMethod)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingMethod.new(value))
            end
          end

          # Returns the instance of RoundingMethod for this value, or nil if not found
          def RoundingMethod.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingMethod.ALL.find { |v| v.value == value }
          end

          def RoundingMethod.ALL
            @@all ||= [RoundingMethod.up, RoundingMethod.down, RoundingMethod.nearest]
          end

          # Round up to the specified rounding.value
          def RoundingMethod.up
            @@_up ||= RoundingMethod.new('up')
          end

          # Round down to the specified rounding.value
          def RoundingMethod.down
            @@_down ||= RoundingMethod.new('down')
          end

          # Round to the nearest specified rounding.value. If equidistant, will round up.
          def RoundingMethod.nearest
            @@_nearest ||= RoundingMethod.new('nearest')
          end

          def to_hash
            value
          end

        end

        class RoundingType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of RoundingType for this value, creating a new instance for an unknown value
          def RoundingType.apply(value)
            if value.instance_of?(RoundingType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || RoundingType.new(value))
            end
          end

          # Returns the instance of RoundingType for this value, or nil if not found
          def RoundingType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            RoundingType.ALL.find { |v| v.value == value }
          end

          def RoundingType.ALL
            @@all ||= [RoundingType.pattern, RoundingType.multiple]
          end

          # Rounds a value to an amount ending with a pattern, e.g. an amount ending in
          # '.99'.
          def RoundingType.pattern
            @@_pattern ||= RoundingType.new('pattern')
          end

          # Rounds a value to an amount that is the multiple of a value, e.g. rounding to
          # the nearest 5 would ensure that the resulting number ends in either 0 or 5.
          def RoundingType.multiple
            @@_multiple ||= RoundingType.new('multiple')
          end

          def to_hash
            value
          end

        end

        class ScheduleExceptionStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ScheduleExceptionStatus for this value, creating a new instance for an unknown value
          def ScheduleExceptionStatus.apply(value)
            if value.instance_of?(ScheduleExceptionStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ScheduleExceptionStatus.new(value))
            end
          end

          # Returns the instance of ScheduleExceptionStatus for this value, or nil if not found
          def ScheduleExceptionStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ScheduleExceptionStatus.ALL.find { |v| v.value == value }
          end

          def ScheduleExceptionStatus.ALL
            @@all ||= [ScheduleExceptionStatus.open, ScheduleExceptionStatus.closed]
          end

          def ScheduleExceptionStatus.open
            @@_open ||= ScheduleExceptionStatus.new('Open')
          end

          def ScheduleExceptionStatus.closed
            @@_closed ||= ScheduleExceptionStatus.new('Closed')
          end

          def to_hash
            value
          end

        end

        class ShipmentIntegrationType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ShipmentIntegrationType for this value, creating a new instance for an unknown value
          def ShipmentIntegrationType.apply(value)
            if value.instance_of?(ShipmentIntegrationType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ShipmentIntegrationType.new(value))
            end
          end

          # Returns the instance of ShipmentIntegrationType for this value, or nil if not found
          def ShipmentIntegrationType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ShipmentIntegrationType.ALL.find { |v| v.value == value }
          end

          def ShipmentIntegrationType.ALL
            @@all ||= [ShipmentIntegrationType.direct, ShipmentIntegrationType.information, ShipmentIntegrationType.preadvice]
          end

          # Always generate a label for the chosen delivery option.
          def ShipmentIntegrationType.direct
            @@_direct ||= ShipmentIntegrationType.new('direct')
          end

          # Booking and label generation is not available. Just use Flow to calculate
          # delivery window estimates and shipment prices to display.
          def ShipmentIntegrationType.information
            @@_information ||= ShipmentIntegrationType.new('information')
          end

          # A generic label will be provided by the client organization when available as
          # pre-advice shipment notification to carrier partner.
          def ShipmentIntegrationType.preadvice
            @@_preadvice ||= ShipmentIntegrationType.new('preadvice')
          end

          def to_hash
            value
          end

        end

        class SortDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SortDirection for this value, creating a new instance for an unknown value
          def SortDirection.apply(value)
            if value.instance_of?(SortDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SortDirection.new(value))
            end
          end

          # Returns the instance of SortDirection for this value, or nil if not found
          def SortDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SortDirection.ALL.find { |v| v.value == value }
          end

          def SortDirection.ALL
            @@all ||= [SortDirection.ascending, SortDirection.descending]
          end

          def SortDirection.ascending
            @@_ascending ||= SortDirection.new('ascending')
          end

          def SortDirection.descending
            @@_descending ||= SortDirection.new('descending')
          end

          def to_hash
            value
          end

        end

        class Strategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Strategy for this value, creating a new instance for an unknown value
          def Strategy.apply(value)
            if value.instance_of?(Strategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Strategy.new(value))
            end
          end

          # Returns the instance of Strategy for this value, or nil if not found
          def Strategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Strategy.ALL.find { |v| v.value == value }
          end

          def Strategy.ALL
            @@all ||= [Strategy.range, Strategy.from, Strategy.to]
          end

          # Tightest range
          def Strategy.range
            @@_range ||= Strategy.new('range')
          end

          # Lowest minimum of the ranges
          def Strategy.from
            @@_from ||= Strategy.new('from')
          end

          # Lowest maximum of the ranges
          def Strategy.to
            @@_to ||= Strategy.new('to')
          end

          def to_hash
            value
          end

        end

        class SubcatalogItemStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of SubcatalogItemStatus for this value, creating a new instance for an unknown value
          def SubcatalogItemStatus.apply(value)
            if value.instance_of?(SubcatalogItemStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || SubcatalogItemStatus.new(value))
            end
          end

          # Returns the instance of SubcatalogItemStatus for this value, or nil if not found
          def SubcatalogItemStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            SubcatalogItemStatus.ALL.find { |v| v.value == value }
          end

          def SubcatalogItemStatus.ALL
            @@all ||= [SubcatalogItemStatus.excluded, SubcatalogItemStatus.included, SubcatalogItemStatus.restricted]
          end

          # Item is excluded based on targeting query.  This is separate from an item
          # marked as restricted.
          def SubcatalogItemStatus.excluded
            @@_excluded ||= SubcatalogItemStatus.new('excluded')
          end

          # Item is included
          def SubcatalogItemStatus.included
            @@_included ||= SubcatalogItemStatus.new('included')
          end

          # Item is restricted and will be treated as excluded
          def SubcatalogItemStatus.restricted
            @@_restricted ||= SubcatalogItemStatus.new('restricted')
          end

          def to_hash
            value
          end

        end

        class TierDirection

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierDirection for this value, creating a new instance for an unknown value
          def TierDirection.apply(value)
            if value.instance_of?(TierDirection)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierDirection.new(value))
            end
          end

          # Returns the instance of TierDirection for this value, or nil if not found
          def TierDirection.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierDirection.ALL.find { |v| v.value == value }
          end

          def TierDirection.ALL
            @@all ||= [TierDirection.outbound, TierDirection.return]
          end

          def TierDirection.outbound
            @@_outbound ||= TierDirection.new('outbound')
          end

          def TierDirection.return
            @@_return ||= TierDirection.new('return')
          end

          def to_hash
            value
          end

        end

        class TierStrategy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TierStrategy for this value, creating a new instance for an unknown value
          def TierStrategy.apply(value)
            if value.instance_of?(TierStrategy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TierStrategy.new(value))
            end
          end

          # Returns the instance of TierStrategy for this value, or nil if not found
          def TierStrategy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TierStrategy.ALL.find { |v| v.value == value }
          end

          def TierStrategy.ALL
            @@all ||= [TierStrategy.fastest, TierStrategy.lowest_cost]
          end

          # Optimize for fastest first, then cheapest
          def TierStrategy.fastest
            @@_fastest ||= TierStrategy.new('fastest')
          end

          # Optimize for lowest cost first, then fastest
          def TierStrategy.lowest_cost
            @@_lowest_cost ||= TierStrategy.new('lowest_cost')
          end

          def to_hash
            value
          end

        end

        class TrackingStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of TrackingStatus for this value, creating a new instance for an unknown value
          def TrackingStatus.apply(value)
            if value.instance_of?(TrackingStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || TrackingStatus.new(value))
            end
          end

          # Returns the instance of TrackingStatus for this value, or nil if not found
          def TrackingStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            TrackingStatus.ALL.find { |v| v.value == value }
          end

          def TrackingStatus.ALL
            @@all ||= [TrackingStatus.label_created, TrackingStatus.pending, TrackingStatus.info_received, TrackingStatus.in_transit, TrackingStatus.out_for_delivery, TrackingStatus.attempt_fail, TrackingStatus.delivered, TrackingStatus.exception, TrackingStatus.expired]
          end

          def TrackingStatus.label_created
            @@_label_created ||= TrackingStatus.new('label_created')
          end

          def TrackingStatus.pending
            @@_pending ||= TrackingStatus.new('pending')
          end

          def TrackingStatus.info_received
            @@_info_received ||= TrackingStatus.new('info_received')
          end

          def TrackingStatus.in_transit
            @@_in_transit ||= TrackingStatus.new('in_transit')
          end

          def TrackingStatus.out_for_delivery
            @@_out_for_delivery ||= TrackingStatus.new('out_for_delivery')
          end

          def TrackingStatus.attempt_fail
            @@_attempt_fail ||= TrackingStatus.new('attempt_fail')
          end

          def TrackingStatus.delivered
            @@_delivered ||= TrackingStatus.new('delivered')
          end

          def TrackingStatus.exception
            @@_exception ||= TrackingStatus.new('exception')
          end

          def TrackingStatus.expired
            @@_expired ||= TrackingStatus.new('expired')
          end

          def to_hash
            value
          end

        end

        class UnitOfMeasurement

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfMeasurement for this value, creating a new instance for an unknown value
          def UnitOfMeasurement.apply(value)
            if value.instance_of?(UnitOfMeasurement)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfMeasurement.new(value))
            end
          end

          # Returns the instance of UnitOfMeasurement for this value, or nil if not found
          def UnitOfMeasurement.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfMeasurement.ALL.find { |v| v.value == value }
          end

          def UnitOfMeasurement.ALL
            @@all ||= [UnitOfMeasurement.millimeter, UnitOfMeasurement.centimeter, UnitOfMeasurement.inch, UnitOfMeasurement.foot, UnitOfMeasurement.cubic_inch, UnitOfMeasurement.cubic_meter, UnitOfMeasurement.gram, UnitOfMeasurement.kilogram, UnitOfMeasurement.meter, UnitOfMeasurement.ounce, UnitOfMeasurement.pound]
          end

          # Equivalent to MILLI(METRE).
          def UnitOfMeasurement.millimeter
            @@_millimeter ||= UnitOfMeasurement.new('millimeter')
          end

          # Equivalent to CENTI(METRE).
          def UnitOfMeasurement.centimeter
            @@_centimeter ||= UnitOfMeasurement.new('centimeter')
          end

          # A unit of length equal to 0.01004 m (standard name in).
          def UnitOfMeasurement.inch
            @@_inch ||= UnitOfMeasurement.new('inch')
          end

          # A unit of length equal to 0.3048 m (standard name ft).
          def UnitOfMeasurement.foot
            @@_foot ||= UnitOfMeasurement.new('foot')
          end

          # A unit of volume equal to one cubic inch (in³).
          def UnitOfMeasurement.cubic_inch
            @@_cubic_inch ||= UnitOfMeasurement.new('cubic_inch')
          end

          # The metric unit for volume quantities (m³).
          def UnitOfMeasurement.cubic_meter
            @@_cubic_meter ||= UnitOfMeasurement.new('cubic_meter')
          end

          # A unit of mass equal to 1 / 1000 kilogram (standard name g).
          def UnitOfMeasurement.gram
            @@_gram ||= UnitOfMeasurement.new('gram')
          end

          # The base unit for mass quantities (kg).
          def UnitOfMeasurement.kilogram
            @@_kilogram ||= UnitOfMeasurement.new('kilogram')
          end

          # The base unit for length quantities (m).
          def UnitOfMeasurement.meter
            @@_meter ||= UnitOfMeasurement.new('meter')
          end

          # A unit of mass equal to 1 / 16 POUND (standard name oz).
          def UnitOfMeasurement.ounce
            @@_ounce ||= UnitOfMeasurement.new('ounce')
          end

          # A unit of mass equal to 453.59237 grams (avoirdupois pound, standard name lb).
          def UnitOfMeasurement.pound
            @@_pound ||= UnitOfMeasurement.new('pound')
          end

          def to_hash
            value
          end

        end

        class UnitOfTime

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UnitOfTime for this value, creating a new instance for an unknown value
          def UnitOfTime.apply(value)
            if value.instance_of?(UnitOfTime)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UnitOfTime.new(value))
            end
          end

          # Returns the instance of UnitOfTime for this value, or nil if not found
          def UnitOfTime.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UnitOfTime.ALL.find { |v| v.value == value }
          end

          def UnitOfTime.ALL
            @@all ||= [UnitOfTime.year, UnitOfTime.month, UnitOfTime.week, UnitOfTime.day, UnitOfTime.hour, UnitOfTime.minute]
          end

          def UnitOfTime.year
            @@_year ||= UnitOfTime.new('year')
          end

          def UnitOfTime.month
            @@_month ||= UnitOfTime.new('month')
          end

          def UnitOfTime.week
            @@_week ||= UnitOfTime.new('week')
          end

          def UnitOfTime.day
            @@_day ||= UnitOfTime.new('day')
          end

          def UnitOfTime.hour
            @@_hour ||= UnitOfTime.new('hour')
          end

          def UnitOfTime.minute
            @@_minute ||= UnitOfTime.new('minute')
          end

          def to_hash
            value
          end

        end

        class UpdatePolicy

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdatePolicy for this value, creating a new instance for an unknown value
          def UpdatePolicy.apply(value)
            if value.instance_of?(UpdatePolicy)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdatePolicy.new(value))
            end
          end

          # Returns the instance of UpdatePolicy for this value, or nil if not found
          def UpdatePolicy.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdatePolicy.ALL.find { |v| v.value == value }
          end

          def UpdatePolicy.ALL
            @@all ||= [UpdatePolicy.auto, UpdatePolicy.queue, UpdatePolicy.discard]
          end

          def UpdatePolicy.auto
            @@_auto ||= UpdatePolicy.new('auto')
          end

          # Queue item update for approval.
          def UpdatePolicy.queue
            @@_queue ||= UpdatePolicy.new('queue')
          end

          def UpdatePolicy.discard
            @@_discard ||= UpdatePolicy.new('discard')
          end

          def to_hash
            value
          end

        end

        class UpdateType

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UpdateType for this value, creating a new instance for an unknown value
          def UpdateType.apply(value)
            if value.instance_of?(UpdateType)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UpdateType.new(value))
            end
          end

          # Returns the instance of UpdateType for this value, or nil if not found
          def UpdateType.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UpdateType.ALL.find { |v| v.value == value }
          end

          def UpdateType.ALL
            @@all ||= [UpdateType.change, UpdateType.set]
          end

          # Long value to increment or decrement. Positive quantities are added to
          # inventory while negative quantities are decrement from inventory.
          def UpdateType.change
            @@_change ||= UpdateType.new('change')
          end

          # Set aboluste quantity to new value with no regard for previous updates
          def UpdateType.set
            @@_set ||= UpdateType.new('set')
          end

          def to_hash
            value
          end

        end

        class UserStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of UserStatus for this value, creating a new instance for an unknown value
          def UserStatus.apply(value)
            if value.instance_of?(UserStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || UserStatus.new(value))
            end
          end

          # Returns the instance of UserStatus for this value, or nil if not found
          def UserStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            UserStatus.ALL.find { |v| v.value == value }
          end

          def UserStatus.ALL
            @@all ||= [UserStatus.pending, UserStatus.active, UserStatus.inactive]
          end

          # Represents a new user account that is pending approval
          def UserStatus.pending
            @@_pending ||= UserStatus.new('pending')
          end

          # Represents an active user account - can authenticate with this account
          def UserStatus.active
            @@_active ||= UserStatus.new('active')
          end

          # Represents an inactive user account - can no longer authenticate with this
          # account
          def UserStatus.inactive
            @@_inactive ||= UserStatus.new('inactive')
          end

          def to_hash
            value
          end

        end

        class ValueAddedService

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of ValueAddedService for this value, creating a new instance for an unknown value
          def ValueAddedService.apply(value)
            if value.instance_of?(ValueAddedService)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || ValueAddedService.new(value))
            end
          end

          # Returns the instance of ValueAddedService for this value, or nil if not found
          def ValueAddedService.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            ValueAddedService.ALL.find { |v| v.value == value }
          end

          def ValueAddedService.ALL
            @@all ||= [ValueAddedService.hazardous_material]
          end

          # See https://en.wikipedia.org/wiki/ORM-D
          def ValueAddedService.hazardous_material
            @@_hazardous_material ||= ValueAddedService.new('Hazardous Material')
          end

          def to_hash
            value
          end

        end

        class Visibility

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of Visibility for this value, creating a new instance for an unknown value
          def Visibility.apply(value)
            if value.instance_of?(Visibility)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || Visibility.new(value))
            end
          end

          # Returns the instance of Visibility for this value, or nil if not found
          def Visibility.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            Visibility.ALL.find { |v| v.value == value }
          end

          def Visibility.ALL
            @@all ||= [Visibility.public, Visibility.private]
          end

          def Visibility.public
            @@_public ||= Visibility.new('public')
          end

          def Visibility.private
            @@_private ||= Visibility.new('private')
          end

          def to_hash
            value
          end

        end

        class WebhookStatus

          attr_reader :value

          def initialize(value)
            @value = HttpClient::Preconditions.assert_class('value', value, String)
          end

          # Returns the instance of WebhookStatus for this value, creating a new instance for an unknown value
          def WebhookStatus.apply(value)
            if value.instance_of?(WebhookStatus)
              value
            else
              HttpClient::Preconditions.assert_class_or_nil('value', value, String)
              value.nil? ? nil : (from_string(value) || WebhookStatus.new(value))
            end
          end

          # Returns the instance of WebhookStatus for this value, or nil if not found
          def WebhookStatus.from_string(value)
            HttpClient::Preconditions.assert_class('value', value, String)
            WebhookStatus.ALL.find { |v| v.value == value }
          end

          def WebhookStatus.ALL
            @@all ||= [WebhookStatus.pending, WebhookStatus.success, WebhookStatus.failure]
          end

          def WebhookStatus.pending
            @@_pending ||= WebhookStatus.new('pending')
          end

          def WebhookStatus.success
            @@_success ||= WebhookStatus.new('success')
          end

          def WebhookStatus.failure
            @@_failure ||= WebhookStatus.new('failure')
          end

          def to_hash
            value
          end

        end

        class AccountOrdersExportType < ExportType

          attr_reader :statement_id, :transaction_summary_id, :transaction_posted_from, :transaction_posted_to, :transaction_posted_on_or_after, :transaction_posted_after, :transaction_posted_on_or_before, :transaction_posted_before

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ACCOUNT_ORDERS_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @statement_id = (x = opts.delete(:statement_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('statement_id', x, String))
            @transaction_summary_id = (x = opts.delete(:transaction_summary_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_summary_id', x, String))
            @transaction_posted_from = (x = opts.delete(:transaction_posted_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_posted_to = (x = opts.delete(:transaction_posted_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @transaction_posted_on_or_after = (x = opts.delete(:transaction_posted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_after = (x = opts.delete(:transaction_posted_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_on_or_before = (x = opts.delete(:transaction_posted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @transaction_posted_before = (x = opts.delete(:transaction_posted_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_posted_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AccountOrdersExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :statement_id => statement_id,
              :transaction_summary_id => transaction_summary_id,
              :transaction_posted_from => transaction_posted_from,
              :transaction_posted_to => transaction_posted_to,
              :transaction_posted_on_or_after => transaction_posted_on_or_after,
              :transaction_posted_after => transaction_posted_after,
              :transaction_posted_on_or_before => transaction_posted_on_or_before,
              :transaction_posted_before => transaction_posted_before
            }
          end

        end

        class AccountTransactionsExportType < ExportType

          attr_reader :statement_id, :transaction_summary_id, :posted_from, :posted_to, :posted_on_or_after, :posted_after, :posted_on_or_before, :posted_before

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ACCOUNT_TRANSACTIONS_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @statement_id = (x = opts.delete(:statement_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('statement_id', x, String))
            @transaction_summary_id = (x = opts.delete(:transaction_summary_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('transaction_summary_id', x, String))
            @posted_from = (x = opts.delete(:posted_from); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_from', HttpClient::Helper.to_date_iso8601(x), Date))
            @posted_to = (x = opts.delete(:posted_to); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_to', HttpClient::Helper.to_date_iso8601(x), Date))
            @posted_on_or_after = (x = opts.delete(:posted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_after = (x = opts.delete(:posted_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_on_or_before = (x = opts.delete(:posted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @posted_before = (x = opts.delete(:posted_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('posted_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AccountTransactionsExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :statement_id => statement_id,
              :transaction_summary_id => transaction_summary_id,
              :posted_from => posted_from,
              :posted_to => posted_to,
              :posted_on_or_after => posted_on_or_after,
              :posted_after => posted_after,
              :posted_on_or_before => posted_on_or_before,
              :posted_before => posted_before
            }
          end

        end

        # Defines structured fields for address to be used in user/form input. Either
        # text or the structured input needs to be present.
        class Address

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Address.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude
            }
          end

        end

        # A suggested address (usually providing more accurate information). This object
        # contains both the suggested address as well as metadata on which fields are
        # actually different
        class AddressSuggestion

          attr_reader :address, :streets, :city, :province, :postal, :country

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :streets, :city, :province, :postal, :country], 'AddressSuggestion')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @streets = HttpClient::Preconditions.assert_boolean('streets', opts.delete(:streets))
            @city = HttpClient::Preconditions.assert_boolean('city', opts.delete(:city))
            @province = HttpClient::Preconditions.assert_boolean('province', opts.delete(:province))
            @postal = HttpClient::Preconditions.assert_boolean('postal', opts.delete(:postal))
            @country = HttpClient::Preconditions.assert_boolean('country', opts.delete(:country))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressSuggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :streets => streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country
            }
          end

        end

        # Address verification returns information on whether or not an address is valid
        # and deliverable - meaning carriers will accept this address. Also returns
        # suggestions for address correction, including data to highlight specific
        # fields to correct.
        class AddressVerification

          attr_reader :address, :valid, :suggestions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :valid], 'AddressVerification')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @valid = HttpClient::Preconditions.assert_boolean('valid', opts.delete(:valid))
            @suggestions = HttpClient::Preconditions.assert_class('suggestions', (x = opts.delete(:suggestions); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AddressSuggestion) ? x : ::Io::Flow::V0::Models::AddressSuggestion.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AddressVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :valid => valid,
              :suggestions => suggestions.map { |o| o.to_hash }
            }
          end

        end

        class AdjustmentReason

          attr_reader :key, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :label], 'AdjustmentReason')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::AdjustmentReasonKey) ? x : ::Io::Flow::V0::Models::AdjustmentReasonKey.apply(x))
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AdjustmentReason.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :label => label
            }
          end

        end

        class Allocation

          attr_reader :order, :details

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :details], 'Allocation')
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @details = HttpClient::Preconditions.assert_class('details', opts.delete(:details), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationDetail) ? x : ::Io::Flow::V0::Models::AllocationDetail.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Allocation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order.to_hash,
              :details => details.map { |o| o.to_hash }
            }
          end

        end

        class AllocationDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ALLOCATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'AllocationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # Represents any component that is not VAT or duty, such as item price,
        # rounding, shipping, etc.
        class AllocationDetailComponent < AllocationComponent

          attr_reader :key, :total

          def initialize(incoming={})
            super(:discriminator => AllocationComponent::Types::ALLOCATION_DETAIL_COMPONENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total], 'AllocationDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationDetailComponent.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash
            }
          end

        end

        # Represents either a VAT or duty component.
        class AllocationLevyComponent < AllocationComponent

          attr_reader :key, :total, :rate, :name

          def initialize(incoming={})
            super(:discriminator => AllocationComponent::Types::ALLOCATION_LEVY_COMPONENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total, :rate, :name], 'AllocationLevyComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationLevyComponent.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash,
              :rate => rate,
              :name => name
            }
          end

        end

        class AllocationLineDetail < AllocationDetail

          attr_reader :number, :quantity, :key, :price, :total, :included, :not_included

          def initialize(incoming={})
            super(:discriminator => AllocationDetail::Types::ALLOCATION_LINE_DETAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :key, :price, :total, :included, :not_included], 'AllocationLineDetail')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @included = HttpClient::Preconditions.assert_class('included', opts.delete(:included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
            @not_included = HttpClient::Preconditions.assert_class('not_included', opts.delete(:not_included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationLineDetail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :quantity => quantity,
              :key => key.value,
              :price => price.to_hash,
              :total => total.to_hash,
              :included => included.map { |o| o.to_hash },
              :not_included => not_included.map { |o| o.to_hash }
            }
          end

        end

        # Represents an order-specific detail such as shipping, insurance, or an
        # order-level discount.
        class AllocationOrderDetail < AllocationDetail

          attr_reader :key, :total, :included, :not_included

          def initialize(incoming={})
            super(:discriminator => AllocationDetail::Types::ALLOCATION_ORDER_DETAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :total, :included, :not_included], 'AllocationOrderDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @included = HttpClient::Preconditions.assert_class('included', opts.delete(:included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
            @not_included = HttpClient::Preconditions.assert_class('not_included', opts.delete(:not_included), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AllocationComponent) ? x : ::Io::Flow::V0::Models::AllocationComponent.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationOrderDetail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key.value,
              :total => total.to_hash,
              :included => included.map { |o| o.to_hash },
              :not_included => not_included.map { |o| o.to_hash }
            }
          end

        end

        class AllocationUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :order_id, :order_number, :details

          def initialize(incoming={})
            super(:discriminator => Event::Types::ALLOCATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :order_id, :order_number, :details], 'AllocationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @order_id = HttpClient::Preconditions.assert_class('order_id', opts.delete(:order_id), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @details = HttpClient::Preconditions.assert_class('details', opts.delete(:details), Array).map { |v| HttpClient::Preconditions.assert_class('details', HttpClient::Helper.to_object(v), Hash) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AllocationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :order_id => order_id,
              :order_number => order_number,
              :details => details
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin price
        class AmountMargin < TierRuleOutcome

          attr_reader :margin

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::AMOUNT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:margin], 'AmountMargin')
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :margin => margin.to_hash
            }
          end

        end

        class AmountMarginForm < TierRuleOutcomeForm

          attr_reader :margin

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcomeForm::Types::AMOUNT_MARGIN_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:margin], 'AmountMarginForm')
            @margin = (x = opts.delete(:margin); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AmountMarginForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :margin => margin.to_hash
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost of the service
        class AtCost < TierRuleOutcome

          attr_reader :ignore

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::AT_COST)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ignore = (x = opts.delete(:ignore); x.nil? ? nil : HttpClient::Preconditions.assert_class('ignore', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AtCost.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :ignore => ignore
            }
          end

        end

        # An attribute can be configured to be used in different ways throughout Flow. A
        # common example is to identify a meaningful attribute (e.g. brand) that can
        # then be displayed throughout the Flow console.
        class Attribute

          attr_reader :id, :key, :options, :label, :intent, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :options], 'Attribute')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
            @intent = (x = opts.delete(:intent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeIntent) ? x : ::Io::Flow::V0::Models::AttributeIntent.apply(x)))
            @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeDataType) ? x : ::Io::Flow::V0::Models::AttributeDataType.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :options => options.to_hash,
              :label => label,
              :intent => intent.nil? ? nil : intent.value,
              :type => type.nil? ? nil : type.value
            }
          end

        end

        class AttributeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key], 'AttributeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key
            }
          end

        end

        class AttributeForm

          attr_reader :key, :options, :label, :intent, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :options], 'AttributeForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @options = (x = opts.delete(:options); x.is_a?(::Io::Flow::V0::Models::Options) ? x : ::Io::Flow::V0::Models::Options.new(x))
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
            @intent = (x = opts.delete(:intent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeIntent) ? x : ::Io::Flow::V0::Models::AttributeIntent.apply(x)))
            @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AttributeDataType) ? x : ::Io::Flow::V0::Models::AttributeDataType.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :options => options.to_hash,
              :label => label,
              :intent => intent.nil? ? nil : intent.value,
              :type => type.nil? ? nil : type.value
            }
          end

        end

        class AttributeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :label, :intent, :type

          def initialize(incoming={})
            super(:discriminator => Event::Types::ATTRIBUTE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :label, :type], 'AttributeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @intent = (x = opts.delete(:intent); x.nil? ? nil : HttpClient::Preconditions.assert_class('intent', x, String))
            @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :label => label,
              :intent => intent,
              :type => type
            }
          end

        end

        # Retrieve journaled history of an attribute
        class AttributeVersion

          attr_reader :id, :timestamp, :type, :attribute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :attribute], 'AttributeVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Flow::V0::Models::Attribute) ? x : ::Io::Flow::V0::Models::Attribute.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AttributeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :attribute => attribute.to_hash
            }
          end

        end

        class AuthenticationForm

          attr_reader :email, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email, :password], 'AuthenticationForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password
            }
          end

        end

        class AuthorizationDeleteError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'AuthorizationDeleteError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::AuthorizationDeleteErrorCode) ? x : ::Io::Flow::V0::Models::AuthorizationDeleteErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDeleteError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class AuthorizationDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :key

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key], 'AuthorizationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key
            }
          end

        end

        class AuthorizationDeletedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_DELETED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'AuthorizationDeletedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationDeletedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        class AuthorizationOrderReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'AuthorizationOrderReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationOrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class AuthorizationReference

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'AuthorizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        # Contains the result of the authorization. If an immediate response is not
        # available, the state will be 'pending' - this usually indicates fraud review
        # requires additional time / verification (or a potential network issue with the
        # issuing bank).
        class AuthorizationResult

          attr_reader :status, :decline_code, :avs, :cvv

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'AuthorizationResult')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::AuthorizationStatus) ? x : ::Io::Flow::V0::Models::AuthorizationStatus.apply(x))
            @decline_code = (x = opts.delete(:decline_code); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationDeclineCode) ? x : ::Io::Flow::V0::Models::AuthorizationDeclineCode.apply(x)))
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationResult.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value,
              :decline_code => decline_code.nil? ? nil : decline_code.value,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        class AuthorizationStatusChanged < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_STATUS_CHANGED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'AuthorizationStatusChanged')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationStatusChanged.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class AuthorizationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :order_number, :card, :amount, :currency, :customer, :attributes, :destination, :result, :ip, :created_at

          def initialize(incoming={})
            super(:discriminator => Event::Types::AUTHORIZATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :card, :amount, :currency, :customer, :attributes, :result, :created_at], 'AuthorizationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @card = HttpClient::Preconditions.assert_class('card', HttpClient::Helper.to_object(opts.delete(:card)), Hash)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = HttpClient::Preconditions.assert_class('customer', HttpClient::Helper.to_object(opts.delete(:customer)), Hash)
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(x), Hash))
            @result = HttpClient::Preconditions.assert_class('result', HttpClient::Helper.to_object(opts.delete(:result)), Hash)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :order_number => order_number,
              :card => card,
              :amount => amount,
              :currency => currency,
              :customer => customer,
              :attributes => attributes,
              :destination => destination,
              :result => result,
              :ip => ip,
              :created_at => created_at
            }
          end

        end

        class AuthorizationVersion

          attr_reader :id, :timestamp, :type, :authorization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :authorization], 'AuthorizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::Authorization) ? x : ::Io::Flow::V0::Models::Authorization.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AuthorizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :authorization => authorization.to_hash
            }
          end

        end

        class AvailablePromotionsDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'AvailablePromotionsDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class AvailablePromotionsUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :available_promotions

          def initialize(incoming={})
            super(:discriminator => Event::Types::AVAILABLE_PROMOTIONS_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :available_promotions], 'AvailablePromotionsUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @available_promotions = HttpClient::Preconditions.assert_class('available_promotions', opts.delete(:available_promotions), Array).map { |v| HttpClient::Preconditions.assert_class('available_promotions', HttpClient::Helper.to_object(v), Hash) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailablePromotionsUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :available_promotions => available_promotions
            }
          end

        end

        # Representation of a service level available at a center and the special pickup
        # times during the week. If pickup schedules are not provided, assumption is
        # once a day during the weekdays.
        class AvailableService

          attr_reader :service, :scheduled_pickups, :lead_days

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:service], 'AvailableService')
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @scheduled_pickups = (x = opts.delete(:scheduled_pickups); x.nil? ? nil : HttpClient::Preconditions.assert_class('scheduled_pickups', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ScheduledPickup) ? x : ::Io::Flow::V0::Models::ScheduledPickup.new(x)) })
            @lead_days = (x = opts.delete(:lead_days); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NumberRange) ? x : ::Io::Flow::V0::Models::NumberRange.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            AvailableService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :service => service,
              :scheduled_pickups => scheduled_pickups.nil? ? nil : scheduled_pickups.map { |o| o.to_hash },
              :lead_days => lead_days.nil? ? nil : lead_days.to_hash
            }
          end

        end

        # Represents the address verification results
        class Avs

          attr_reader :code, :name, :address, :postal, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'Avs')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::AvsCode) ? x : ::Io::Flow::V0::Models::AvsCode.apply(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('name', x))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('address', x))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('postal', x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Avs.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :name => name,
              :address => address,
              :postal => postal,
              :description => description
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class Capture

          attr_reader :id, :key, :authorization, :amount, :currency, :created_at, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :authorization, :amount, :currency, :created_at], 'Capture')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Capture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :authorization => authorization.to_hash,
              :amount => amount,
              :currency => currency,
              :created_at => created_at,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Capture actually transfers funds. You can capture as many times as you'd like
        # up until the total amount of the authorization has been captured or the
        # authorization otherwise becomes unavailable (e.g. expires).
        class CaptureForm

          attr_reader :authorization_id, :key, :amount, :currency, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:authorization_id], 'CaptureForm')
            @authorization_id = HttpClient::Preconditions.assert_class('authorization_id', opts.delete(:authorization_id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authorization_id => authorization_id,
              :key => key,
              :amount => amount,
              :currency => currency,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class CaptureUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :authorization_key, :amount, :currency, :created_at

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :authorization_key, :amount, :currency, :created_at], 'CaptureUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization_key = HttpClient::Preconditions.assert_class('authorization_key', opts.delete(:authorization_key), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :authorization_key => authorization_key,
              :amount => amount,
              :currency => currency,
              :created_at => created_at
            }
          end

        end

        class CaptureUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :capture

          def initialize(incoming={})
            super(:discriminator => Event::Types::CAPTURE_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :capture], 'CaptureUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :capture => capture.to_hash
            }
          end

        end

        class CaptureVersion

          attr_reader :id, :timestamp, :type, :capture

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :capture], 'CaptureVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CaptureVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :capture => capture.to_hash
            }
          end

        end

        # Card represents the metadata about a secure, tokenized card. The card 'token'
        # is a unique, cryptographically secure token by which this card can be
        # identified in the future. The card token itself will either be a permanent
        # card token (denoted by a prefix of F96) or a one time nonce (denoted by a
        # prefix of F17). Nonces represent cards that were encrypted from public
        # channels (like the user's browser via JavaScript) and can be used once only.
        # If you have a nonce you can exchange it for a permanent card token via the
        # operation POST /:organization/cards/nonces
        class Card < ExpandableCard

          attr_reader :id, :token, :type, :expiration, :iin, :last4, :name, :address

          def initialize(incoming={})
            super(:discriminator => ExpandableCard::Types::CARD)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :token, :type, :expiration, :iin, :last4, :name], 'Card')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::CardType) ? x : ::Io::Flow::V0::Models::CardType.apply(x))
            @expiration = (x = opts.delete(:expiration); x.is_a?(::Io::Flow::V0::Models::Expiration) ? x : ::Io::Flow::V0::Models::Expiration.new(x))
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Card.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :token => token,
              :type => type.value,
              :expiration => expiration.to_hash,
              :iin => iin,
              :last4 => last4,
              :name => name,
              :address => address.nil? ? nil : address.to_hash
            }
          end

        end

        # An authorization is used to check and reserve funds w/ a given payment method.
        # No funds are actually transferred; once you have you an authorization, you can
        # capture up to the amount of the authorization.
        class CardAuthorization < Authorization

          attr_reader :id, :key, :card, :amount, :currency, :customer, :attributes, :destination, :order, :ip, :result, :created_at

          def initialize(incoming={})
            super(:discriminator => Authorization::Types::CARD_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :card, :amount, :currency, :customer, :attributes, :result, :created_at], 'CardAuthorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::ExpandableCard) ? x : ::Io::Flow::V0::Models::ExpandableCard.from_json(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @result = (x = opts.delete(:result); x.is_a?(::Io::Flow::V0::Models::AuthorizationResult) ? x : ::Io::Flow::V0::Models::AuthorizationResult.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :card => card.to_hash,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :attributes => attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :ip => ip,
              :result => result.to_hash,
              :created_at => created_at
            }
          end

        end

        # Represents an authorization for a card payment method
        class CardAuthorizationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_AUTHORIZATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :authorization], 'CardAuthorizationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::CardAuthorization) ? x : ::Io::Flow::V0::Models::CardAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorizationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :authorization => authorization.to_hash
            }
          end

        end

        # Represents an authorization for a card payment method
        class CardAuthorizationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_AUTHORIZATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'CardAuthorizationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::CardAuthorization) ? x : ::Io::Flow::V0::Models::CardAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardAuthorizationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class CardDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'CardDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Details for why a card was declined
        class CardError

          attr_reader :code, :messages, :avs, :cvv

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'CardError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::CardErrorCode) ? x : ::Io::Flow::V0::Models::CardErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @avs = (x = opts.delete(:avs); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Avs) ? x : ::Io::Flow::V0::Models::Avs.new(x)))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Cvv) ? x : ::Io::Flow::V0::Models::Cvv.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :avs => avs.nil? ? nil : avs.to_hash,
              :cvv => cvv.nil? ? nil : cvv.to_hash
            }
          end

        end

        class CardForm

          attr_reader :number, :cipher, :expiration_month, :expiration_year, :name, :cvv, :address, :ip, :challenge_text, :challenge_cipher

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:expiration_month, :expiration_year, :name, :cvv], 'CardForm')
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @cipher = (x = opts.delete(:cipher); x.nil? ? nil : HttpClient::Preconditions.assert_class('cipher', x, String))
            @expiration_month = HttpClient::Preconditions.assert_class('expiration_month', opts.delete(:expiration_month), Integer)
            @expiration_year = HttpClient::Preconditions.assert_class('expiration_year', opts.delete(:expiration_year), Integer)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @cvv = HttpClient::Preconditions.assert_class('cvv', opts.delete(:cvv), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @challenge_text = (x = opts.delete(:challenge_text); x.nil? ? nil : HttpClient::Preconditions.assert_class('challenge_text', x, String))
            @challenge_cipher = (x = opts.delete(:challenge_cipher); x.nil? ? nil : HttpClient::Preconditions.assert_class('challenge_cipher', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :cipher => cipher,
              :expiration_month => expiration_month,
              :expiration_year => expiration_year,
              :name => name,
              :cvv => cvv,
              :address => address.nil? ? nil : address.to_hash,
              :ip => ip,
              :challenge_text => challenge_text,
              :challenge_cipher => challenge_cipher
            }
          end

        end

        # The card nonce form presents a one time token to exchance server side for a
        # permanent, secure tokenized card
        class CardNonceForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'CardNonceForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardNonceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        class CardReference < ExpandableCard

          attr_reader :id, :token

          def initialize(incoming={})
            super(:discriminator => ExpandableCard::Types::CARD_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :token], 'CardReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :token => token
            }
          end

        end

        class CardUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :type, :expiration, :iin, :last4, :name, :address

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :type, :expiration, :iin, :last4, :name], 'CardUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_object(opts.delete(:expiration)), Hash)
            @iin = HttpClient::Preconditions.assert_class('iin', opts.delete(:iin), String)
            @last4 = HttpClient::Preconditions.assert_class('last4', opts.delete(:last4), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :type => type,
              :expiration => expiration,
              :iin => iin,
              :last4 => last4,
              :name => name,
              :address => address
            }
          end

        end

        class CardUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :card

          def initialize(incoming={})
            super(:discriminator => Event::Types::CARD_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :card], 'CardUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :card => card.to_hash
            }
          end

        end

        class CardVersion

          attr_reader :id, :timestamp, :type, :card

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :card], 'CardVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @card = (x = opts.delete(:card); x.is_a?(::Io::Flow::V0::Models::Card) ? x : ::Io::Flow::V0::Models::Card.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CardVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :card => card.to_hash
            }
          end

        end

        # Partner that actually take a shipment between places (ex: FedEx, DHL, SF
        # Express)
        class Carrier

          attr_reader :id, :name, :facilities, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :facilities, :visibility], 'Carrier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @facilities = HttpClient::Preconditions.assert_class('facilities', opts.delete(:facilities), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)) }
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Carrier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :facilities => facilities.map { |o| o.to_hash },
              :visibility => visibility.value
            }
          end

        end

        class CarrierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CarrierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CarrierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CartReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CartReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CartReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class Catalog

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Catalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Catalog.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CatalogDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog], 'CatalogDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog
            }
          end

        end

        # Describes a catalog feed.
        class CatalogFeed < Feed

          attr_reader :id, :experience_feed_summaries, :incoming_feed, :outgoing_feed, :feed_statistics_summary

          def initialize(incoming={})
            super(:discriminator => Feed::Types::CATALOG_FEED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience_feed_summaries, :incoming_feed, :outgoing_feed, :feed_statistics_summary], 'CatalogFeed')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience_feed_summaries = HttpClient::Preconditions.assert_class('experience_feed_summaries', opts.delete(:experience_feed_summaries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceFeedSummary) ? x : ::Io::Flow::V0::Models::ExperienceFeedSummary.new(x)) }
            @incoming_feed = (x = opts.delete(:incoming_feed); x.is_a?(::Io::Flow::V0::Models::IncomingFeed) ? x : ::Io::Flow::V0::Models::IncomingFeed.new(x))
            @outgoing_feed = (x = opts.delete(:outgoing_feed); x.is_a?(::Io::Flow::V0::Models::OutgoingFeed) ? x : ::Io::Flow::V0::Models::OutgoingFeed.new(x))
            @feed_statistics_summary = (x = opts.delete(:feed_statistics_summary); x.is_a?(::Io::Flow::V0::Models::FeedStatisticsSummary) ? x : ::Io::Flow::V0::Models::FeedStatisticsSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogFeed.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :experience_feed_summaries => experience_feed_summaries.map { |o| o.to_hash },
              :incoming_feed => incoming_feed.to_hash,
              :outgoing_feed => outgoing_feed.to_hash,
              :feed_statistics_summary => feed_statistics_summary.to_hash
            }
          end

        end

        # Specify a catalog feed for one or more experiences.
        class CatalogFeedFormPost

          attr_reader :experience_keys, :incoming_feed, :outgoing_feed_form

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience_keys, :incoming_feed, :outgoing_feed_form], 'CatalogFeedFormPost')
            @experience_keys = HttpClient::Preconditions.assert_class('experience_keys', opts.delete(:experience_keys), Array).map { |v| HttpClient::Preconditions.assert_class('experience_keys', v, String) }
            @incoming_feed = (x = opts.delete(:incoming_feed); x.is_a?(::Io::Flow::V0::Models::IncomingFeed) ? x : ::Io::Flow::V0::Models::IncomingFeed.new(x))
            @outgoing_feed_form = (x = opts.delete(:outgoing_feed_form); x.is_a?(::Io::Flow::V0::Models::OutgoingFeed) ? x : ::Io::Flow::V0::Models::OutgoingFeed.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogFeedFormPost.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience_keys => experience_keys,
              :incoming_feed => incoming_feed.to_hash,
              :outgoing_feed_form => outgoing_feed_form.to_hash
            }
          end

        end

        # Specify a catalog feed for one or more experiences.
        class CatalogFeedFormPut

          attr_reader :id, :experience_keys, :incoming_feed, :outgoing_feed_form

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience_keys, :incoming_feed, :outgoing_feed_form], 'CatalogFeedFormPut')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience_keys = HttpClient::Preconditions.assert_class('experience_keys', opts.delete(:experience_keys), Array).map { |v| HttpClient::Preconditions.assert_class('experience_keys', v, String) }
            @incoming_feed = (x = opts.delete(:incoming_feed); x.is_a?(::Io::Flow::V0::Models::IncomingFeed) ? x : ::Io::Flow::V0::Models::IncomingFeed.new(x))
            @outgoing_feed_form = (x = opts.delete(:outgoing_feed_form); x.is_a?(::Io::Flow::V0::Models::OutgoingFeed) ? x : ::Io::Flow::V0::Models::OutgoingFeed.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogFeedFormPut.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience_keys => experience_keys,
              :incoming_feed => incoming_feed.to_hash,
              :outgoing_feed_form => outgoing_feed_form.to_hash
            }
          end

        end

        class CatalogItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog], 'CatalogItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog
            }
          end

        end

        class CatalogItemDocument < Document

          attr_reader :number, :name, :categories, :experiences, :attributes, :images

          def initialize(incoming={})
            super(:discriminator => Document::Types::CATALOG_ITEM_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :categories, :experiences, :attributes, :images], 'CatalogItemDocument')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @experiences = HttpClient::Preconditions.assert_class('experiences', opts.delete(:experiences), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x)) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @images = (x = opts.delete(:images); x.is_a?(::Io::Flow::V0::Models::CatalogItemDocumentImages) ? x : ::Io::Flow::V0::Models::CatalogItemDocumentImages.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :number => number,
              :name => name,
              :categories => categories,
              :experiences => experiences.map { |o| o.to_hash },
              :attributes => attributes,
              :images => images.to_hash
            }
          end

        end

        class CatalogItemDocumentImages

          attr_reader :thumbnail

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @thumbnail = (x = opts.delete(:thumbnail); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemDocumentImages.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :thumbnail => thumbnail.nil? ? nil : thumbnail.to_hash
            }
          end

        end

        # Defines the filters that can be applied when requesting a catalog item data
        # export
        class CatalogItemExportType < ExportType

          attr_reader :numbers, :q, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::CATALOG_ITEM_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :q => q,
              :sort => sort
            }
          end

        end

        class CatalogItemSummary

          attr_reader :number, :name, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :attributes], 'CatalogItemSummary')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name,
              :attributes => attributes
            }
          end

        end

        class CatalogItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :attributes, :dimensions, :images], 'CatalogItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', HttpClient::Helper.to_object(opts.delete(:dimensions)), Hash)
            @images = HttpClient::Preconditions.assert_class('images', opts.delete(:images), Array).map { |v| HttpClient::Preconditions.assert_class('images', HttpClient::Helper.to_object(v), Hash) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions,
              :images => images
            }
          end

        end

        class CatalogReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class CatalogStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'CatalogStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        class CatalogUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::CATALOG_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog], 'CatalogUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog
            }
          end

        end

        class CatalogVersion

          attr_reader :id, :timestamp, :type, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :catalog], 'CatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :catalog => catalog.to_hash
            }
          end

        end

        class CategorySummary

          attr_reader :name, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:count], 'CategorySummary')
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CategorySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :count => count
            }
          end

        end

        # Represents a facility capable of fulfilling a shipment
        class Center

          attr_reader :id, :key, :address, :packaging, :name, :services, :schedule, :timezone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :address, :packaging, :name, :services, :schedule, :timezone], 'Center')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Center.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone
            }
          end

        end

        class CenterForm

          attr_reader :address, :packaging, :name, :services, :schedule, :timezone, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :packaging, :name, :services, :schedule], 'CenterForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @packaging = HttpClient::Preconditions.assert_class('packaging', opts.delete(:packaging), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Packaging) ? x : ::Io::Flow::V0::Models::Packaging.new(x)) }
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AvailableService) ? x : ::Io::Flow::V0::Models::AvailableService.new(x)) }
            @schedule = (x = opts.delete(:schedule); x.is_a?(::Io::Flow::V0::Models::Schedule) ? x : ::Io::Flow::V0::Models::Schedule.new(x))
            @timezone = (x = opts.delete(:timezone); x.nil? ? nil : HttpClient::Preconditions.assert_class('timezone', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :packaging => packaging.map { |o| o.to_hash },
              :name => name,
              :services => services.map { |o| o.to_hash },
              :schedule => schedule.to_hash,
              :timezone => timezone,
              :key => key
            }
          end

        end

        class CenterReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'CenterReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class CenterVersion

          attr_reader :id, :timestamp, :type, :center

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :center], 'CenterVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::Center) ? x : ::Io::Flow::V0::Models::Center.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CenterVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :center => center.to_hash
            }
          end

        end

        # The actual value of the API token. This is modeled as a separate resource as
        # it is fetched only on demand.
        class Cleartext

          attr_reader :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value], 'Cleartext')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cleartext.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value
            }
          end

        end

        # Defines structured fields for a contact person. Typically used for specifying
        # contact person for an account, shipment, or organization representative
        class Contact

          attr_reader :name, :company, :email, :phone

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Contact')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @company = (x = opts.delete(:company); x.nil? ? nil : HttpClient::Preconditions.assert_class('company', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Contact.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :company => company,
              :email => email,
              :phone => phone
            }
          end

        end

        # ISO 3166 country codes. Note Flow APIs will accept either the 2 or 3 character
        # country code, but internally we normalize data and store as the 3 character,
        # upper case ISO code. See https://api.flow.io/reference/countries
        class Country

          attr_reader :name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :default_currency, :timezones, :default_delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_3166_2, :iso_3166_3, :languages, :measurement_system, :timezones], 'Country')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @iso_3166_3 = HttpClient::Preconditions.assert_class('iso_3166_3', opts.delete(:iso_3166_3), String)
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @default_currency = (x = opts.delete(:default_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_currency', x, String))
            @timezones = HttpClient::Preconditions.assert_class('timezones', opts.delete(:timezones), Array).map { |v| HttpClient::Preconditions.assert_class('timezones', v, String) }
            @default_delivered_duty = (x = opts.delete(:default_delivered_duty); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_delivered_duty', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Country.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_3166_2 => iso_3166_2,
              :iso_3166_3 => iso_3166_3,
              :languages => languages,
              :measurement_system => measurement_system,
              :default_currency => default_currency,
              :timezones => timezones,
              :default_delivered_duty => default_delivered_duty
            }
          end

        end

        # Provides country level default settings for currency, language, etc.
        class CountryDefaults

          attr_reader :country, :currency, :language

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language], 'CountryDefaults')
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CountryDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country,
              :currency => currency,
              :language => language
            }
          end

        end

        # ISO 4217 3-character currency code. See
        # https://api.flow.io/reference/currencies
        class Currency

          attr_reader :name, :iso_4217_3, :number_decimals, :symbols, :default_locale

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_4217_3, :number_decimals], 'Currency')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_4217_3 = HttpClient::Preconditions.assert_class('iso_4217_3', opts.delete(:iso_4217_3), String)
            @number_decimals = HttpClient::Preconditions.assert_class('number_decimals', opts.delete(:number_decimals), Integer)
            @symbols = (x = opts.delete(:symbols); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::CurrencySymbols) ? x : ::Io::Flow::V0::Models::CurrencySymbols.new(x)))
            @default_locale = (x = opts.delete(:default_locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_locale', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Currency.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_4217_3 => iso_4217_3,
              :number_decimals => number_decimals,
              :symbols => symbols.nil? ? nil : symbols.to_hash,
              :default_locale => default_locale
            }
          end

        end

        # Defines one or more symbols representing this currency
        class CurrencySymbols

          attr_reader :primary, :narrow

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:primary], 'CurrencySymbols')
            @primary = HttpClient::Preconditions.assert_class('primary', opts.delete(:primary), String)
            @narrow = (x = opts.delete(:narrow); x.nil? ? nil : HttpClient::Preconditions.assert_class('narrow', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            CurrencySymbols.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :primary => primary,
              :narrow => narrow
            }
          end

        end

        # A customer represents the actual person purchasing from you. This information
        # is needed primarily to support logistics (delivery to this person), fraud
        # management (verification of who the person is), and reporting. We also
        # recommend including your customer number whenever possible as doing so will
        # allow Flow to link up transactions for this customer making customer service
        # easier.
        class Customer

          attr_reader :name, :number, :phone, :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'Customer')
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @phone = (x = opts.delete(:phone); x.nil? ? nil : HttpClient::Preconditions.assert_class('phone', x, String))
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Customer.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name.to_hash,
              :number => number,
              :phone => phone,
              :email => email
            }
          end

        end

        # Represents the card verification results
        class Cvv

          attr_reader :code, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'Cvv')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::CvvCode) ? x : ::Io::Flow::V0::Models::CvvCode.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Cvv.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :description => description
            }
          end

        end

        class DatetimeRange

          attr_reader :from, :to

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DatetimeRange')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DatetimeRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to
            }
          end

        end

        class DeliveredDutySetting

          attr_reader :default, :available

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:default, :available], 'DeliveredDutySetting')
            @default = (x = opts.delete(:default); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveredDutySetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :default => default.value,
              :available => available.map { |o| o.value }
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class Delivery

          attr_reader :id, :items, :options

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :options], 'Delivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @options = HttpClient::Preconditions.assert_class('options', opts.delete(:options), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOption) ? x : ::Io::Flow::V0::Models::DeliveryOption.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Delivery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :options => options.map { |o| o.to_hash }
            }
          end

        end

        # Represents a collection of items, the available delivery option tier for that
        # collection of items, and metadata about those options
        class DeliveryForm

          attr_reader :quote, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quote, :items, :destination], 'DeliveryForm')
            @quote = HttpClient::Preconditions.assert_class('quote', opts.delete(:quote), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :quote => quote,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOption

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window, :rule_outcome, :weight

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOption')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DeliveryWindow) ? x : ::Io::Flow::V0::Models::DeliveryWindow.new(x))
            @rule_outcome = (x = opts.delete(:rule_outcome); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OptionWeightEstimates) ? x : ::Io::Flow::V0::Models::OptionWeightEstimates.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOption.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash,
              :rule_outcome => rule_outcome.nil? ? nil : rule_outcome.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash
            }
          end

        end

        # Represents a way to fulfill a delivery, including an estimates for the date
        # range and cost
        class DeliveryOptionForm

          attr_reader :delivery, :items, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivery, :items, :destination], 'DeliveryOptionForm')
            @delivery = HttpClient::Preconditions.assert_class('delivery', opts.delete(:delivery), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivery => delivery,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash
            }
          end

        end

        class DeliveryOptionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'DeliveryOptionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class DeliveryOptionSummary

          attr_reader :id, :cost, :delivered_duty, :price, :service, :tier, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :cost, :delivered_duty, :price, :service, :tier, :window], 'DeliveryOptionSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceReference) ? x : ::Io::Flow::V0::Models::ServiceReference.new(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :cost => cost.to_hash,
              :delivered_duty => delivered_duty.value,
              :price => price.to_hash,
              :service => service.to_hash,
              :tier => tier.to_hash,
              :window => window.to_hash
            }
          end

        end

        class DeliveryOptionVersion

          attr_reader :id, :timestamp, :type, :delivery_option

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery_option], 'DeliveryOptionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery_option = (x = opts.delete(:delivery_option); x.is_a?(::Io::Flow::V0::Models::DeliveryOptionSummary) ? x : ::Io::Flow::V0::Models::DeliveryOptionSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryOptionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery_option => delivery_option.to_hash
            }
          end

        end

        class DeliverySummary

          attr_reader :id, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items], 'DeliverySummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliverySummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class DeliveryVersion

          attr_reader :id, :timestamp, :type, :delivery

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :delivery], 'DeliveryVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @delivery = (x = opts.delete(:delivery); x.is_a?(::Io::Flow::V0::Models::DeliverySummary) ? x : ::Io::Flow::V0::Models::DeliverySummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :delivery => delivery.to_hash
            }
          end

        end

        class DeliveryWindow

          attr_reader :from, :to, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to], 'DeliveryWindow')
            @from = HttpClient::Preconditions.assert_class('from', HttpClient::Helper.to_date_time_iso8601(opts.delete(:from)), DateTime)
            @to = HttpClient::Preconditions.assert_class('to', HttpClient::Helper.to_date_time_iso8601(opts.delete(:to)), DateTime)
            @label = (x = opts.delete(:label); x.nil? ? nil : HttpClient::Preconditions.assert_class('label', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeliveryWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :label => label
            }
          end

        end

        # De Minimis per item describes rules which require minimum and/or maximum
        # values per item
        class DeminimisPerItem < Deminimis

          attr_reader :currency, :minimum, :maximum

          def initialize(incoming={})
            super(:discriminator => Deminimis::Types::DEMINIMIS_PER_ITEM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency], 'DeminimisPerItem')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @minimum = (x = opts.delete(:minimum); x.nil? ? nil : HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @maximum = (x = opts.delete(:maximum); x.nil? ? nil : HttpClient::Preconditions.assert_class('maximum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimisPerItem.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :minimum => minimum,
              :maximum => maximum
            }
          end

        end

        # De Minimis for most common example which includes a value threshold and rules
        # on what components are used in the duty calculation
        class DeminimisSimple < Deminimis

          attr_reader :value, :currency, :components, :minimum

          def initialize(incoming={})
            super(:discriminator => Deminimis::Types::DEMINIMIS_SIMPLE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :components], 'DeminimisSimple')
            @value = (x = opts.delete(:value); x.nil? ? nil : HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @minimum = (x = opts.delete(:minimum); x.nil? ? nil : HttpClient::Preconditions.assert_class('minimum', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DeminimisSimple.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :value => value,
              :currency => currency,
              :components => components.map { |o| o.value },
              :minimum => minimum
            }
          end

        end

        class Dimension

          attr_reader :depth, :diameter, :length, :weight, :width

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @depth = (x = opts.delete(:depth); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @diameter = (x = opts.delete(:diameter); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @length = (x = opts.delete(:length); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @weight = (x = opts.delete(:weight); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
            @width = (x = opts.delete(:width); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimension.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :depth => depth.nil? ? nil : depth.to_hash,
              :diameter => diameter.nil? ? nil : diameter.to_hash,
              :length => length.nil? ? nil : length.to_hash,
              :weight => weight.nil? ? nil : weight.to_hash,
              :width => width.nil? ? nil : width.to_hash
            }
          end

        end

        class Dimensions

          attr_reader :product, :packaging

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @product = (x = opts.delete(:product); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
            @packaging = (x = opts.delete(:packaging); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Dimensions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :product => product.nil? ? nil : product.to_hash,
              :packaging => packaging.nil? ? nil : packaging.to_hash
            }
          end

        end

        # Creates an authorization for a transaction in which you remain the merchant of
        # record. An authorization is used to check and reserve funds w/ a given payment
        # method. No funds are actually transferred; once you have you an authorization,
        # you can capture up to the amount of the authorization.
        class DirectAuthorizationForm < AuthorizationForm

          attr_reader :token, :amount, :currency, :customer, :key, :cvv, :attributes, :destination, :ip, :options

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::DIRECT_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :amount, :currency], 'DirectAuthorizationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x)))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @options = (x = opts.delete(:options); x.nil? ? nil : HttpClient::Preconditions.assert_class('options', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthorizationOption) ? x : ::Io::Flow::V0::Models::AuthorizationOption.apply(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            DirectAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :token => token,
              :amount => amount,
              :currency => currency,
              :customer => customer.nil? ? nil : customer.to_hash,
              :key => key,
              :cvv => cvv,
              :attributes => attributes.nil? ? nil : attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :ip => ip,
              :options => options.nil? ? nil : options.map { |o| o.value }
            }
          end

        end

        # Represents a duration of time.
        class Duration

          attr_reader :unit, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:unit, :value], 'Duration')
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :unit => unit.value,
              :value => value
            }
          end

        end

        # Represents a simple model of duties that apply to a given item / trade lane.
        class Duty

          attr_reader :rate, :components, :deminimis

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:rate, :components], 'Duty')
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimis = (x = opts.delete(:deminimis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimis) ? x : ::Io::Flow::V0::Models::Deminimis.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Duty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimis => deminimis.nil? ? nil : deminimis.to_hash
            }
          end

        end

        # Represents the successful response of an email verification token. We return
        # the email address in this case to allow the UI to display which email address
        # was verified.
        class EmailVerification

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'EmailVerification')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EmailVerification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        # Range of time given a from and to number and the unit. For example: 1-4 hours
        # or 4-7 days
        class EstimatedWindow

          attr_reader :from, :to, :unit

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:from, :to, :unit], 'EstimatedWindow')
            @from = HttpClient::Preconditions.assert_class('from', opts.delete(:from), Integer)
            @to = HttpClient::Preconditions.assert_class('to', opts.delete(:to), Integer)
            @unit = (x = opts.delete(:unit); x.is_a?(::Io::Flow::V0::Models::UnitOfTime) ? x : ::Io::Flow::V0::Models::UnitOfTime.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            EstimatedWindow.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :from => from,
              :to => to,
              :unit => unit.value
            }
          end

        end

        # Represents an exception to the schedule of a center.
        class Exception

          attr_reader :type, :datetime_range

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :datetime_range], 'Exception')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExceptionType) ? x : ::Io::Flow::V0::Models::ExceptionType.apply(x))
            @datetime_range = (x = opts.delete(:datetime_range); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Exception.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :datetime_range => datetime_range.to_hash
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class Experience < ExpandableExperience

          attr_reader :id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position, :settings

          def initialize(incoming={})
            super(:discriminator => ExpandableExperience::Types::EXPERIENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :delivered_duty, :region, :country, :currency, :language, :measurement_system, :subcatalog, :position, :settings], 'Experience')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x))
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::ExperienceSettings) ? x : ::Io::Flow::V0::Models::ExperienceSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experience.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty.value,
              :region => region.to_hash,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value,
              :subcatalog => subcatalog.to_hash,
              :position => position,
              :settings => settings.to_hash
            }
          end

        end

        # Defines a set of defaults for a given organization and region
        class ExperienceDefaults

          attr_reader :key, :name, :delivered_duty, :country, :currency, :language, :measurement_system

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name, :delivered_duty, :country, :currency, :language, :measurement_system], 'ExperienceDefaults')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceDefaults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty.value,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value
            }
          end

        end

        class ExperienceDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :subcatalog_id], 'ExperienceDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class ExperienceFeedSummary

          attr_reader :experience, :url, :last_construct_date

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience, :url], 'ExperienceFeedSummary')
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceReference) ? x : ::Io::Flow::V0::Models::ExperienceReference.new(x))
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @last_construct_date = (x = opts.delete(:last_construct_date); x.nil? ? nil : HttpClient::Preconditions.assert_class('last_construct_date', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceFeedSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience => experience.to_hash,
              :url => url,
              :last_construct_date => last_construct_date
            }
          end

        end

        # Experiences define a local experience for a given geographic region
        class ExperienceForm

          attr_reader :region_id, :name, :delivered_duty, :country, :currency, :language, :key, :measurement_system, :subcatalog_id, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:region_id, :name], 'ExperienceForm')
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @measurement_system = (x = opts.delete(:measurement_system); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x)))
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :region_id => region_id,
              :name => name,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :country => country,
              :currency => currency,
              :language => language,
              :key => key,
              :measurement_system => measurement_system.nil? ? nil : measurement_system.value,
              :subcatalog_id => subcatalog_id,
              :position => position
            }
          end

        end

        # Experience Geo summarizes an experience along with geographic info
        class ExperienceGeo

          attr_reader :key, :name, :region, :country, :currency, :language, :measurement_system

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name, :region, :country, :currency, :language, :measurement_system], 'ExperienceGeo')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @region = (x = opts.delete(:region); x.is_a?(::Io::Flow::V0::Models::RegionReference) ? x : ::Io::Flow::V0::Models::RegionReference.new(x))
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = (x = opts.delete(:measurement_system); x.is_a?(::Io::Flow::V0::Models::MeasurementSystem) ? x : ::Io::Flow::V0::Models::MeasurementSystem.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceGeo.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name,
              :region => region.to_hash,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system.value
            }
          end

        end

        class ExperienceReference < ExpandableExperience

          attr_reader :key

          def initialize(incoming={})
            super(:discriminator => ExpandableExperience::Types::EXPERIENCE_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'ExperienceReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :key => key
            }
          end

        end

        class ExperienceSettings

          attr_reader :delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:delivered_duty], 'ExperienceSettings')
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDutySetting) ? x : ::Io::Flow::V0::Models::DeliveredDutySetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :delivered_duty => delivered_duty.to_hash
            }
          end

        end

        # Some important fields related to experiences used in various APIs
        class ExperienceSummary

          attr_reader :id, :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name], 'ExperienceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name
            }
          end

        end

        class ExperienceUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :name, :delivered_duty, :subcatalog_id, :region_id, :country, :currency, :language, :measurement_system, :position

          def initialize(incoming={})
            super(:discriminator => Event::Types::EXPERIENCE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :name, :delivered_duty, :subcatalog_id, :region_id, :country, :currency, :language, :measurement_system, :position], 'ExperienceUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @delivered_duty = HttpClient::Preconditions.assert_class('delivered_duty', opts.delete(:delivered_duty), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @region_id = HttpClient::Preconditions.assert_class('region_id', opts.delete(:region_id), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @measurement_system = HttpClient::Preconditions.assert_class('measurement_system', opts.delete(:measurement_system), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :name => name,
              :delivered_duty => delivered_duty,
              :subcatalog_id => subcatalog_id,
              :region_id => region_id,
              :country => country,
              :currency => currency,
              :language => language,
              :measurement_system => measurement_system,
              :position => position
            }
          end

        end

        class ExperienceVersion

          attr_reader :id, :timestamp, :type, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :experience], 'ExperienceVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::Experience) ? x : ::Io::Flow::V0::Models::Experience.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperienceVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :experience => experience.to_hash
            }
          end

        end

        # Represents a single experiment / test (e.g. for an incremental rollout or AB
        # Test)
        class Experiment

          attr_reader :id, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key], 'Experiment')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Experiment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key
            }
          end

        end

        # Represents a single instance of an experiment (e.g. page request) resulting in
        # a decision as to the status of a given experiment
        class ExperimentStatus

          attr_reader :enabled

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:enabled], 'ExperimentStatus')
            @enabled = HttpClient::Preconditions.assert_boolean('enabled', opts.delete(:enabled))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExperimentStatus.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :enabled => enabled
            }
          end

        end

        # The month and year at which a card expires
        class Expiration

          attr_reader :month, :year

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:month, :year], 'Expiration')
            @month = HttpClient::Preconditions.assert_class('month', opts.delete(:month), Integer)
            @year = HttpClient::Preconditions.assert_class('year', opts.delete(:year), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Expiration.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :month => month,
              :year => year
            }
          end

        end

        # Exports represent data extraction requests (e.g. download my catalog items to
        # a CSV file)
        class Export

          attr_reader :id, :type, :status, :organization_q, :created_at, :started_at, :completed_at, :url, :deliveries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :status, :organization_q, :created_at, :deliveries], 'Export')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExportStatus) ? x : ::Io::Flow::V0::Models::ExportStatus.apply(x))
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @url = (x = opts.delete(:url); x.nil? ? nil : HttpClient::Preconditions.assert_class('url', x, String))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportDelivery) ? x : ::Io::Flow::V0::Models::ExportDelivery.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Export.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.to_hash,
              :status => status.value,
              :organization_q => organization_q,
              :created_at => created_at,
              :started_at => started_at,
              :completed_at => completed_at,
              :url => url,
              :deliveries => deliveries.map { |o| o.to_hash }
            }
          end

        end

        # Triggers an email notification once the requested export is ready
        class ExportDeliveryEmail < ExportDelivery

          attr_reader :email

          def initialize(incoming={})
            super(:discriminator => ExportDelivery::Types::EXPORT_DELIVERY_EMAIL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'ExportDeliveryEmail')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportDeliveryEmail.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :email => email
            }
          end

        end

        # Export forms are used to create exports. The export type defines both the type
        # of the export (e.g. the CSV File format) and the available parameters for each
        # export (e.g. the filters to apply to select the desired data).
        class ExportForm

          attr_reader :type, :emails, :organization_q

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type], 'ExportForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x))
            @emails = (x = opts.delete(:emails); x.nil? ? nil : HttpClient::Preconditions.assert_class('emails', x, Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) })
            @organization_q = (x = opts.delete(:organization_q); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_q', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.to_hash,
              :emails => emails.nil? ? nil : emails,
              :organization_q => organization_q
            }
          end

        end

        class ExportVersion

          attr_reader :id, :timestamp, :type, :export

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :export], 'ExportVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @export = (x = opts.delete(:export); x.is_a?(::Io::Flow::V0::Models::Export) ? x : ::Io::Flow::V0::Models::Export.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ExportVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :export => export.to_hash
            }
          end

        end

        # A brief packet of statistics about a live feed. Will be blank for most new
        # feeds.
        class FeedStatisticsSummary

          attr_reader :last_incoming_date

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @last_incoming_date = (x = opts.delete(:last_incoming_date); x.nil? ? nil : HttpClient::Preconditions.assert_class('last_incoming_date', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FeedStatisticsSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :last_incoming_date => last_incoming_date
            }
          end

        end

        class Ference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'Ference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Ference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is pre-defined flat rate
        class FlatRate < TierRuleOutcome

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::FLAT_RATE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRate')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRate.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class FlatRateForm < TierRuleOutcomeForm

          attr_reader :price

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcomeForm::Types::FLAT_RATE_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:price], 'FlatRateForm')
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlatRateForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :price => price.to_hash
            }
          end

        end

        class FlowItemIndexMetadata

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'FlowItemIndexMetadata')
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FlowItemIndexMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.value
            }
          end

        end

        class FreeShipping < Promotion

          attr_reader :trigger

          def initialize(incoming={})
            super(:discriminator => Promotion::Types::FREE_SHIPPING)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:trigger], 'FreeShipping')
            @trigger = (x = opts.delete(:trigger); x.is_a?(::Io::Flow::V0::Models::PromotionTrigger) ? x : ::Io::Flow::V0::Models::PromotionTrigger.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FreeShipping.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :trigger => trigger.to_hash
            }
          end

        end

        class FulfillmentExperienceReference

          attr_reader :id, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :currency], 'FulfillmentExperienceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            FulfillmentExperienceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :currency => currency
            }
          end

        end

        # An error of some type has occured. The most common error will be validation on
        # input. See messages for details.
        class GenericError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages], 'GenericError')
            @code = (x = (x = opts.delete(:code); x.nil? ? "generic_error" : x); x.is_a?(::Io::Flow::V0::Models::GenericErrorCode) ? x : ::Io::Flow::V0::Models::GenericErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            GenericError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class HarmonizationDocument < Document

          attr_reader :code, :categories, :origin

          def initialize(incoming={})
            super(:discriminator => Document::Types::HARMONIZATION_DOCUMENT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :categories], 'HarmonizationDocument')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::CategorySummary) ? x : ::Io::Flow::V0::Models::CategorySummary.new(x)) }
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationDocument.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :code => code,
              :categories => categories.map { |o| o.to_hash },
              :origin => origin
            }
          end

        end

        # Exports harmonization HS10 codes
        class HarmonizationHs10ExportType < ExportType

          attr_reader :origin, :destination, :numbers, :has_codes, :has_origins, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_HS10_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @has_codes = (x = opts.delete(:has_codes); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_codes', x))
            @has_origins = (x = opts.delete(:has_origins); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_origins', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationHs10ExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin => origin,
              :destination => destination,
              :numbers => numbers.nil? ? nil : numbers,
              :has_codes => has_codes,
              :has_origins => has_origins,
              :sort => sort
            }
          end

        end

        # Exports HS6 codes
        class HarmonizationHs6ExportType < ExportType

          attr_reader :numbers, :has_codes, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_HS6_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @has_codes = (x = opts.delete(:has_codes); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_codes', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationHs6ExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :has_codes => has_codes,
              :sort => sort
            }
          end

        end

        # Exports HS10 code overview details
        class HarmonizationOverviewExportType < ExportType

          attr_reader :origin, :destination, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::HARMONIZATION_OVERVIEW_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : HttpClient::Preconditions.assert_class('origin', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : HttpClient::Preconditions.assert_class('destination', x, String))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationOverviewExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :origin => origin,
              :destination => destination,
              :sort => sort
            }
          end

        end

        # Organization level settings.
        class HarmonizationSettings

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = (x = opts.delete(:duty_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
            @tax_strategy = (x = (x = opts.delete(:tax_strategy); x.nil? ? "maximum" : x); x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.value,
              :tax_strategy => tax_strategy.value
            }
          end

        end

        class HarmonizationSettingsForm

          attr_reader :duty_strategy, :tax_strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @duty_strategy = (x = opts.delete(:duty_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
            @tax_strategy = (x = opts.delete(:tax_strategy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LevyStrategy) ? x : ::Io::Flow::V0::Models::LevyStrategy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizationSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :duty_strategy => duty_strategy.nil? ? nil : duty_strategy.value,
              :tax_strategy => tax_strategy.nil? ? nil : tax_strategy.value
            }
          end

        end

        # Categories optimized for harmonization
        class HarmonizedCategory

          attr_reader :id, :name, :parent

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'HarmonizedCategory')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::HarmonizedCategoryReference) ? x : ::Io::Flow::V0::Models::HarmonizedCategoryReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedCategory.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :parent => parent.nil? ? nil : parent.to_hash
            }
          end

        end

        class HarmonizedCategoryReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'HarmonizedCategoryReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedCategoryReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # A harmonized item stores explicit information about this item for the purposes
        # of harmonization / classification. The harmonization process begins by
        # creating a harmonized item; this kicks off the internal processes. Once
        # assigned, codes will be available via the hs6 and hs10 resources
        class HarmonizedItem

          attr_reader :id, :number, :name, :categories, :attributes, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :name], 'HarmonizedItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :name => name,
              :categories => categories,
              :attributes => attributes,
              :description => description
            }
          end

        end

        class HarmonizedItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number

          def initialize(incoming={})
            super(:discriminator => Event::Types::HARMONIZED_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number], 'HarmonizedItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number
            }
          end

        end

        # Used to specifically set an item's duty rate for a given trade lane.
        class HarmonizedItemDuty

          attr_reader :id, :item, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :rate], 'HarmonizedItemDuty')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDuty.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyForm

          attr_reader :number, :origin, :destination, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :origin, :destination, :rate], 'HarmonizedItemDutyForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :origin => origin,
              :destination => destination,
              :rate => rate
            }
          end

        end

        class HarmonizedItemDutyVersion

          attr_reader :id, :timestamp, :type, :harmonized_item_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item_duty], 'HarmonizedItemDutyVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item_duty = (x = opts.delete(:harmonized_item_duty); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemDuty) ? x : ::Io::Flow::V0::Models::HarmonizedItemDuty.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemDutyVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item_duty => harmonized_item_duty.to_hash
            }
          end

        end

        class HarmonizedItemForm

          attr_reader :name, :number, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :number], 'HarmonizedItemForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :number => number,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemPutForm

          attr_reader :name, :categories, :description, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name], 'HarmonizedItemPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class HarmonizedItemReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'HarmonizedItemReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class HarmonizedItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :name, :categories, :attributes, :description

          def initialize(incoming={})
            super(:discriminator => Event::Types::HARMONIZED_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :name, :categories, :attributes], 'HarmonizedItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :name => name,
              :categories => categories,
              :attributes => attributes,
              :description => description
            }
          end

        end

        class HarmonizedItemVersion

          attr_reader :id, :timestamp, :type, :harmonized_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :harmonized_item], 'HarmonizedItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @harmonized_item = (x = opts.delete(:harmonized_item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItem) ? x : ::Io::Flow::V0::Models::HarmonizedItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :harmonized_item => harmonized_item.to_hash
            }
          end

        end

        # Summary of landed cost data (taxes and duties) for 1 or more items going to a
        # single destination country. Records are unique based on (item.number, country
        # of origin).
        class HarmonizedLandedCost

          attr_reader :address, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :items], 'HarmonizedLandedCost')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::HarmonizedLandedCostItem) ? x : ::Io::Flow::V0::Models::HarmonizedLandedCostItem.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCost.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        # Allows calculation of duty and tax for multiple items in one API call for
        # items going to a specific destination country
        class HarmonizedLandedCostForm

          attr_reader :address, :item_numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:address, :item_numbers], 'HarmonizedLandedCostForm')
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @item_numbers = HttpClient::Preconditions.assert_class('item_numbers', opts.delete(:item_numbers), Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :address => address.to_hash,
              :item_numbers => item_numbers
            }
          end

        end

        # Duty and tax information for a given item. Note that the internal
        # implementation supports multiple countries of origin.
        class HarmonizedLandedCostItem

          attr_reader :item, :duty, :tax

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item, :duty, :tax], 'HarmonizedLandedCostItem')
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x))
            @tax = (x = opts.delete(:tax); x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HarmonizedLandedCostItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item => item.to_hash,
              :duty => duty.to_hash,
              :tax => tax.to_hash
            }
          end

        end

        class Header

          attr_reader :name, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :value], 'Header')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Header.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :value => value
            }
          end

        end

        class Healthcheck

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'Healthcheck')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # The (Harmonized System) HS-10 code assigned to an item with a given
        # origin/destination pair.
        class Hs10

          attr_reader :id, :item, :origin, :destination, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :origin, :destination, :code], 'Hs10')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        # Event raised whenever an HS-10 code is unassigned from an item
        class Hs10CodeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin, :destination

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS10_CODE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin, :destination], 'Hs10CodeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10CodeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin,
              :destination => destination
            }
          end

        end

        # Event raised whenever an HS-10 code is assigned to an item
        class Hs10CodeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin, :destination, :code

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS10_CODE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin, :destination, :code], 'Hs10CodeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
            @destination = HttpClient::Preconditions.assert_class('destination', opts.delete(:destination), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10CodeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin,
              :destination => destination,
              :code => code
            }
          end

        end

        class Hs10Version

          attr_reader :id, :timestamp, :type, :hs10

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs10], 'Hs10Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs10 = (x = opts.delete(:hs10); x.is_a?(::Io::Flow::V0::Models::Hs10) ? x : ::Io::Flow::V0::Models::Hs10.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs10Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs10 => hs10.to_hash
            }
          end

        end

        # The (Harmonized System) HS-6 code assigned to an item.
        class Hs6

          attr_reader :id, :item, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :code], 'Hs6')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::HarmonizedItemReference) ? x : ::Io::Flow::V0::Models::HarmonizedItemReference.new(x))
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :code => code
            }
          end

        end

        # Event raised whenever an HS-6 code is deleted
        class Hs6CodeDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS6_CODE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number], 'Hs6CodeDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6CodeDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number
            }
          end

        end

        # Event raised whenever an HS-6 code is assigned to an item
        class Hs6CodeUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :code

          def initialize(incoming={})
            super(:discriminator => Event::Types::HS6_CODE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :code], 'Hs6CodeUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6CodeUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :code => code
            }
          end

        end

        class Hs6Version

          attr_reader :id, :timestamp, :type, :hs6

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :hs6], 'Hs6Version')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @hs6 = (x = opts.delete(:hs6); x.is_a?(::Io::Flow::V0::Models::Hs6) ? x : ::Io::Flow::V0::Models::Hs6.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Hs6Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :hs6 => hs6.to_hash
            }
          end

        end

        # Harmonized System codes.
        class HsCode

          attr_reader :code, :parent, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code], 'HsCode')
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @parent = (x = opts.delete(:parent); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent', x, String))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            HsCode.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :parent => parent,
              :description => description
            }
          end

        end

        # The URL to an image, with optional tags. Flow Commerce primarily uses images
        # to enhance the administrative tools (e.g. showing an item image in console)
        class Image

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'Image')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = HttpClient::Preconditions.assert_class('tags', (x = opts.delete(:tags); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Image.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags
            }
          end

        end

        # Image form defines the data needed to create an image
        class ImageForm

          attr_reader :url, :tags

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url], 'ImageForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @tags = (x = opts.delete(:tags); x.nil? ? nil : HttpClient::Preconditions.assert_class('tags', x, Array).map { |v| HttpClient::Preconditions.assert_class('tags', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImageForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :tags => tags.nil? ? nil : tags
            }
          end

        end

        # Imports allow you to upload data to Flow via files in batch. Each import
        # fetches data from a given URL. The type of the import determines which file
        # format to expect and what data to update
        class Import

          attr_reader :id, :type, :source_url, :status, :created_at, :started_at, :completed_at, :results, :deliveries

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :source_url, :status, :created_at, :deliveries], 'Import')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::ExportStatus) ? x : ::Io::Flow::V0::Models::ExportStatus.apply(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @results = (x = opts.delete(:results); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ImportResults) ? x : ::Io::Flow::V0::Models::ImportResults.new(x)))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportDelivery) ? x : ::Io::Flow::V0::Models::ExportDelivery.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Import.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :source_url => source_url,
              :status => status.value,
              :created_at => created_at,
              :started_at => started_at,
              :completed_at => completed_at,
              :results => results.nil? ? nil : results.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash }
            }
          end

        end

        # Import forms create imports. The import type defines both the type of the
        # import (e.g. the CSV File format) and the URL at which the source data are
        # available. If you do not have a URL readily available, you can first upload a
        # file via the Flow API - see the resource named 'Upload'
        class ImportForm

          attr_reader :type, :source_url, :emails

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :source_url], 'ImportForm')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ImportType) ? x : ::Io::Flow::V0::Models::ImportType.apply(x))
            @source_url = HttpClient::Preconditions.assert_class('source_url', opts.delete(:source_url), String)
            @emails = (x = opts.delete(:emails); x.nil? ? nil : HttpClient::Preconditions.assert_class('emails', x, Array).map { |v| HttpClient::Preconditions.assert_class('emails', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :source_url => source_url,
              :emails => emails.nil? ? nil : emails
            }
          end

        end

        class ImportResults

          attr_reader :number_successful, :number_errors, :url

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number_successful, :number_errors], 'ImportResults')
            @number_successful = HttpClient::Preconditions.assert_class('number_successful', opts.delete(:number_successful), Integer)
            @number_errors = HttpClient::Preconditions.assert_class('number_errors', opts.delete(:number_errors), Integer)
            @url = (x = opts.delete(:url); x.nil? ? nil : HttpClient::Preconditions.assert_class('url', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportResults.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number_successful => number_successful,
              :number_errors => number_errors,
              :url => url
            }
          end

        end

        class ImportVersion

          attr_reader :id, :timestamp, :type, :import

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :import], 'ImportVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @import = (x = opts.delete(:import); x.is_a?(::Io::Flow::V0::Models::Import) ? x : ::Io::Flow::V0::Models::Import.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ImportVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :import => import.to_hash
            }
          end

        end

        class IncludedLevies

          attr_reader :key, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :label], 'IncludedLevies')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::IncludedLevyKey) ? x : ::Io::Flow::V0::Models::IncludedLevyKey.apply(x))
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IncludedLevies.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :label => label
            }
          end

        end

        # Describe a feed incoming to Flow
        class IncomingFeed

          attr_reader :url, :format, :minute, :item_link

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :format, :item_link], 'IncomingFeed')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @format = (x = opts.delete(:format); x.is_a?(::Io::Flow::V0::Models::IncomingFeedFormat) ? x : ::Io::Flow::V0::Models::IncomingFeedFormat.apply(x))
            @minute = HttpClient::Preconditions.assert_class('minute', (x = opts.delete(:minute); x.nil? ? 55 : x), Integer)
            @item_link = (x = opts.delete(:item_link); x.is_a?(::Io::Flow::V0::Models::ItemLink) ? x : ::Io::Flow::V0::Models::ItemLink.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            IncomingFeed.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :format => format.value,
              :minute => minute,
              :item_link => item_link.to_hash
            }
          end

        end

        # Enables backorders, setting an optional number of units that we allow for
        # backorder. For example, a backorder w/ quantity 10 will enable selling until
        # the actual inventory quantity is -10.
        class InventoryBackorder < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_BACKORDER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryBackorder')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryBackorder.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        class InventoryCenterReference

          attr_reader :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key], 'InventoryCenterReference')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryCenterReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key
            }
          end

        end

        class InventoryItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'InventoryItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        # Ordered list of rules to apply, from first to last, to get available quantity.
        # This is unique per organization
        class InventoryRule

          attr_reader :id, :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :strategy], 'InventoryRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleForm

          attr_reader :position, :query, :strategy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:position, :query, :strategy], 'InventoryRuleForm')
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::InventoryStrategy) ? x : ::Io::Flow::V0::Models::InventoryStrategy.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :strategy => strategy.to_hash
            }
          end

        end

        class InventoryRuleVersion

          attr_reader :id, :timestamp, :type, :inventory_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_rule], 'InventoryRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_rule = (x = opts.delete(:inventory_rule); x.is_a?(::Io::Flow::V0::Models::InventoryRule) ? x : ::Io::Flow::V0::Models::InventoryRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_rule => inventory_rule.to_hash
            }
          end

        end

        # Inventory snapshot reflects the current quantity and available number of units
        # for a given center / item
        class InventorySnapshot

          attr_reader :id, :available, :center, :item, :quantity

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :available, :center, :item, :quantity], 'InventorySnapshot')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshot.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :available => available,
              :center => center.to_hash,
              :item => item.to_hash,
              :quantity => quantity
            }
          end

        end

        class InventorySnapshotVersion

          attr_reader :id, :timestamp, :type, :inventory_snapshot

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_snapshot], 'InventorySnapshotVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_snapshot = (x = opts.delete(:inventory_snapshot); x.is_a?(::Io::Flow::V0::Models::InventorySnapshot) ? x : ::Io::Flow::V0::Models::InventorySnapshot.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventorySnapshotVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_snapshot => inventory_snapshot.to_hash
            }
          end

        end

        # Treats inventory as available as long as the actual inventory quantity is >
        # the specified quantity. A common use case is to set quantity to zero to
        # indicate availability as long as there is at least 1 unit available.
        class InventoryStock < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_STOCK)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:quantity], 'InventoryStock')
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryStock.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Items affected with rules pursuing an unlimited strategy will always be
        # available
        class InventoryUnlimited < InventoryStrategy

          attr_reader :quantity

          def initialize(incoming={})
            super(:discriminator => InventoryStrategy::Types::INVENTORY_UNLIMITED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @quantity = HttpClient::Preconditions.assert_class('quantity', (x = opts.delete(:quantity); x.nil? ? "unlimited" : x), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUnlimited.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :quantity => quantity
            }
          end

        end

        # Represents a single update on inventory quantity
        class InventoryUpdate

          attr_reader :id, :idempotency_key, :center, :item, :notes, :quantity, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :idempotency_key, :center, :item, :notes, :quantity, :type], 'InventoryUpdate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @center = (x = opts.delete(:center); x.is_a?(::Io::Flow::V0::Models::InventoryCenterReference) ? x : ::Io::Flow::V0::Models::InventoryCenterReference.new(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::InventoryItemReference) ? x : ::Io::Flow::V0::Models::InventoryItemReference.new(x))
            @notes = HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(opts.delete(:notes)), Hash)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :idempotency_key => idempotency_key,
              :center => center.to_hash,
              :item => item.to_hash,
              :notes => notes,
              :quantity => quantity,
              :type => type.value
            }
          end

        end

        # Form used to create an update on inventory. If inventory for center/item has
        # not been previously created, a new row is created for the center/item tuple.
        class InventoryUpdateForm

          attr_reader :center, :idempotency_key, :item_number, :quantity, :type, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:center, :idempotency_key, :item_number, :quantity, :type], 'InventoryUpdateForm')
            @center = HttpClient::Preconditions.assert_class('center', opts.delete(:center), String)
            @idempotency_key = HttpClient::Preconditions.assert_class('idempotency_key', opts.delete(:idempotency_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::UpdateType) ? x : ::Io::Flow::V0::Models::UpdateType.apply(x))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :center => center,
              :idempotency_key => idempotency_key,
              :item_number => item_number,
              :quantity => quantity,
              :type => type.value,
              :notes => notes
            }
          end

        end

        class InventoryUpdateVersion

          attr_reader :id, :timestamp, :type, :inventory_update

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :inventory_update], 'InventoryUpdateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @inventory_update = (x = opts.delete(:inventory_update); x.is_a?(::Io::Flow::V0::Models::InventoryUpdate) ? x : ::Io::Flow::V0::Models::InventoryUpdate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InventoryUpdateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :inventory_update => inventory_update.to_hash
            }
          end

        end

        # An invitation via email to a user to join this organization. The user will
        # then walk through a user login/registration process and will immediately
        # become a member of the organization.
        class Invitation

          attr_reader :id, :organization, :email, :name, :role, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :email, :name, :role, :expiration], 'Invitation')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Invitation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :email => email,
              :name => name.to_hash,
              :role => role.value,
              :expiration => expiration
            }
          end

        end

        # Returns information as to why a particular invitation could not be accepted.
        class InvitationError

          attr_reader :code, :messages

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'InvitationError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::InvitationErrorCode) ? x : ::Io::Flow::V0::Models::InvitationErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages
            }
          end

        end

        class InvitationForm

          attr_reader :organization, :email, :name, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :email], 'InvitationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x)))
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :email => email,
              :name => name.nil? ? nil : name.to_hash,
              :role => role.value
            }
          end

        end

        class InvitationVersion

          attr_reader :id, :timestamp, :type, :invitation

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :invitation], 'InvitationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @invitation = (x = opts.delete(:invitation); x.is_a?(::Io::Flow::V0::Models::Invitation) ? x : ::Io::Flow::V0::Models::Invitation.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            InvitationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :invitation => invitation.to_hash
            }
          end

        end

        # The Flow item defines a specific item that can be purchased by a consumer. For
        # many clients, this will map to a Sku.
        class Item

          attr_reader :id, :number, :locale, :name, :price, :categories, :description, :attributes, :dimensions, :images, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :locale, :name, :price, :dimensions], 'Item')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @categories = HttpClient::Preconditions.assert_class('categories', (x = opts.delete(:categories); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @images = HttpClient::Preconditions.assert_class('images', (x = opts.delete(:images); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Image) ? x : ::Io::Flow::V0::Models::Image.new(x)) }
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :locale => locale,
              :name => name,
              :price => price.to_hash,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions.to_hash,
              :images => images.map { |o| o.to_hash },
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # The item form defines the data required to create an item.
        class ItemForm

          attr_reader :number, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :locale, :name, :currency, :price], 'ItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = (x = opts.delete(:categories); x.nil? ? nil : HttpClient::Preconditions.assert_class('categories', x, Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) })
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @dimensions = (x = opts.delete(:dimensions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x)))
            @images = (x = opts.delete(:images); x.nil? ? nil : HttpClient::Preconditions.assert_class('images', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ImageForm) ? x : ::Io::Flow::V0::Models::ImageForm.new(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories.nil? ? nil : categories,
              :description => description,
              :attributes => attributes.nil? ? nil : attributes,
              :dimensions => dimensions.nil? ? nil : dimensions.to_hash,
              :images => images.nil? ? nil : images.map { |o| o.to_hash }
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunction < ExpandableItemFunction

          attr_reader :id, :key, :description, :code

          def initialize(incoming={})
            super(:discriminator => ExpandableItemFunction::Types::ITEM_FUNCTION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :description, :code], 'ItemFunction')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunction.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :description => description,
              :code => code
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunctionPostForm

          attr_reader :description, :code, :key

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:description, :code], 'ItemFunctionPostForm')
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionPostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description,
              :code => code,
              :key => key
            }
          end

        end

        # Item Functions are javascript code used to calculate the localized price of an
        # additional item. Each function can be associated with an optional query
        # identifying the products to which the function applies. Flow selects the first
        # function matching an item, then uses that function to calculate local prices
        # whenever any data relevant to the item changes (e.g. on update in master
        # catalog, on change in relevant exchange rate, etc.). Item functions are
        # immutable once created.
        class ItemFunctionPutForm

          attr_reader :description, :code

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:description, :code], 'ItemFunctionPutForm')
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :description => description,
              :code => code
            }
          end

        end

        class ItemFunctionReference < ExpandableItemFunction

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableItemFunction::Types::ITEM_FUNCTION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ItemFunctionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class ItemFunctionVersion

          attr_reader :id, :timestamp, :type, :item_function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item_function], 'ItemFunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item_function = (x = opts.delete(:item_function); x.is_a?(::Io::Flow::V0::Models::ItemFunction) ? x : ::Io::Flow::V0::Models::ItemFunction.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemFunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item_function => item_function.to_hash
            }
          end

        end

        # Describes how items from an incoming feed will link with localized items in a
        # Flow catalog to create an outgoing feed.
        class ItemLink

          attr_reader :incoming_field_name, :flow_field_name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:incoming_field_name, :flow_field_name], 'ItemLink')
            @incoming_field_name = (x = opts.delete(:incoming_field_name); x.is_a?(::Io::Flow::V0::Models::IncomingFieldName) ? x : ::Io::Flow::V0::Models::IncomingFieldName.apply(x))
            @flow_field_name = (x = opts.delete(:flow_field_name); x.is_a?(::Io::Flow::V0::Models::FlowFieldName) ? x : ::Io::Flow::V0::Models::FlowFieldName.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemLink.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :incoming_field_name => incoming_field_name.value,
              :flow_field_name => flow_field_name.value
            }
          end

        end

        # Defines a fixed and percent margin to apply to items matching a query.
        class ItemMargin

          attr_reader :id, :key, :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :name, :q, :fixed, :percent, :position], 'ItemMargin')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMargin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :name => name,
              :q => q,
              :fixed => fixed,
              :percent => percent,
              :position => position
            }
          end

        end

        class ItemMarginDeleted < Event

          attr_reader :event_id, :timestamp, :item_margin_id, :organization_id, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_MARGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_margin_id, :organization_id, :experience_key], 'ItemMarginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_margin_id = HttpClient::Preconditions.assert_class('item_margin_id', opts.delete(:item_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_margin_id => item_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key
            }
          end

        end

        # A percent and/or fixed margin to apply to items based on query.
        class ItemMarginPostForm

          attr_reader :name, :q, :key, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :q], 'ItemMarginPostForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @fixed = (x = opts.delete(:fixed); x.nil? ? nil : HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @percent = (x = opts.delete(:percent); x.nil? ? nil : HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginPostForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :q => q,
              :key => key,
              :fixed => fixed,
              :percent => percent,
              :position => position
            }
          end

        end

        # A percent and/or fixed margin to apply to items based on query.
        class ItemMarginPutForm

          attr_reader :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :q], 'ItemMarginPutForm')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = (x = opts.delete(:fixed); x.nil? ? nil : HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @percent = (x = opts.delete(:percent); x.nil? ? nil : HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :q => q,
              :fixed => fixed,
              :percent => percent,
              :position => position
            }
          end

        end

        class ItemMarginUpserted < Event

          attr_reader :event_id, :timestamp, :item_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position, :key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_MARGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position], 'ItemMarginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_margin_id = HttpClient::Preconditions.assert_class('item_margin_id', opts.delete(:item_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_margin_id => item_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key,
              :name => name,
              :q => q,
              :fixed => fixed,
              :percent => percent,
              :position => position,
              :key => key
            }
          end

        end

        class ItemMarginVersion

          attr_reader :id, :timestamp, :type, :item_margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item_margin], 'ItemMarginVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item_margin = (x = opts.delete(:item_margin); x.is_a?(::Io::Flow::V0::Models::ItemMargin) ? x : ::Io::Flow::V0::Models::ItemMargin.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemMarginVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item_margin => item_margin.to_hash
            }
          end

        end

        class ItemOriginDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_ORIGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin], 'ItemOriginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemOriginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin
            }
          end

        end

        # Event raised whenever an item is assigned a country of origin. Note that one
        # item may have multiple countries of origin.
        class ItemOriginUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_ORIGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :origin], 'ItemOriginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @origin = HttpClient::Preconditions.assert_class('origin', opts.delete(:origin), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemOriginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :origin => origin
            }
          end

        end

        class ItemSalesMarginDeleted < Event

          attr_reader :event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_SALES_MARGIN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key], 'ItemSalesMarginDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_sales_margin_id = HttpClient::Preconditions.assert_class('item_sales_margin_id', opts.delete(:item_sales_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSalesMarginDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_sales_margin_id => item_sales_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key
            }
          end

        end

        class ItemSalesMarginUpserted < Event

          attr_reader :event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position

          def initialize(incoming={})
            super(:discriminator => Event::Types::ITEM_SALES_MARGIN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :item_sales_margin_id, :organization_id, :experience_key, :name, :q, :fixed, :percent, :position], 'ItemSalesMarginUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @item_sales_margin_id = HttpClient::Preconditions.assert_class('item_sales_margin_id', opts.delete(:item_sales_margin_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @fixed = HttpClient::Preconditions.assert_class('fixed', HttpClient::Helper.to_big_decimal(opts.delete(:fixed)), BigDecimal)
            @percent = HttpClient::Preconditions.assert_class('percent', HttpClient::Helper.to_big_decimal(opts.delete(:percent)), BigDecimal)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemSalesMarginUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :item_sales_margin_id => item_sales_margin_id,
              :organization_id => organization_id,
              :experience_key => experience_key,
              :name => name,
              :q => q,
              :fixed => fixed,
              :percent => percent,
              :position => position
            }
          end

        end

        # Statistics covering product catalog item information, including total catalog
        # item count, number of distinct categories, etc.
        class ItemStatistics

          attr_reader :items, :categories

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items, :categories], 'ItemStatistics')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Integer)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items,
              :categories => categories
            }
          end

        end

        class ItemVersion

          attr_reader :id, :timestamp, :type, :item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :item], 'ItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :item => item.to_hash
            }
          end

        end

        # The jsonp_response defines the schema for all Flow APIs calls made over JSONP,
        # providing access to the specific response status, headers, and body from the
        # underlying service.  See https://docs.flow.io/#jsonp for details
        class JsonpResponse

          attr_reader :status, :headers, :body

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status, :headers, :body], 'JsonpResponse')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), Integer)
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('headers', d[1], Array).map { |v| HttpClient::Preconditions.assert_class('headers', v, String) }; h }
            @body = HttpClient::Preconditions.assert_class('body', HttpClient::Helper.to_object(opts.delete(:body)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            JsonpResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status,
              :headers => headers.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1]; hash },
              :body => body
            }
          end

        end

        class LabelFormatDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_FORMAT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'LabelFormatDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelFormatDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class LabelFormatUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :format

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_FORMAT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :format], 'LabelFormatUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @format = HttpClient::Preconditions.assert_class('format', opts.delete(:format), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelFormatUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :format => format
            }
          end

        end

        class LabelOrderSummary

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'LabelOrderSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class LabelUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :label_id, :carrier_tracking_number, :commercial_invoice, :flow_tracking_number, :destination, :origin, :carrier, :service, :zpl, :pdf, :png, :order, :carrier_tracking_number_url, :flow_tracking_number_url

          def initialize(incoming={})
            super(:discriminator => Event::Types::LABEL_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :label_id, :carrier_tracking_number, :commercial_invoice, :flow_tracking_number, :destination, :origin, :carrier, :service], 'LabelUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @label_id = HttpClient::Preconditions.assert_class('label_id', opts.delete(:label_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @commercial_invoice = HttpClient::Preconditions.assert_class('commercial_invoice', opts.delete(:commercial_invoice), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(opts.delete(:destination)), Hash)
            @origin = HttpClient::Preconditions.assert_class('origin', HttpClient::Helper.to_object(opts.delete(:origin)), Hash)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @png = (x = opts.delete(:png); x.nil? ? nil : HttpClient::Preconditions.assert_class('png', x, String))
            @order = (x = opts.delete(:order); x.nil? ? nil : HttpClient::Preconditions.assert_class('order', x, String))
            @carrier_tracking_number_url = (x = opts.delete(:carrier_tracking_number_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('carrier_tracking_number_url', x, String))
            @flow_tracking_number_url = (x = opts.delete(:flow_tracking_number_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('flow_tracking_number_url', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LabelUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :label_id => label_id,
              :carrier_tracking_number => carrier_tracking_number,
              :commercial_invoice => commercial_invoice,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination,
              :origin => origin,
              :carrier => carrier,
              :service => service,
              :zpl => zpl,
              :pdf => pdf,
              :png => png,
              :order => order,
              :carrier_tracking_number_url => carrier_tracking_number_url,
              :flow_tracking_number_url => flow_tracking_number_url
            }
          end

        end

        # ISO 639 2-character language code. See https://api.flow.io/reference/languages
        class Language

          attr_reader :name, :iso_639_2

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :iso_639_2], 'Language')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @iso_639_2 = HttpClient::Preconditions.assert_class('iso_639_2', opts.delete(:iso_639_2), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Language.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :iso_639_2 => iso_639_2
            }
          end

        end

        # Provides display data for a line item.
        class Line

          attr_reader :item_number, :quantity, :price, :total

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity, :price, :total], 'Line')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::PriceWithBase) ? x : ::Io::Flow::V0::Models::PriceWithBase.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Line.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :quantity => quantity,
              :price => price.to_hash,
              :total => total.to_hash
            }
          end

        end

        # Line items represent the items a consumer is purchasing, including additional
        # information to complete the transaction. Note that you may pass in as many
        # line items as you like - including repeating item numbers across line items.
        class LineItem

          attr_reader :number, :quantity, :price, :attributes, :center, :discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity, :price, :attributes], 'LineItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :price => price.to_hash,
              :attributes => attributes,
              :center => center,
              :discount => discount.nil? ? nil : discount.to_hash
            }
          end

        end

        # Line items represent the items a consumer is purchasing, including additional
        # information to complete the transaction. Note that you may pass in as many
        # line items as you like - including repeating item numbers across line items.
        class LineItemForm

          attr_reader :number, :quantity, :price, :attributes, :center, :discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :quantity], 'LineItemForm')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LineItemForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :quantity => quantity,
              :price => price.nil? ? nil : price.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :center => center,
              :discount => discount.nil? ? nil : discount.to_hash
            }
          end

        end

        class Local

          attr_reader :experience, :prices, :rates, :spot_rates, :status, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:experience, :prices, :rates, :spot_rates], 'Local')
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceSummary) ? x : ::Io::Flow::V0::Models::ExperienceSummary.new(x))
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedPrice) ? x : ::Io::Flow::V0::Models::LocalizedPrice.from_json(x)) }
            @rates = HttpClient::Preconditions.assert_class('rates', opts.delete(:rates), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x)) }
            @spot_rates = HttpClient::Preconditions.assert_class('spot_rates', opts.delete(:spot_rates), Array).map { |v| HttpClient::Preconditions.assert_class('spot_rates', HttpClient::Helper.to_object(v), Hash) }
            @status = (x = (x = opts.delete(:status); x.nil? ? "included" : x); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', HttpClient::Helper.to_object(x), Hash))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Local.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :experience => experience.to_hash,
              :prices => prices.map { |o| o.to_hash },
              :rates => rates.map { |o| o.to_hash },
              :spot_rates => spot_rates,
              :status => status.value,
              :attributes => attributes
            }
          end

        end

        class LocalPriceDetails

          attr_reader :base, :local, :discount, :local_before_discount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :local], 'LocalPriceDetails')
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::PriceDetails) ? x : ::Io::Flow::V0::Models::PriceDetails.new(x))
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::PriceDetails) ? x : ::Io::Flow::V0::Models::PriceDetails.new(x))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
            @local_before_discount = (x = opts.delete(:local_before_discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalPriceDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base.to_hash,
              :local => local.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :local_before_discount => local_before_discount.nil? ? nil : local_before_discount.to_hash
            }
          end

        end

        # If we found an experience for the given session, the localized information
        # will be presented here
        class LocalSession

          attr_reader :country, :currency, :language, :locale, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:country, :currency, :language, :locale, :experience], 'LocalSession')
            @country = (x = opts.delete(:country); x.is_a?(::Io::Flow::V0::Models::Country) ? x : ::Io::Flow::V0::Models::Country.new(x))
            @currency = (x = opts.delete(:currency); x.is_a?(::Io::Flow::V0::Models::Currency) ? x : ::Io::Flow::V0::Models::Currency.new(x))
            @language = (x = opts.delete(:language); x.is_a?(::Io::Flow::V0::Models::Language) ? x : ::Io::Flow::V0::Models::Language.new(x))
            @locale = (x = opts.delete(:locale); x.is_a?(::Io::Flow::V0::Models::Locale) ? x : ::Io::Flow::V0::Models::Locale.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::ExperienceGeo) ? x : ::Io::Flow::V0::Models::ExperienceGeo.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalSession.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :country => country.to_hash,
              :currency => currency.to_hash,
              :language => language.to_hash,
              :locale => locale.to_hash,
              :experience => experience.to_hash
            }
          end

        end

        # Locales defines standard conventions for presentation of content. See
        # https://api.flow.io/reference/locales
        class Locale

          attr_reader :id, :name, :country, :language, :numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :country, :language, :numbers], 'Locale')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @language = HttpClient::Preconditions.assert_class('language', opts.delete(:language), String)
            @numbers = (x = opts.delete(:numbers); x.is_a?(::Io::Flow::V0::Models::LocaleNumbers) ? x : ::Io::Flow::V0::Models::LocaleNumbers.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Locale.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :country => country,
              :language => language,
              :numbers => numbers.to_hash
            }
          end

        end

        # Number formats defined for a given locale
        class LocaleNumbers

          attr_reader :decimal, :group

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:decimal, :group], 'LocaleNumbers')
            @decimal = HttpClient::Preconditions.assert_class('decimal', opts.delete(:decimal), String)
            @group = HttpClient::Preconditions.assert_class('group', opts.delete(:group), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocaleNumbers.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :decimal => decimal,
              :group => group
            }
          end

        end

        class LocalizedAdjustment

          attr_reader :currency, :amount, :label, :base, :reason

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base, :reason], 'LocalizedAdjustment')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @reason = (x = opts.delete(:reason); x.is_a?(::Io::Flow::V0::Models::AdjustmentReason) ? x : ::Io::Flow::V0::Models::AdjustmentReason.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedAdjustment.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :reason => reason.to_hash
            }
          end

        end

        class LocalizedItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog

          def initialize(incoming={})
            super(:discriminator => Event::Types::LOCALIZED_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog], 'LocalizedItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog
            }
          end

        end

        class LocalizedItemDuty < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :adjustment

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_DUTY)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedItemDuty')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedAdjustment) ? x : ::Io::Flow::V0::Models::LocalizedAdjustment.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemDuty.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash
            }
          end

        end

        class LocalizedItemPrice < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :includes

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_PRICE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedItemPrice')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @includes = (x = opts.delete(:includes); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::IncludedLevies) ? x : ::Io::Flow::V0::Models::IncludedLevies.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemPrice.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :includes => includes.nil? ? nil : includes.to_hash
            }
          end

        end

        class LocalizedItemSnapshot < Event

          attr_reader :event_id, :timestamp, :organization, :subcatalog_id, :url

          def initialize(incoming={})
            super(:discriminator => Event::Types::LOCALIZED_ITEM_SNAPSHOT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :subcatalog_id, :url], 'LocalizedItemSnapshot')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemSnapshot.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :subcatalog_id => subcatalog_id,
              :url => url
            }
          end

        end

        class LocalizedItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :description, :attributes, :dimensions, :images, :local

          def initialize(incoming={})
            super(:discriminator => Event::Types::LOCALIZED_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :locale, :name, :currency, :price, :categories, :attributes, :dimensions, :images, :local], 'LocalizedItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @locale = HttpClient::Preconditions.assert_class('locale', opts.delete(:locale), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @price = HttpClient::Preconditions.assert_class('price', opts.delete(:price), Numeric)
            @categories = HttpClient::Preconditions.assert_class('categories', opts.delete(:categories), Array).map { |v| HttpClient::Preconditions.assert_class('categories', v, String) }
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @dimensions = HttpClient::Preconditions.assert_class('dimensions', HttpClient::Helper.to_object(opts.delete(:dimensions)), Hash)
            @images = HttpClient::Preconditions.assert_class('images', opts.delete(:images), Array).map { |v| HttpClient::Preconditions.assert_class('images', HttpClient::Helper.to_object(v), Hash) }
            @local = HttpClient::Preconditions.assert_class('local', HttpClient::Helper.to_object(opts.delete(:local)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :locale => locale,
              :name => name,
              :currency => currency,
              :price => price,
              :categories => categories,
              :description => description,
              :attributes => attributes,
              :dimensions => dimensions,
              :images => images,
              :local => local
            }
          end

        end

        class LocalizedItemVat < LocalizedPrice

          attr_reader :currency, :amount, :label, :base, :name, :adjustment

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_ITEM_VAT)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base, :name], 'LocalizedItemVat')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalizedAdjustment) ? x : ::Io::Flow::V0::Models::LocalizedAdjustment.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedItemVat.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :name => name,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash
            }
          end

        end

        # Line items on the order, with localized pricing information
        class LocalizedLineItem

          attr_reader :number, :name, :quantity, :center, :price, :discount, :attributes, :local

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number, :name, :quantity, :local], 'LocalizedLineItem')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @center = (x = opts.delete(:center); x.nil? ? nil : HttpClient::Preconditions.assert_class('center', x, String))
            @price = (x = opts.delete(:price); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @local = (x = opts.delete(:local); x.is_a?(::Io::Flow::V0::Models::Local) ? x : ::Io::Flow::V0::Models::Local.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number,
              :name => name,
              :quantity => quantity,
              :center => center,
              :price => price.nil? ? nil : price.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :local => local.to_hash
            }
          end

        end

        class LocalizedTotal < LocalizedPrice

          attr_reader :currency, :amount, :label, :base

          def initialize(incoming={})
            super(:key => LocalizedPrice::Types::LOCALIZED_TOTAL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label, :base], 'LocalizedTotal')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            LocalizedTotal.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash
            }
          end

        end

        class Margin

          attr_reader :type, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :value], 'Margin')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::MarginType) ? x : ::Io::Flow::V0::Models::MarginType.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Margin.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :value => value
            }
          end

        end

        class Measurement

          attr_reader :value, :units

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:value, :units], 'Measurement')
            @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            @units = (x = opts.delete(:units); x.is_a?(::Io::Flow::V0::Models::UnitOfMeasurement) ? x : ::Io::Flow::V0::Models::UnitOfMeasurement.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Measurement.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :value => value,
              :units => units.value
            }
          end

        end

        # Represents the users that are part of this organization. Primary purpose is to
        # manage which users have access to the organization's data and to provide a
        # simple user interface to assign roles and permissions to each member of the
        # organization
        class Membership

          attr_reader :id, :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :role], 'Membership')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::ExpandableOrganization) ? x : ::Io::Flow::V0::Models::ExpandableOrganization.from_json(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::ExpandableUser) ? x : ::Io::Flow::V0::Models::ExpandableUser.from_json(x))
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :role => role.value
            }
          end

        end

        class MembershipDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::MEMBERSHIP_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'MembershipDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipForm

          attr_reader :organization, :user, :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :user], 'MembershipForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user = HttpClient::Preconditions.assert_class('user', opts.delete(:user), String)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :user => user,
              :role => role.value
            }
          end

        end

        # Top level resource to create a membership.
        class MembershipPutForm

          attr_reader :role

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @role = (x = (x = opts.delete(:role); x.nil? ? "member" : x); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value
            }
          end

        end

        class MembershipUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :user_id, :role

          def initialize(incoming={})
            super(:discriminator => Event::Types::MEMBERSHIP_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :user_id, :role], 'MembershipUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
            @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :user_id => user_id,
              :role => role
            }
          end

        end

        class MembershipVersion

          attr_reader :id, :timestamp, :type, :membership

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :membership], 'MembershipVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @membership = (x = opts.delete(:membership); x.is_a?(::Io::Flow::V0::Models::Membership) ? x : ::Io::Flow::V0::Models::Membership.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MembershipVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :membership => membership.to_hash
            }
          end

        end

        # Creates an authorization for a transaction for which Flow is the merchant of
        # record. In this case, you must provide your order number for a valid Flow
        # order. An authorization is used to check and reserve funds w/ a given payment
        # method. No funds are actually transferred; once you have you an authorization,
        # you can capture up to the amount of the authorization
        class MerchantOfRecordAuthorizationForm < AuthorizationForm

          attr_reader :token, :order_number, :amount, :currency, :key, :cvv, :attributes, :ip, :options

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::MERCHANT_OF_RECORD_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :order_number], 'MerchantOfRecordAuthorizationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @cvv = (x = opts.delete(:cvv); x.nil? ? nil : HttpClient::Preconditions.assert_class('cvv', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @options = (x = opts.delete(:options); x.nil? ? nil : HttpClient::Preconditions.assert_class('options', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::AuthorizationOption) ? x : ::Io::Flow::V0::Models::AuthorizationOption.apply(x)) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :token => token,
              :order_number => order_number,
              :amount => amount,
              :currency => currency,
              :key => key,
              :cvv => cvv,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip,
              :options => options.nil? ? nil : options.map { |o| o.value }
            }
          end

        end

        # Creates an online payment
        class MerchantOfRecordPaymentForm < PaymentForm

          attr_reader :method, :order_number, :amount, :currency

          def initialize(incoming={})
            super(:discriminator => PaymentForm::Types::MERCHANT_OF_RECORD_PAYMENT_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:method, :order_number, :amount, :currency], 'MerchantOfRecordPaymentForm')
            @method = HttpClient::Preconditions.assert_class('method', opts.delete(:method), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            MerchantOfRecordPaymentForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :method => method,
              :order_number => order_number,
              :amount => amount,
              :currency => currency
            }
          end

        end

        # Money represents an amount in a given currency
        class Money

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'Money')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Money.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        class Name

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Name.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NameForm

          attr_reader :first, :last

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @first = (x = opts.delete(:first); x.nil? ? nil : HttpClient::Preconditions.assert_class('first', x, String))
            @last = (x = opts.delete(:last); x.nil? ? nil : HttpClient::Preconditions.assert_class('last', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NameForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :first => first,
              :last => last
            }
          end

        end

        class NotificationDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package

          def initialize(incoming={})
            super(:discriminator => Event::Types::NOTIFICATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package], 'NotificationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification_id = HttpClient::Preconditions.assert_class('notification_id', opts.delete(:notification_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(opts.delete(:destination)), Hash)
            @origin = HttpClient::Preconditions.assert_class('origin', HttpClient::Helper.to_object(opts.delete(:origin)), Hash)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @package = HttpClient::Preconditions.assert_class('package', HttpClient::Helper.to_object(opts.delete(:package)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NotificationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification_id => notification_id,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination,
              :origin => origin,
              :carrier => carrier,
              :service => service,
              :order => order,
              :package => package
            }
          end

        end

        class NotificationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package

          def initialize(incoming={})
            super(:discriminator => Event::Types::NOTIFICATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :notification_id, :carrier_tracking_number, :flow_tracking_number, :destination, :origin, :carrier, :service, :order, :package], 'NotificationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @notification_id = HttpClient::Preconditions.assert_class('notification_id', opts.delete(:notification_id), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @destination = HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(opts.delete(:destination)), Hash)
            @origin = HttpClient::Preconditions.assert_class('origin', HttpClient::Helper.to_object(opts.delete(:origin)), Hash)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @package = HttpClient::Preconditions.assert_class('package', HttpClient::Helper.to_object(opts.delete(:package)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NotificationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :notification_id => notification_id,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :destination => destination,
              :origin => origin,
              :carrier => carrier,
              :service => service,
              :order => order,
              :package => package
            }
          end

        end

        class NumberRange

          attr_reader :min, :max

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:min, :max], 'NumberRange')
            @min = HttpClient::Preconditions.assert_class('min', opts.delete(:min), Integer)
            @max = HttpClient::Preconditions.assert_class('max', opts.delete(:max), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            NumberRange.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :min => min,
              :max => max
            }
          end

        end

        class OnlineAuthorization < Authorization

          attr_reader :id, :key, :payment, :amount, :currency, :customer, :attributes, :destination, :order, :ip, :result, :created_at

          def initialize(incoming={})
            super(:discriminator => Authorization::Types::ONLINE_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :payment, :amount, :currency, :customer, :attributes, :result, :created_at], 'OnlineAuthorization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::ExpandablePayment) ? x : ::Io::Flow::V0::Models::ExpandablePayment.from_json(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x)))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @result = (x = opts.delete(:result); x.is_a?(::Io::Flow::V0::Models::AuthorizationResult) ? x : ::Io::Flow::V0::Models::AuthorizationResult.new(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :key => key,
              :payment => payment.to_hash,
              :amount => amount,
              :currency => currency,
              :customer => customer.to_hash,
              :attributes => attributes,
              :destination => destination.nil? ? nil : destination.to_hash,
              :order => order.nil? ? nil : order.to_hash,
              :ip => ip,
              :result => result.to_hash,
              :created_at => created_at
            }
          end

        end

        # Represents an authorization for a card payment method
        class OnlineAuthorizationUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ONLINE_AUTHORIZATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :authorization], 'OnlineAuthorizationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::OnlineAuthorization) ? x : ::Io::Flow::V0::Models::OnlineAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorizationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :authorization => authorization.to_hash
            }
          end

        end

        # Represents an authorization for a card payment method
        class OnlineAuthorizationUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :authorization

          def initialize(incoming={})
            super(:discriminator => Event::Types::ONLINE_AUTHORIZATION_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :authorization], 'OnlineAuthorizationUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::OnlineAuthorization) ? x : ::Io::Flow::V0::Models::OnlineAuthorization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OnlineAuthorizationUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :authorization => authorization.to_hash
            }
          end

        end

        class OptionWeightEstimates

          attr_reader :gravitational, :dimensional

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:gravitational, :dimensional], 'OptionWeightEstimates')
            @gravitational = (x = opts.delete(:gravitational); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
            @dimensional = (x = opts.delete(:dimensional); x.is_a?(::Io::Flow::V0::Models::Measurement) ? x : ::Io::Flow::V0::Models::Measurement.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OptionWeightEstimates.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :gravitational => gravitational.to_hash,
              :dimensional => dimensional.to_hash
            }
          end

        end

        # Flags to indicate whether a feature is enabled/disabled on a particular model
        # (e.g. show/do not show attribute as a column in harmonization table view of
        # items)
        class Options

          attr_reader :required, :show_in_catalog, :show_in_harmonization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @required = HttpClient::Preconditions.assert_boolean('required', (x = opts.delete(:required); x.nil? ? false : x))
            @show_in_catalog = HttpClient::Preconditions.assert_boolean('show_in_catalog', (x = opts.delete(:show_in_catalog); x.nil? ? false : x))
            @show_in_harmonization = HttpClient::Preconditions.assert_boolean('show_in_harmonization', (x = opts.delete(:show_in_harmonization); x.nil? ? false : x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Options.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :required => required,
              :show_in_catalog => show_in_catalog,
              :show_in_harmonization => show_in_harmonization
            }
          end

        end

        # An order represents all of the information about a particular line item,
        # including pricing, currency rates, delivery options, etc. All information in
        # an order is guaranteed by Flow - if an order is submitted before its
        # expiration. The intended use case is to create an order as a consumer enters
        # checkout, then to submit that order as part of the user submitting their
        # order. Note that Flow will automatically mark an order submitted if we see a
        # payment authorization for an order.
        class Order

          attr_reader :id, :number, :experience, :customer, :delivered_duty, :destination, :expires_at, :items, :deliveries, :selections, :prices, :total, :attributes, :submitted_at, :lines, :identifiers, :promotions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number, :customer, :delivered_duty, :destination, :expires_at, :items, :deliveries, :selections, :prices, :total, :attributes], 'Order')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @experience = (x = opts.delete(:experience); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableExperience) ? x : ::Io::Flow::V0::Models::ExpandableExperience.from_json(x)))
            @customer = (x = opts.delete(:customer); x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItem) ? x : ::Io::Flow::V0::Models::LocalizedLineItem.new(x)) }
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) })
            @identifiers = (x = opts.delete(:identifiers); x.nil? ? nil : HttpClient::Preconditions.assert_class('identifiers', x, Array).map { |v| HttpClient::Preconditions.assert_class('identifiers', v, String) })
            @promotions = (x = opts.delete(:promotions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Promotions) ? x : ::Io::Flow::V0::Models::Promotions.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Order.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number,
              :experience => experience.nil? ? nil : experience.to_hash,
              :customer => customer.to_hash,
              :delivered_duty => delivered_duty.value,
              :destination => destination.to_hash,
              :expires_at => expires_at,
              :items => items.map { |o| o.to_hash },
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections,
              :prices => prices.map { |o| o.to_hash },
              :total => total.to_hash,
              :attributes => attributes,
              :submitted_at => submitted_at,
              :lines => lines.nil? ? nil : lines.map { |o| o.to_hash },
              :identifiers => identifiers.nil? ? nil : identifiers,
              :promotions => promotions.nil? ? nil : promotions.to_hash
            }
          end

        end

        class OrderAddress

          attr_reader :text, :streets, :city, :province, :postal, :country, :latitude, :longitude, :contact

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @text = (x = opts.delete(:text); x.nil? ? nil : HttpClient::Preconditions.assert_class('text', x, String))
            @streets = (x = opts.delete(:streets); x.nil? ? nil : HttpClient::Preconditions.assert_class('streets', x, Array).map { |v| HttpClient::Preconditions.assert_class('streets', v, String) })
            @city = (x = opts.delete(:city); x.nil? ? nil : HttpClient::Preconditions.assert_class('city', x, String))
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @postal = (x = opts.delete(:postal); x.nil? ? nil : HttpClient::Preconditions.assert_class('postal', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @latitude = (x = opts.delete(:latitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('latitude', x, String))
            @longitude = (x = opts.delete(:longitude); x.nil? ? nil : HttpClient::Preconditions.assert_class('longitude', x, String))
            @contact = (x = opts.delete(:contact); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :text => text,
              :streets => streets.nil? ? nil : streets,
              :city => city,
              :province => province,
              :postal => postal,
              :country => country,
              :latitude => latitude,
              :longitude => longitude,
              :contact => contact.nil? ? nil : contact.to_hash
            }
          end

        end

        class OrderDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number], 'OrderDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number
            }
          end

        end

        class OrderError

          attr_reader :code, :messages, :numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'OrderError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::OrderErrorCode) ? x : ::Io::Flow::V0::Models::OrderErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :numbers => numbers.nil? ? nil : numbers
            }
          end

        end

        # Lightweight estimate for a group of items without any customer-related
        # information. This will contain available estimates on shipping, taxes, and
        # duties.
        class OrderEstimate

          attr_reader :id, :items, :destination, :deliveries, :prices, :selections, :total, :lines, :promotions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :items, :destination, :deliveries, :prices, :selections, :total], 'OrderEstimate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LocalizedLineItem) ? x : ::Io::Flow::V0::Models::LocalizedLineItem.new(x)) }
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetail) ? x : ::Io::Flow::V0::Models::OrderPriceDetail.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::LocalizedTotal) ? x : ::Io::Flow::V0::Models::LocalizedTotal.new(x))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Line) ? x : ::Io::Flow::V0::Models::Line.new(x)) })
            @promotions = (x = opts.delete(:promotions); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Promotions) ? x : ::Io::Flow::V0::Models::Promotions.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderEstimate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :items => items.map { |o| o.to_hash },
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :prices => prices.map { |o| o.to_hash },
              :selections => selections,
              :total => total.to_hash,
              :lines => lines.nil? ? nil : lines.map { |o| o.to_hash },
              :promotions => promotions.nil? ? nil : promotions.to_hash
            }
          end

        end

        # Form to get a lightweight estimate of an order.
        class OrderEstimateForm

          attr_reader :items, :destination, :selections

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderEstimateForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @selections = (x = opts.delete(:selections); x.nil? ? nil : HttpClient::Preconditions.assert_class('selections', x, Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderEstimateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :destination => destination.nil? ? nil : destination.to_hash,
              :selections => selections.nil? ? nil : selections
            }
          end

        end

        # Exports orders
        class OrderExportType < ExportType

          attr_reader :numbers, :min_hours_since_submitted_at, :submitted_on_or_before, :submitted_on_or_after, :status, :has_tracking_label, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::ORDER_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @min_hours_since_submitted_at = (x = opts.delete(:min_hours_since_submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('min_hours_since_submitted_at', x, Integer))
            @submitted_on_or_before = (x = opts.delete(:submitted_on_or_before); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_on_or_before', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @submitted_on_or_after = (x = opts.delete(:submitted_on_or_after); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_on_or_after', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderStatus) ? x : ::Io::Flow::V0::Models::OrderStatus.apply(x)))
            @has_tracking_label = (x = opts.delete(:has_tracking_label); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_tracking_label', x))
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :min_hours_since_submitted_at => min_hours_since_submitted_at,
              :submitted_on_or_before => submitted_on_or_before,
              :submitted_on_or_after => submitted_on_or_after,
              :status => status.nil? ? nil : status.value,
              :has_tracking_label => has_tracking_label,
              :sort => sort
            }
          end

        end

        # The order form is used to create an open order, providing the details on
        # pricing and delivery options for destination and items/quantities specified
        class OrderForm

          attr_reader :customer, :items, :delivered_duty, :number, :destination, :discount, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderForm')
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x)))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :customer => customer.nil? ? nil : customer.to_hash,
              :items => items.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :number => number,
              :destination => destination.nil? ? nil : destination.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Represents alternate numbers with which to identify an order.
        class OrderIdentifier

          attr_reader :id, :order, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :order, :number], 'OrderIdentifier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::OrderReference) ? x : ::Io::Flow::V0::Models::OrderReference.new(x))
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :order => order.to_hash,
              :number => number
            }
          end

        end

        class OrderIdentifierDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'OrderIdentifierDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class OrderIdentifierForm

          attr_reader :order, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order, :number], 'OrderIdentifierForm')
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order,
              :number => number
            }
          end

        end

        class OrderIdentifierPutForm

          attr_reader :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order], 'OrderIdentifierPutForm')
            @order = HttpClient::Preconditions.assert_class('order', opts.delete(:order), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order => order
            }
          end

        end

        class OrderIdentifierUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :number, :order_number

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_IDENTIFIER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :number, :order_number], 'OrderIdentifierUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :number => number,
              :order_number => order_number
            }
          end

        end

        class OrderIdentifierVersion

          attr_reader :id, :timestamp, :type, :order_identifier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order_identifier], 'OrderIdentifierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order_identifier = (x = opts.delete(:order_identifier); x.is_a?(::Io::Flow::V0::Models::OrderIdentifier) ? x : ::Io::Flow::V0::Models::OrderIdentifier.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderIdentifierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order_identifier => order_identifier.to_hash
            }
          end

        end

        # Represents a top-level order price detail, e.g. 'Subtotal' or 'VAT'.
        class OrderPriceDetail

          attr_reader :key, :currency, :amount, :label, :base, :components, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label, :base, :components], 'OrderPriceDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponent) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponent.new(x)) }
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPriceDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :components => components.map { |o| o.to_hash },
              :name => name
            }
          end

        end

        class OrderPriceDetailComponent

          attr_reader :key, :currency, :amount, :label, :base, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :currency, :amount, :label, :base], 'OrderPriceDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::OrderPriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::OrderPriceDetailComponentKey.apply(x))
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPriceDetailComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.to_hash,
              :name => name
            }
          end

        end

        # The order put form is used to upsert an order, providing the details on
        # pricing and delivery options for destination and items/quantities specified.
        class OrderPutForm

          attr_reader :items, :customer, :delivered_duty, :selections, :destination, :discount, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'OrderPutForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @customer = (x = opts.delete(:customer); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Customer) ? x : ::Io::Flow::V0::Models::Customer.new(x)))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @selections = (x = opts.delete(:selections); x.nil? ? nil : HttpClient::Preconditions.assert_class('selections', x, Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) })
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrderAddress) ? x : ::Io::Flow::V0::Models::OrderAddress.new(x)))
            @discount = (x = opts.delete(:discount); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Money) ? x : ::Io::Flow::V0::Models::Money.new(x)))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :customer => customer.nil? ? nil : customer.to_hash,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :selections => selections.nil? ? nil : selections,
              :destination => destination.nil? ? nil : destination.to_hash,
              :discount => discount.nil? ? nil : discount.to_hash,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class OrderReference

          attr_reader :id, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :number], 'OrderReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :number => number
            }
          end

        end

        class OrderUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :environment, :experience_id, :expires_at, :customer, :selections, :items, :destination, :deliveries, :prices, :discount, :delivered_duty, :total, :created_at, :updated_at, :submitted_at, :lines, :attributes

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORDER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :environment, :experience_id, :expires_at, :customer, :selections, :items, :destination, :deliveries, :prices, :total], 'OrderUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @environment = HttpClient::Preconditions.assert_class('environment', opts.delete(:environment), String)
            @experience_id = HttpClient::Preconditions.assert_class('experience_id', opts.delete(:experience_id), String)
            @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            @customer = HttpClient::Preconditions.assert_class('customer', HttpClient::Helper.to_object(opts.delete(:customer)), Hash)
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| HttpClient::Preconditions.assert_class('selections', v, String) }
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| HttpClient::Preconditions.assert_class('items', HttpClient::Helper.to_object(v), Hash) }
            @destination = HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(opts.delete(:destination)), Hash)
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| HttpClient::Preconditions.assert_class('deliveries', HttpClient::Helper.to_object(v), Hash) }
            @prices = HttpClient::Preconditions.assert_class('prices', opts.delete(:prices), Array).map { |v| HttpClient::Preconditions.assert_class('prices', HttpClient::Helper.to_object(v), Hash) }
            @discount = (x = opts.delete(:discount); x.nil? ? nil : HttpClient::Preconditions.assert_class('discount', HttpClient::Helper.to_object(x), Hash))
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivered_duty', x, String))
            @total = HttpClient::Preconditions.assert_class('total', HttpClient::Helper.to_object(opts.delete(:total)), Hash)
            @created_at = (x = opts.delete(:created_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @updated_at = (x = opts.delete(:updated_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('updated_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @submitted_at = (x = opts.delete(:submitted_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('submitted_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @lines = (x = opts.delete(:lines); x.nil? ? nil : HttpClient::Preconditions.assert_class('lines', x, Array).map { |v| HttpClient::Preconditions.assert_class('lines', HttpClient::Helper.to_object(v), Hash) })
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :environment => environment,
              :experience_id => experience_id,
              :expires_at => expires_at,
              :customer => customer,
              :selections => selections,
              :items => items,
              :destination => destination,
              :deliveries => deliveries,
              :prices => prices,
              :discount => discount,
              :delivered_duty => delivered_duty,
              :total => total,
              :created_at => created_at,
              :updated_at => updated_at,
              :submitted_at => submitted_at,
              :lines => lines.nil? ? nil : lines,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class OrderVersion

          attr_reader :id, :timestamp, :type, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :order], 'OrderVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @order = (x = opts.delete(:order); x.is_a?(::Io::Flow::V0::Models::Order) ? x : ::Io::Flow::V0::Models::Order.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrderVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :order => order.to_hash
            }
          end

        end

        # Represents a single organization in the system, and what environment it is
        # currently operating in.
        class Organization < ExpandableOrganization

          attr_reader :id, :name, :environment, :parent

          def initialize(incoming={})
            super(:discriminator => ExpandableOrganization::Types::ORGANIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :environment], 'Organization')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent = (x = opts.delete(:parent); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Organization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent => parent.nil? ? nil : parent.to_hash
            }
          end

        end

        # Defines the data used for broad authorization of user access to org level data
        class OrganizationAuthorization

          attr_reader :role, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:role, :environment], 'OrganizationAuthorization')
            @role = (x = opts.delete(:role); x.is_a?(::Io::Flow::V0::Models::Role) ? x : ::Io::Flow::V0::Models::Role.apply(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :role => role.value,
              :environment => environment.value
            }
          end

        end

        class OrganizationAuthorizationForm

          attr_reader :organization, :environment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :environment], 'OrganizationAuthorizationForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationAuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :organization => organization,
              :environment => environment.value
            }
          end

        end

        # Represents organization-specific currency conversion adjustments.
        class OrganizationCurrencySetting

          attr_reader :id, :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :margin], 'OrganizationCurrencySetting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySetting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :margin => margin
            }
          end

        end

        # Represents the parts of an organization setting that can be updated.
        class OrganizationCurrencySettingForm

          attr_reader :base, :target, :margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :margin], 'OrganizationCurrencySettingForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @margin = HttpClient::Preconditions.assert_class('margin', HttpClient::Helper.to_big_decimal(opts.delete(:margin)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :margin => margin
            }
          end

        end

        class OrganizationCurrencySettingVersion

          attr_reader :id, :timestamp, :type, :organization_currency_setting

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization_currency_setting], 'OrganizationCurrencySettingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization_currency_setting = (x = opts.delete(:organization_currency_setting); x.is_a?(::Io::Flow::V0::Models::OrganizationCurrencySetting) ? x : ::Io::Flow::V0::Models::OrganizationCurrencySetting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationCurrencySettingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization_currency_setting => organization_currency_setting.to_hash
            }
          end

        end

        class OrganizationDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'OrganizationDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # Either id or name is required.
        class OrganizationForm

          attr_reader :id, :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @id = (x = opts.delete(:id); x.nil? ? nil : HttpClient::Preconditions.assert_class('id', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = (x = opts.delete(:environment); x.nil? ? "production" : x); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :environment => environment.value,
              :parent_id => parent_id
            }
          end

        end

        # Data required to upsert an organization.
        class OrganizationPutForm

          attr_reader :name, :environment, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @environment = (x = opts.delete(:environment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x)))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :environment => environment.nil? ? nil : environment.value,
              :parent_id => parent_id
            }
          end

        end

        class OrganizationReference < ExpandableOrganization

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableOrganization::Types::ORGANIZATION_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'OrganizationReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class OrganizationSession < Session

          attr_reader :id, :organization, :environment, :attributes, :ip, :local

          def initialize(incoming={})
            super(:discriminator => Session::Types::ORGANIZATION_SESSION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :environment, :attributes], 'OrganizationSession')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalSession) ? x : ::Io::Flow::V0::Models::LocalSession.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSession.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization,
              :environment => environment.value,
              :attributes => attributes,
              :ip => ip,
              :local => local.nil? ? nil : local.to_hash
            }
          end

        end

        # Represents a session authorized access to the specified organization's data
        class OrganizationSessionAuthorization < SessionAuthorization

          attr_reader :organization, :environment

          def initialize(incoming={})
            super(:discriminator => SessionAuthorization::Types::ORGANIZATION_SESSION_AUTHORIZATION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :environment], 'OrganizationSessionAuthorization')
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSessionAuthorization.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :organization => organization.to_hash,
              :environment => environment.value
            }
          end

        end

        class OrganizationSummary

          attr_reader :id, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'OrganizationSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name
            }
          end

        end

        # All of the metadata associated with a given token.
        class OrganizationToken < Token

          attr_reader :id, :organization, :user, :environment, :partial, :created_at, :description

          def initialize(incoming={})
            super(:discriminator => Token::Types::ORGANIZATION_TOKEN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :user, :environment, :partial, :created_at], 'OrganizationToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationToken.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :user => user.to_hash,
              :environment => environment.value,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to create a new token. User making the request must be authorized to
        # create a token for this organization.
        class OrganizationTokenForm < TokenForm

          attr_reader :organization, :environment, :description

          def initialize(incoming={})
            super(:discriminator => TokenForm::Types::ORGANIZATION_TOKEN_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:organization, :environment], 'OrganizationTokenForm')
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationTokenForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :organization => organization,
              :environment => environment.value,
              :description => description
            }
          end

        end

        # Summary data for a given token
        class OrganizationTokenReference < TokenReference

          attr_reader :id, :organization, :environment, :user

          def initialize(incoming={})
            super(:discriminator => TokenReference::Types::ORGANIZATION_TOKEN_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :environment, :user], 'OrganizationTokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::OrganizationReference) ? x : ::Io::Flow::V0::Models::OrganizationReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationTokenReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization.to_hash,
              :environment => environment.value,
              :user => user.to_hash
            }
          end

        end

        class OrganizationUpserted < Event

          attr_reader :event_id, :timestamp, :id, :name, :environment, :currencies, :parent_id, :default_base_currency, :default_country, :default_language, :default_locale, :default_timezone

          def initialize(incoming={})
            super(:discriminator => Event::Types::ORGANIZATION_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :name, :environment, :currencies], 'OrganizationUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @environment = HttpClient::Preconditions.assert_class('environment', opts.delete(:environment), String)
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
            @default_base_currency = (x = opts.delete(:default_base_currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_base_currency', x, String))
            @default_country = (x = opts.delete(:default_country); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_country', x, String))
            @default_language = (x = opts.delete(:default_language); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_language', x, String))
            @default_locale = (x = opts.delete(:default_locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_locale', x, String))
            @default_timezone = (x = opts.delete(:default_timezone); x.nil? ? nil : HttpClient::Preconditions.assert_class('default_timezone', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :name => name,
              :environment => environment,
              :currencies => currencies,
              :parent_id => parent_id,
              :default_base_currency => default_base_currency,
              :default_country => default_country,
              :default_language => default_language,
              :default_locale => default_locale,
              :default_timezone => default_timezone
            }
          end

        end

        class OrganizationVersion

          attr_reader :id, :timestamp, :type, :organization

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :organization], 'OrganizationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @organization = (x = opts.delete(:organization); x.is_a?(::Io::Flow::V0::Models::Organization) ? x : ::Io::Flow::V0::Models::Organization.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OrganizationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :organization => organization.to_hash
            }
          end

        end

        # Describes the outgoing feed constructed by Flow
        class OutgoingFeed

          attr_reader :format, :minute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:format], 'OutgoingFeed')
            @format = (x = opts.delete(:format); x.is_a?(::Io::Flow::V0::Models::OutgoingFeedFormat) ? x : ::Io::Flow::V0::Models::OutgoingFeedFormat.apply(x))
            @minute = HttpClient::Preconditions.assert_class('minute', (x = opts.delete(:minute); x.nil? ? 0 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OutgoingFeed.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :format => format.value,
              :minute => minute
            }
          end

        end

        # Describes the outgoing feed constructed by Flow
        class OutgoingFeedForm

          attr_reader :format, :minute

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:format], 'OutgoingFeedForm')
            @format = (x = opts.delete(:format); x.is_a?(::Io::Flow::V0::Models::OutgoingFeedFormat) ? x : ::Io::Flow::V0::Models::OutgoingFeedFormat.apply(x))
            @minute = HttpClient::Preconditions.assert_class('minute', (x = opts.delete(:minute); x.nil? ? 0 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            OutgoingFeedForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :format => format.value,
              :minute => minute
            }
          end

        end

        # Represents packaging available to ship items
        class Packaging

          attr_reader :dimensions, :name, :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions], 'Packaging')
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimensions) ? x : ::Io::Flow::V0::Models::Dimensions.new(x))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            @number = (x = opts.delete(:number); x.nil? ? nil : HttpClient::Preconditions.assert_class('number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Packaging.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.to_hash,
              :name => name,
              :number => number
            }
          end

        end

        # All of the metadata associated with a given token.
        class PartnerToken < Token

          attr_reader :id, :partner, :user, :environment, :partial, :created_at, :description

          def initialize(incoming={})
            super(:discriminator => Token::Types::PARTNER_TOKEN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :partner, :user, :environment, :partial, :created_at], 'PartnerToken')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @partner = (x = opts.delete(:partner); x.is_a?(::Io::Flow::V0::Models::TokenPartnerReference) ? x : ::Io::Flow::V0::Models::TokenPartnerReference.new(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @partial = HttpClient::Preconditions.assert_class('partial', opts.delete(:partial), String)
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerToken.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :partner => partner.to_hash,
              :user => user.to_hash,
              :environment => environment.value,
              :partial => partial,
              :created_at => created_at,
              :description => description
            }
          end

        end

        # Used to create a new token. User making the request must be authorized to
        # create a token for this partner.
        class PartnerTokenForm < TokenForm

          attr_reader :partner, :environment, :description

          def initialize(incoming={})
            super(:discriminator => TokenForm::Types::PARTNER_TOKEN_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:partner, :environment], 'PartnerTokenForm')
            @partner = HttpClient::Preconditions.assert_class('partner', opts.delete(:partner), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerTokenForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :partner => partner,
              :environment => environment.value,
              :description => description
            }
          end

        end

        # Summary data for a given token
        class PartnerTokenReference < TokenReference

          attr_reader :id, :partner, :environment, :user

          def initialize(incoming={})
            super(:discriminator => TokenReference::Types::PARTNER_TOKEN_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :partner, :environment, :user], 'PartnerTokenReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @partner = (x = opts.delete(:partner); x.is_a?(::Io::Flow::V0::Models::TokenPartnerReference) ? x : ::Io::Flow::V0::Models::TokenPartnerReference.new(x))
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PartnerTokenReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :partner => partner.to_hash,
              :environment => environment.value,
              :user => user.to_hash
            }
          end

        end

        class PasswordChangeForm

          attr_reader :current, :new

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:current, :new], 'PasswordChangeForm')
            @current = HttpClient::Preconditions.assert_class('current', opts.delete(:current), String)
            @new = HttpClient::Preconditions.assert_class('new', opts.delete(:new), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordChangeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :current => current,
              :new => new
            }
          end

        end

        class PasswordResetForm

          attr_reader :token, :password

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordResetForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token,
              :password => password
            }
          end

        end

        class PasswordResetRequestForm

          attr_reader :email

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequestForm')
            @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PasswordResetRequestForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email
            }
          end

        end

        class PaymentDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::PAYMENT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id], 'PaymentDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id
            }
          end

        end

        # Details for why a payment failed
        class PaymentError

          attr_reader :code, :messages, :codes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:messages, :codes], 'PaymentError')
            @code = HttpClient::Preconditions.assert_class('code', (x = opts.delete(:code); x.nil? ? "payment_error" : x), String)
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @codes = HttpClient::Preconditions.assert_class('codes', opts.delete(:codes), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PaymentErrorCode) ? x : ::Io::Flow::V0::Models::PaymentErrorCode.apply(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code,
              :messages => messages,
              :codes => codes.map { |o| o.value }
            }
          end

        end

        # Represents a single payment method - e.g VISA or Paypal - and any associated
        # metadata required for processing
        class PaymentMethod

          attr_reader :id, :type, :name, :images, :regions

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :type, :name, :images, :regions], 'PaymentMethod')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PaymentMethodType) ? x : ::Io::Flow::V0::Models::PaymentMethodType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @images = (x = opts.delete(:images); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImages) ? x : ::Io::Flow::V0::Models::PaymentMethodImages.new(x))
            @regions = HttpClient::Preconditions.assert_class('regions', opts.delete(:regions), Array).map { |v| HttpClient::Preconditions.assert_class('regions', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethod.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :type => type.value,
              :name => name,
              :images => images.to_hash,
              :regions => regions
            }
          end

        end

        class PaymentMethodImage

          attr_reader :url, :width, :height

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :width, :height], 'PaymentMethodImage')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @width = HttpClient::Preconditions.assert_class('width', opts.delete(:width), Integer)
            @height = HttpClient::Preconditions.assert_class('height', opts.delete(:height), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodImage.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :width => width,
              :height => height
            }
          end

        end

        class PaymentMethodImages

          attr_reader :small, :medium, :large

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:small, :medium, :large], 'PaymentMethodImages')
            @small = (x = opts.delete(:small); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
            @medium = (x = opts.delete(:medium); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
            @large = (x = opts.delete(:large); x.is_a?(::Io::Flow::V0::Models::PaymentMethodImage) ? x : ::Io::Flow::V0::Models::PaymentMethodImage.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentMethodImages.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :small => small.to_hash,
              :medium => medium.to_hash,
              :large => large.to_hash
            }
          end

        end

        # Represents on line payment
        class PaymentPaypal < ExpandablePayment

          attr_reader :id, :order, :amount, :currency, :paypal

          def initialize(incoming={})
            super(:discriminator => ExpandablePayment::Types::PAYMENT_PAYPAL)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :amount, :currency, :paypal], 'PaymentPaypal')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::AuthorizationOrderReference) ? x : ::Io::Flow::V0::Models::AuthorizationOrderReference.new(x)))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @paypal = (x = opts.delete(:paypal); x.is_a?(::Io::Flow::V0::Models::PaymentPaypalData) ? x : ::Io::Flow::V0::Models::PaymentPaypalData.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentPaypal.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :order => order.nil? ? nil : order.to_hash,
              :amount => amount,
              :currency => currency,
              :paypal => paypal.to_hash
            }
          end

        end

        # Represents on line payment
        class PaymentPaypalData

          attr_reader :payment_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:payment_id], 'PaymentPaypalData')
            @payment_id = HttpClient::Preconditions.assert_class('payment_id', opts.delete(:payment_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentPaypalData.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :payment_id => payment_id
            }
          end

        end

        class PaymentReference < ExpandablePayment

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandablePayment::Types::PAYMENT_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'PaymentReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class PaymentUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :payment

          def initialize(incoming={})
            super(:discriminator => Event::Types::PAYMENT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :payment], 'PaymentUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::Payment) ? x : ::Io::Flow::V0::Models::Payment.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :payment => payment.to_hash
            }
          end

        end

        class PaymentVersion

          attr_reader :id, :timestamp, :type, :payment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :payment], 'PaymentVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @payment = (x = opts.delete(:payment); x.is_a?(::Io::Flow::V0::Models::Payment) ? x : ::Io::Flow::V0::Models::Payment.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaymentVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :payment => payment.to_hash
            }
          end

        end

        # Executes the Paypal payment
        class PaypalAuthorizationForm < AuthorizationForm

          attr_reader :paypal_payment_id, :paypal_payer_id, :key, :attributes, :ip

          def initialize(incoming={})
            super(:discriminator => AuthorizationForm::Types::PAYPAL_AUTHORIZATION_FORM)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:paypal_payment_id, :paypal_payer_id], 'PaypalAuthorizationForm')
            @paypal_payment_id = HttpClient::Preconditions.assert_class('paypal_payment_id', opts.delete(:paypal_payment_id), String)
            @paypal_payer_id = HttpClient::Preconditions.assert_class('paypal_payer_id', opts.delete(:paypal_payer_id), String)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PaypalAuthorizationForm.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :paypal_payment_id => paypal_payment_id,
              :paypal_payer_id => paypal_payer_id,
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :ip => ip
            }
          end

        end

        # Rule outcome where shipping surfaced in quote is actual cost plus a predefined
        # margin percentage
        class PercentMargin < TierRuleOutcome

          attr_reader :percentage

          def initialize(incoming={})
            super(:discriminator => TierRuleOutcome::Types::PERCENT_MARGIN)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:percentage], 'PercentMargin')
            @percentage = HttpClient::Preconditions.assert_class('percentage', opts.delete(:percentage), Numeric)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PercentMargin.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :percentage => percentage
            }
          end

        end

        # Represents an amount-currency pair for a basic price
        class Price

          attr_reader :amount, :currency, :label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency, :label], 'Price')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Price.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency,
              :label => label
            }
          end

        end

        class PriceCheck

          attr_reader :display, :final

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:display, :final], 'PriceCheck')
            @display = (x = opts.delete(:display); x.is_a?(::Io::Flow::V0::Models::LocalPriceDetails) ? x : ::Io::Flow::V0::Models::LocalPriceDetails.new(x))
            @final = (x = opts.delete(:final); x.is_a?(::Io::Flow::V0::Models::LocalPriceDetails) ? x : ::Io::Flow::V0::Models::LocalPriceDetails.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceCheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :display => display.to_hash,
              :final => final.to_hash
            }
          end

        end

        # Represents a top-level price detail, e.g. 'Subtotal' or 'VAT'.
        class PriceDetail

          attr_reader :key, :components, :amount, :label, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :components, :amount, :label], 'PriceDetail')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::PriceDetailKey) ? x : ::Io::Flow::V0::Models::PriceDetailKey.apply(x))
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::PriceDetailComponent) ? x : ::Io::Flow::V0::Models::PriceDetailComponent.new(x)) }
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetail.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :components => components.map { |o| o.to_hash },
              :amount => amount,
              :label => label,
              :name => name
            }
          end

        end

        class PriceDetailComponent

          attr_reader :key, :amount, :label, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :amount, :label], 'PriceDetailComponent')
            @key = (x = opts.delete(:key); x.is_a?(::Io::Flow::V0::Models::PriceDetailComponentKey) ? x : ::Io::Flow::V0::Models::PriceDetailComponentKey.apply(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetailComponent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key.value,
              :amount => amount,
              :label => label,
              :name => name
            }
          end

        end

        # Detailed information for the pricing of a given item within an experience.
        class PriceDetails

          attr_reader :currency, :item_price, :margins, :vat, :duty, :rounding, :price, :total, :adjustment

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :item_price, :margins, :vat, :duty, :rounding, :price, :total], 'PriceDetails')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @item_price = (x = opts.delete(:item_price); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @margins = (x = opts.delete(:margins); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @rounding = (x = opts.delete(:rounding); x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x))
            @price = (x = opts.delete(:price); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @total = (x = opts.delete(:total); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @adjustment = (x = opts.delete(:adjustment); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::PriceDetail) ? x : ::Io::Flow::V0::Models::PriceDetail.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceDetails.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :item_price => item_price.to_hash,
              :margins => margins.to_hash,
              :vat => vat.to_hash,
              :duty => duty.to_hash,
              :rounding => rounding.to_hash,
              :price => price.to_hash,
              :total => total.to_hash,
              :adjustment => adjustment.nil? ? nil : adjustment.to_hash
            }
          end

        end

        class PriceEquation

          attr_reader :contracted_rate, :rate, :pricing, :base_price, :discount, :fixed_margin, :percent_margin, :insurance, :freight, :duty, :tax, :percent_sales_margin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contracted_rate, :rate, :pricing, :base_price, :discount, :fixed_margin, :percent_margin, :insurance, :freight], 'PriceEquation')
            @contracted_rate = HttpClient::Preconditions.assert_class('contracted_rate', HttpClient::Helper.to_big_decimal(opts.delete(:contracted_rate)), BigDecimal)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @pricing = (x = opts.delete(:pricing); x.is_a?(::Io::Flow::V0::Models::Pricing) ? x : ::Io::Flow::V0::Models::Pricing.new(x))
            @base_price = HttpClient::Preconditions.assert_class('base_price', HttpClient::Helper.to_big_decimal(opts.delete(:base_price)), BigDecimal)
            @discount = HttpClient::Preconditions.assert_class('discount', HttpClient::Helper.to_big_decimal(opts.delete(:discount)), BigDecimal)
            @fixed_margin = HttpClient::Preconditions.assert_class('fixed_margin', HttpClient::Helper.to_big_decimal(opts.delete(:fixed_margin)), BigDecimal)
            @percent_margin = HttpClient::Preconditions.assert_class('percent_margin', HttpClient::Helper.to_big_decimal(opts.delete(:percent_margin)), BigDecimal)
            @insurance = HttpClient::Preconditions.assert_class('insurance', HttpClient::Helper.to_big_decimal(opts.delete(:insurance)), BigDecimal)
            @freight = HttpClient::Preconditions.assert_class('freight', HttpClient::Helper.to_big_decimal(opts.delete(:freight)), BigDecimal)
            @duty = (x = opts.delete(:duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Duty) ? x : ::Io::Flow::V0::Models::Duty.new(x)))
            @tax = (x = opts.delete(:tax); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Tax) ? x : ::Io::Flow::V0::Models::Tax.new(x)))
            @percent_sales_margin = HttpClient::Preconditions.assert_class('percent_sales_margin', HttpClient::Helper.to_big_decimal((x = opts.delete(:percent_sales_margin); x.nil? ? 0 : x)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceEquation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contracted_rate => contracted_rate,
              :rate => rate,
              :pricing => pricing.to_hash,
              :base_price => base_price,
              :discount => discount,
              :fixed_margin => fixed_margin,
              :percent_margin => percent_margin,
              :insurance => insurance,
              :freight => freight,
              :duty => duty.nil? ? nil : duty.to_hash,
              :tax => tax.nil? ? nil : tax.to_hash,
              :percent_sales_margin => percent_sales_margin
            }
          end

        end

        # Amount-currency paid for a basic price to be used in model forms, before a
        # price label is created. Label in the main price model is created by the
        # implementing api.
        class PriceForm

          attr_reader :amount, :currency

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:amount, :currency], 'PriceForm')
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :amount => amount,
              :currency => currency
            }
          end

        end

        class PriceWithBase

          attr_reader :currency, :amount, :label, :base

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :amount, :label], 'PriceWithBase')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @amount = HttpClient::Preconditions.assert_class('amount', opts.delete(:amount), Numeric)
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @base = (x = opts.delete(:base); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PriceWithBase.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :amount => amount,
              :label => label,
              :base => base.nil? ? nil : base.to_hash
            }
          end

        end

        # Pricing determines how the item price is calculated when items are requests
        # via the experience.
        class Pricing

          attr_reader :vat, :duty, :rounding

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:vat, :duty], 'Pricing')
            @vat = (x = opts.delete(:vat); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @duty = (x = opts.delete(:duty); x.is_a?(::Io::Flow::V0::Models::PricingLevySetting) ? x : ::Io::Flow::V0::Models::PricingLevySetting.apply(x))
            @rounding = (x = opts.delete(:rounding); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Rounding) ? x : ::Io::Flow::V0::Models::Rounding.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Pricing.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :vat => vat.value,
              :duty => duty.value,
              :rounding => rounding.nil? ? nil : rounding.to_hash
            }
          end

        end

        class PricingDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICING_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key], 'PricingDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PricingDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key
            }
          end

        end

        class PricingUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :experience_key, :vat, :duty, :rounding_type, :rounding_method, :rounding_value

          def initialize(incoming={})
            super(:discriminator => Event::Types::PRICING_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :experience_key, :vat, :duty], 'PricingUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @vat = HttpClient::Preconditions.assert_class('vat', opts.delete(:vat), String)
            @duty = HttpClient::Preconditions.assert_class('duty', opts.delete(:duty), String)
            @rounding_type = (x = opts.delete(:rounding_type); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_type', x, String))
            @rounding_method = (x = opts.delete(:rounding_method); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_method', x, String))
            @rounding_value = (x = opts.delete(:rounding_value); x.nil? ? nil : HttpClient::Preconditions.assert_class('rounding_value', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PricingUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :experience_key => experience_key,
              :vat => vat,
              :duty => duty,
              :rounding_type => rounding_type,
              :rounding_method => rounding_method,
              :rounding_value => rounding_value
            }
          end

        end

        class PromotionTrigger

          attr_reader :type, :min, :remaining, :max

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :min, :remaining], 'PromotionTrigger')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::PromotionTriggerType) ? x : ::Io::Flow::V0::Models::PromotionTriggerType.apply(x))
            @min = (x = opts.delete(:min); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @remaining = (x = opts.delete(:remaining); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @max = (x = opts.delete(:max); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PromotionTrigger.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :min => min.to_hash,
              :remaining => remaining.to_hash,
              :max => max.nil? ? nil : max.to_hash
            }
          end

        end

        class Promotions

          attr_reader :applied, :available

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:applied, :available], 'Promotions')
            @applied = HttpClient::Preconditions.assert_class('applied', opts.delete(:applied), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Promotion) ? x : ::Io::Flow::V0::Models::Promotion.from_json(x)) }
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Promotion) ? x : ::Io::Flow::V0::Models::Promotion.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Promotions.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :applied => applied.map { |o| o.to_hash },
              :available => available.map { |o| o.to_hash }
            }
          end

        end

        # A subdivision/province/state within a country. These conform to the ISO 3166-2
        # standard for country subdivisions. See https://api.flow.io/reference/provinces
        class Province

          attr_reader :id, :iso_3166_2, :name, :country, :province_type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :iso_3166_2, :name, :country, :province_type], 'Province')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @iso_3166_2 = HttpClient::Preconditions.assert_class('iso_3166_2', opts.delete(:iso_3166_2), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @country = HttpClient::Preconditions.assert_class('country', opts.delete(:country), String)
            @province_type = (x = opts.delete(:province_type); x.is_a?(::Io::Flow::V0::Models::ProvinceType) ? x : ::Io::Flow::V0::Models::ProvinceType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Province.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :iso_3166_2 => iso_3166_2,
              :name => name,
              :country => country,
              :province_type => province_type.value
            }
          end

        end

        # A public key is used to encrypt cards client side prior to submitting to the
        # Flow vault.
        class PublicKey

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'PublicKey')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            PublicKey.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Represents a typed query to indicate which items to include or exclude in a
        # subcatalog
        class Query

          attr_reader :id, :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :type], 'Query')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Query.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :type => type.value
            }
          end

        end

        # Defines a query specifying items to be included or excluded in a subcatalog
        class QueryForm

          attr_reader :q, :type

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :type], 'QueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::QueryType) ? x : ::Io::Flow::V0::Models::QueryType.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :type => type.value
            }
          end

        end

        # Indicates valid and invalid queries
        class QueryValidation

          attr_reader :valid, :invalid

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:valid, :invalid], 'QueryValidation')
            @valid = HttpClient::Preconditions.assert_class('valid', opts.delete(:valid), Array).map { |v| HttpClient::Preconditions.assert_class('valid', v, String) }
            @invalid = HttpClient::Preconditions.assert_class('invalid', opts.delete(:invalid), Array).map { |v| HttpClient::Preconditions.assert_class('invalid', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QueryValidation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :valid => valid,
              :invalid => invalid
            }
          end

        end

        # Represents a collection of deliveries and available options for fulfillment of
        # that delivery
        class Quote

          attr_reader :id, :destination, :deliveries, :selections, :delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination, :deliveries, :selections], 'Quote')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @deliveries = HttpClient::Preconditions.assert_class('deliveries', opts.delete(:deliveries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Delivery) ? x : ::Io::Flow::V0::Models::Delivery.new(x)) }
            @selections = HttpClient::Preconditions.assert_class('selections', opts.delete(:selections), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::DeliveryOptionReference) ? x : ::Io::Flow::V0::Models::DeliveryOptionReference.new(x)) }
            @delivered_duty = (x = (x = opts.delete(:delivered_duty); x.nil? ? "paid" : x); x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Quote.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash,
              :deliveries => deliveries.map { |o| o.to_hash },
              :selections => selections.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.value
            }
          end

        end

        class QuoteError

          attr_reader :code, :messages, :item_numbers

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:code, :messages], 'QuoteError')
            @code = (x = opts.delete(:code); x.is_a?(::Io::Flow::V0::Models::QuoteErrorCode) ? x : ::Io::Flow::V0::Models::QuoteErrorCode.apply(x))
            @messages = HttpClient::Preconditions.assert_class('messages', opts.delete(:messages), Array).map { |v| HttpClient::Preconditions.assert_class('messages', v, String) }
            @item_numbers = (x = opts.delete(:item_numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('item_numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('item_numbers', v, String) })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteError.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :code => code.value,
              :messages => messages,
              :item_numbers => item_numbers.nil? ? nil : item_numbers
            }
          end

        end

        class QuoteForm

          attr_reader :destination, :experience, :items, :delivered_duty

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :experience, :items], 'QuoteForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :experience => experience,
              :items => items.map { |o| o.to_hash },
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value
            }
          end

        end

        class QuoteSummary

          attr_reader :id, :destination

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :destination], 'QuoteSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :destination => destination.to_hash
            }
          end

        end

        class QuoteVersion

          attr_reader :id, :timestamp, :type, :quote

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :quote], 'QuoteVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @quote = (x = opts.delete(:quote); x.is_a?(::Io::Flow::V0::Models::QuoteSummary) ? x : ::Io::Flow::V0::Models::QuoteSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            QuoteVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :quote => quote.to_hash
            }
          end

        end

        # Represents an organization-specific currency conversion rate at a point in
        # time.
        class Rate

          attr_reader :id, :base, :target, :effective_at, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :base, :target, :effective_at, :value], 'Rate')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rate.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :base => base,
              :target => target,
              :effective_at => effective_at,
              :value => value
            }
          end

        end

        class RateDeleted < Event

          attr_reader :event_id, :timestamp, :rate_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :rate_id], 'RateDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @rate_id = HttpClient::Preconditions.assert_class('rate_id', opts.delete(:rate_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :rate_id => rate_id
            }
          end

        end

        # Represents the parts of an organization rate that can be updated.
        class RateForm

          attr_reader :base, :target, :effective_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:base, :target, :effective_at], 'RateForm')
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :base => base,
              :target => target,
              :effective_at => effective_at
            }
          end

        end

        class RateUpserted < Event

          attr_reader :event_id, :timestamp, :rate_id, :organization_id, :base, :target, :effective_at, :value

          def initialize(incoming={})
            super(:discriminator => Event::Types::RATE_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :rate_id, :organization_id, :base, :target, :effective_at, :value], 'RateUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @rate_id = HttpClient::Preconditions.assert_class('rate_id', opts.delete(:rate_id), String)
            @organization_id = HttpClient::Preconditions.assert_class('organization_id', opts.delete(:organization_id), String)
            @base = HttpClient::Preconditions.assert_class('base', opts.delete(:base), String)
            @target = HttpClient::Preconditions.assert_class('target', opts.delete(:target), String)
            @effective_at = HttpClient::Preconditions.assert_class('effective_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:effective_at)), DateTime)
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :rate_id => rate_id,
              :organization_id => organization_id,
              :base => base,
              :target => target,
              :effective_at => effective_at,
              :value => value
            }
          end

        end

        class RateVersion

          attr_reader :id, :timestamp, :type, :rate

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :rate], 'RateVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @rate = (x = opts.delete(:rate); x.is_a?(::Io::Flow::V0::Models::Rate) ? x : ::Io::Flow::V0::Models::Rate.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RateVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :rate => rate.to_hash
            }
          end

        end

        # Refunds can be created against either a specific capture or an authorization
        # (in which case we will select 1 or more specific captures against which to
        # execute the refund).
        class Refund

          attr_reader :id, :key, :authorization, :amount, :currency, :captures, :created_at, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :authorization, :amount, :currency, :captures, :created_at], 'Refund')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization = (x = opts.delete(:authorization); x.is_a?(::Io::Flow::V0::Models::AuthorizationReference) ? x : ::Io::Flow::V0::Models::AuthorizationReference.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @captures = HttpClient::Preconditions.assert_class('captures', opts.delete(:captures), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::RefundCapture) ? x : ::Io::Flow::V0::Models::RefundCapture.new(x)) }
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Refund.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :authorization => authorization.to_hash,
              :amount => amount,
              :currency => currency,
              :captures => captures.map { |o| o.to_hash },
              :created_at => created_at,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # Refund captures provide the detailed information on the amount refunded
        # against a specific capture
        class RefundCapture

          attr_reader :capture, :amount

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:capture, :amount], 'RefundCapture')
            @capture = (x = opts.delete(:capture); x.is_a?(::Io::Flow::V0::Models::Capture) ? x : ::Io::Flow::V0::Models::Capture.new(x))
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundCapture.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :capture => capture.to_hash,
              :amount => amount
            }
          end

        end

        # Refund actually transfers funds. You can refund as many times as you'd like up
        # until the total amount of captured funds has been refunded. Note when creating
        # a refund you can specify either an order authorization id, a capture id, or an
        # order number (or all of them as long as they match).
        class RefundForm

          attr_reader :authorization_id, :capture_id, :order_number, :key, :amount, :currency, :rma_key, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @authorization_id = (x = opts.delete(:authorization_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('authorization_id', x, String))
            @capture_id = (x = opts.delete(:capture_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('capture_id', x, String))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @amount = (x = opts.delete(:amount); x.nil? ? nil : HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @rma_key = (x = opts.delete(:rma_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('rma_key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :authorization_id => authorization_id,
              :capture_id => capture_id,
              :order_number => order_number,
              :key => key,
              :amount => amount,
              :currency => currency,
              :rma_key => rma_key,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        # For merchant of record authorizations, we provide a summary of refund
        # information primarily to support customer service workflow.
        class RefundOrderSummary

          attr_reader :order_number, :currency, :captured, :refunded, :amounts

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:order_number, :currency, :captured, :refunded, :amounts], 'RefundOrderSummary')
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @captured = HttpClient::Preconditions.assert_class('captured', HttpClient::Helper.to_big_decimal(opts.delete(:captured)), BigDecimal)
            @refunded = HttpClient::Preconditions.assert_class('refunded', HttpClient::Helper.to_big_decimal(opts.delete(:refunded)), BigDecimal)
            @amounts = (x = opts.delete(:amounts); x.is_a?(::Io::Flow::V0::Models::RefundOrderSummaryAmounts) ? x : ::Io::Flow::V0::Models::RefundOrderSummaryAmounts.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundOrderSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :order_number => order_number,
              :currency => currency,
              :captured => captured,
              :refunded => refunded,
              :amounts => amounts.to_hash
            }
          end

        end

        # Detailed examples of amount to refund following common ecommerce use cases.
        class RefundOrderSummaryAmounts

          attr_reader :balance, :balance_excluding_shipping, :shipping

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:balance], 'RefundOrderSummaryAmounts')
            @balance = HttpClient::Preconditions.assert_class('balance', HttpClient::Helper.to_big_decimal(opts.delete(:balance)), BigDecimal)
            @balance_excluding_shipping = (x = opts.delete(:balance_excluding_shipping); x.nil? ? nil : HttpClient::Preconditions.assert_class('balance_excluding_shipping', HttpClient::Helper.to_big_decimal(x), BigDecimal))
            @shipping = (x = opts.delete(:shipping); x.nil? ? nil : HttpClient::Preconditions.assert_class('shipping', HttpClient::Helper.to_big_decimal(x), BigDecimal))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundOrderSummaryAmounts.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :balance => balance,
              :balance_excluding_shipping => balance_excluding_shipping,
              :shipping => shipping
            }
          end

        end

        class RefundUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :key, :authorization_key, :amount, :currency, :captures, :created_at, :order_number, :rma_key

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :key, :authorization_key, :amount, :currency, :captures, :created_at], 'RefundUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @authorization_key = HttpClient::Preconditions.assert_class('authorization_key', opts.delete(:authorization_key), String)
            @amount = HttpClient::Preconditions.assert_class('amount', HttpClient::Helper.to_big_decimal(opts.delete(:amount)), BigDecimal)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @captures = HttpClient::Preconditions.assert_class('captures', opts.delete(:captures), Array).map { |v| HttpClient::Preconditions.assert_class('captures', HttpClient::Helper.to_object(v), Hash) }
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @rma_key = (x = opts.delete(:rma_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('rma_key', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :key => key,
              :authorization_key => authorization_key,
              :amount => amount,
              :currency => currency,
              :captures => captures,
              :created_at => created_at,
              :order_number => order_number,
              :rma_key => rma_key
            }
          end

        end

        class RefundUpsertedV2 < Event

          attr_reader :event_id, :timestamp, :organization, :id, :refund

          def initialize(incoming={})
            super(:discriminator => Event::Types::REFUND_UPSERTED_V2)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :refund], 'RefundUpsertedV2')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundUpsertedV2.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :refund => refund.to_hash
            }
          end

        end

        class RefundVersion

          attr_reader :id, :timestamp, :type, :refund

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :refund], 'RefundVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @refund = (x = opts.delete(:refund); x.is_a?(::Io::Flow::V0::Models::Refund) ? x : ::Io::Flow::V0::Models::Refund.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RefundVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :refund => refund.to_hash
            }
          end

        end

        # A region represents a geographic area of the world. Regions can be countries,
        # continents or other political areas (like the Eurozone). See
        # https://api.flow.io/reference/regions
        class Region

          attr_reader :id, :name, :countries, :currencies, :languages, :measurement_systems, :timezones

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :countries, :currencies, :languages, :measurement_systems, :timezones], 'Region')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @countries = HttpClient::Preconditions.assert_class('countries', opts.delete(:countries), Array).map { |v| HttpClient::Preconditions.assert_class('countries', v, String) }
            @currencies = HttpClient::Preconditions.assert_class('currencies', opts.delete(:currencies), Array).map { |v| HttpClient::Preconditions.assert_class('currencies', v, String) }
            @languages = HttpClient::Preconditions.assert_class('languages', opts.delete(:languages), Array).map { |v| HttpClient::Preconditions.assert_class('languages', v, String) }
            @measurement_systems = HttpClient::Preconditions.assert_class('measurement_systems', opts.delete(:measurement_systems), Array).map { |v| HttpClient::Preconditions.assert_class('measurement_systems', v, String) }
            @timezones = HttpClient::Preconditions.assert_class('timezones', opts.delete(:timezones), Array).map { |v| HttpClient::Preconditions.assert_class('timezones', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Region.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :countries => countries,
              :currencies => currencies,
              :languages => languages,
              :measurement_systems => measurement_systems,
              :timezones => timezones
            }
          end

        end

        class RegionReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'RegionReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            RegionReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class Return

          attr_reader :id, :key, :items, :labels

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :items, :labels], 'Return')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReturnLineItem) ? x : ::Io::Flow::V0::Models::ReturnLineItem.new(x)) }
            @labels = HttpClient::Preconditions.assert_class('labels', opts.delete(:labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ShippingLabel) ? x : ::Io::Flow::V0::Models::ShippingLabel.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Return.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :items => items.map { |o| o.to_hash },
              :labels => labels.map { |o| o.to_hash }
            }
          end

        end

        class ReturnDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::RETURN_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'ReturnDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        class ReturnForm

          attr_reader :items, :service, :destination, :key, :origin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:items], 'ReturnForm')
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ReturnLineItem) ? x : ::Io::Flow::V0::Models::ReturnLineItem.new(x)) }
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
            @destination = (x = opts.delete(:destination); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @origin = (x = opts.delete(:origin); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :items => items.map { |o| o.to_hash },
              :service => service,
              :destination => destination.nil? ? nil : destination.to_hash,
              :key => key,
              :origin => origin.nil? ? nil : origin.to_hash
            }
          end

        end

        class ReturnItemReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReturnItemReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnItemReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ReturnLineItem

          attr_reader :item_number, :order_number, :quantity, :reason, :notes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_number, :quantity], 'ReturnLineItem')
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
            @reason = (x = opts.delete(:reason); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ReturnReason) ? x : ::Io::Flow::V0::Models::ReturnReason.new(x)))
            @notes = (x = opts.delete(:notes); x.nil? ? nil : HttpClient::Preconditions.assert_class('notes', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnLineItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_number => item_number,
              :order_number => order_number,
              :quantity => quantity,
              :reason => reason.nil? ? nil : reason.to_hash,
              :notes => notes
            }
          end

        end

        class ReturnOrderReference

          attr_reader :number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:number], 'ReturnOrderReference')
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnOrderReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :number => number
            }
          end

        end

        class ReturnReason

          attr_reader :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :name], 'ReturnReason')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReason.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name
            }
          end

        end

        class ReturnReasonForm

          attr_reader :key, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReasonForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :name => name
            }
          end

        end

        class ReturnReasonPutForm

          attr_reader :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnReasonPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name
            }
          end

        end

        class ReturnUpserted < Event

          attr_reader :event_id, :timestamp, :id, :organization, :destination, :items, :key, :labels, :service, :origin

          def initialize(incoming={})
            super(:discriminator => Event::Types::RETURN_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id, :organization, :destination, :items, :key, :labels, :service, :origin], 'ReturnUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @destination = HttpClient::Preconditions.assert_class('destination', HttpClient::Helper.to_object(opts.delete(:destination)), Hash)
            @items = HttpClient::Preconditions.assert_class('items', HttpClient::Helper.to_object(opts.delete(:items)), Hash)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @labels = HttpClient::Preconditions.assert_class('labels', HttpClient::Helper.to_object(opts.delete(:labels)), Hash)
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin = HttpClient::Preconditions.assert_class('origin', HttpClient::Helper.to_object(opts.delete(:origin)), Hash)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id,
              :organization => organization,
              :destination => destination,
              :items => items,
              :key => key,
              :labels => labels,
              :service => service,
              :origin => origin
            }
          end

        end

        class ReturnVersion

          attr_reader :id, :timestamp, :type, :return_

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :return_], 'ReturnVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @return_ = (x = opts.delete(:return); x.is_a?(::Io::Flow::V0::Models::Return) ? x : ::Io::Flow::V0::Models::Return.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ReturnVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :return => return_.to_hash
            }
          end

        end

        class Rounding

          attr_reader :type, :method, :value

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:type, :method, :value], 'Rounding')
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::RoundingType) ? x : ::Io::Flow::V0::Models::RoundingType.apply(x))
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::RoundingMethod) ? x : ::Io::Flow::V0::Models::RoundingMethod.apply(x))
            @value = HttpClient::Preconditions.assert_class('value', HttpClient::Helper.to_big_decimal(opts.delete(:value)), BigDecimal)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Rounding.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :type => type.value,
              :method => method.value,
              :value => value
            }
          end

        end

        # Represents operating calendar and holidays of a center
        class Schedule

          attr_reader :calendar, :holiday, :exception, :cutoff, :min_lead_time, :max_lead_time

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:holiday, :exception], 'Schedule')
            @calendar = (x = opts.delete(:calendar); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Calendar) ? x : ::Io::Flow::V0::Models::Calendar.apply(x)))
            @holiday = (x = opts.delete(:holiday); x.is_a?(::Io::Flow::V0::Models::HolidayCalendar) ? x : ::Io::Flow::V0::Models::HolidayCalendar.apply(x))
            @exception = HttpClient::Preconditions.assert_class('exception', opts.delete(:exception), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Exception) ? x : ::Io::Flow::V0::Models::Exception.new(x)) }
            @cutoff = (x = opts.delete(:cutoff); x.nil? ? nil : HttpClient::Preconditions.assert_class('cutoff', x, String))
            @min_lead_time = (x = opts.delete(:min_lead_time); x.nil? ? nil : HttpClient::Preconditions.assert_class('min_lead_time', x, Integer))
            @max_lead_time = (x = opts.delete(:max_lead_time); x.nil? ? nil : HttpClient::Preconditions.assert_class('max_lead_time', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Schedule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :calendar => calendar.nil? ? nil : calendar.value,
              :holiday => holiday.value,
              :exception => exception.map { |o| o.to_hash },
              :cutoff => cutoff,
              :min_lead_time => min_lead_time,
              :max_lead_time => max_lead_time
            }
          end

        end

        # Allows a user to create a scheduled export that will be delivered on a
        # schedule (currently only support once / day at a set time)
        class ScheduledExport

          attr_reader :id, :user, :organization_q, :hour, :minute, :timezone, :types, :last_sent_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :user, :organization_q, :hour, :minute, :timezone, :types], 'ScheduledExport')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::UserReference) ? x : ::Io::Flow::V0::Models::UserReference.new(x))
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @hour = HttpClient::Preconditions.assert_class('hour', opts.delete(:hour), Integer)
            @minute = HttpClient::Preconditions.assert_class('minute', opts.delete(:minute), Integer)
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @types = HttpClient::Preconditions.assert_class('types', opts.delete(:types), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x)) }
            @last_sent_at = (x = opts.delete(:last_sent_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('last_sent_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledExport.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :user => user.to_hash,
              :organization_q => organization_q,
              :hour => hour,
              :minute => minute,
              :timezone => timezone,
              :types => types.map { |o| o.to_hash },
              :last_sent_at => last_sent_at
            }
          end

        end

        class ScheduledExportForm

          attr_reader :user_id, :organization_q, :hour, :minute, :timezone, :types

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:user_id, :organization_q, :hour, :minute, :timezone, :types], 'ScheduledExportForm')
            @user_id = HttpClient::Preconditions.assert_class('user_id', opts.delete(:user_id), String)
            @organization_q = HttpClient::Preconditions.assert_class('organization_q', opts.delete(:organization_q), String)
            @hour = HttpClient::Preconditions.assert_class('hour', opts.delete(:hour), Integer)
            @minute = HttpClient::Preconditions.assert_class('minute', opts.delete(:minute), Integer)
            @timezone = HttpClient::Preconditions.assert_class('timezone', opts.delete(:timezone), String)
            @types = HttpClient::Preconditions.assert_class('types', opts.delete(:types), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::ExportType) ? x : ::Io::Flow::V0::Models::ExportType.from_json(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledExportForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :user_id => user_id,
              :organization_q => organization_q,
              :hour => hour,
              :minute => minute,
              :timezone => timezone,
              :types => types.map { |o| o.to_hash }
            }
          end

        end

        class ScheduledPickup

          attr_reader :day_of_week, :hour_of_day, :minute_of_hour

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:day_of_week, :hour_of_day, :minute_of_hour], 'ScheduledPickup')
            @day_of_week = (x = opts.delete(:day_of_week); x.is_a?(::Io::Flow::V0::Models::DayOfWeek) ? x : ::Io::Flow::V0::Models::DayOfWeek.apply(x))
            @hour_of_day = HttpClient::Preconditions.assert_class('hour_of_day', opts.delete(:hour_of_day), String)
            @minute_of_hour = HttpClient::Preconditions.assert_class('minute_of_hour', opts.delete(:minute_of_hour), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ScheduledPickup.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :day_of_week => day_of_week.value,
              :hour_of_day => hour_of_day,
              :minute_of_hour => minute_of_hour
            }
          end

        end

        # Specific service rendered by the carrier (fedex ground saturday, ups overnight
        # weekend, etc)
        class Service

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'Service')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::Carrier) ? x : ::Io::Flow::V0::Models::Carrier.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Service.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        class ServiceReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'ServiceReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class ServiceSummary

          attr_reader :id, :carrier, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :name], 'ServiceSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = (x = opts.delete(:carrier); x.is_a?(::Io::Flow::V0::Models::CarrierReference) ? x : ::Io::Flow::V0::Models::CarrierReference.new(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ServiceSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier.to_hash,
              :name => name
            }
          end

        end

        # Authorize a request using a session id
        class SessionAuthorizationForm

          attr_reader :session

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:session], 'SessionAuthorizationForm')
            @session = HttpClient::Preconditions.assert_class('session', opts.delete(:session), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionAuthorizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :session => session
            }
          end

        end

        class SessionForm

          attr_reader :ip, :experience, :country, :currency, :language, :locale, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @locale = (x = opts.delete(:locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('locale', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :experience => experience,
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class SessionPutForm

          attr_reader :ip, :experience, :country, :currency, :language, :locale, :attributes

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @locale = (x = opts.delete(:locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('locale', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :experience => experience,
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale,
              :attributes => attributes.nil? ? nil : attributes
            }
          end

        end

        class SessionResetForm

          attr_reader :ip, :experience, :country, :currency, :language, :locale

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @experience = (x = opts.delete(:experience); x.nil? ? nil : HttpClient::Preconditions.assert_class('experience', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @currency = (x = opts.delete(:currency); x.nil? ? nil : HttpClient::Preconditions.assert_class('currency', x, String))
            @language = (x = opts.delete(:language); x.nil? ? nil : HttpClient::Preconditions.assert_class('language', x, String))
            @locale = (x = opts.delete(:locale); x.nil? ? nil : HttpClient::Preconditions.assert_class('locale', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SessionResetForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :ip => ip,
              :experience => experience,
              :country => country,
              :currency => currency,
              :language => language,
              :locale => locale
            }
          end

        end

        class ShippingAddress

          attr_reader :contact, :location

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:contact, :location], 'ShippingAddress')
            @contact = (x = opts.delete(:contact); x.is_a?(::Io::Flow::V0::Models::Contact) ? x : ::Io::Flow::V0::Models::Contact.new(x))
            @location = (x = opts.delete(:location); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingAddress.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :contact => contact.to_hash,
              :location => location.to_hash
            }
          end

        end

        # Represents information about a carrier-generated shipping label used by a
        # shipper to transport a package from a given origin to destination
        class ShippingLabel

          attr_reader :id, :direction, :attributes, :carrier_tracking_number, :carrier_tracking_number_url, :cost, :destination, :flow_tracking_number, :flow_tracking_number_url, :origin, :service, :window, :commercial_invoice, :zpl, :pdf, :png, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :direction, :carrier_tracking_number, :carrier_tracking_number_url, :cost, :destination, :flow_tracking_number, :flow_tracking_number_url, :origin, :service, :window], 'ShippingLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @direction = (x = opts.delete(:direction); x.is_a?(::Io::Flow::V0::Models::Direction) ? x : ::Io::Flow::V0::Models::Direction.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @carrier_tracking_number_url = HttpClient::Preconditions.assert_class('carrier_tracking_number_url', opts.delete(:carrier_tracking_number_url), String)
            @cost = (x = opts.delete(:cost); x.is_a?(::Io::Flow::V0::Models::Price) ? x : ::Io::Flow::V0::Models::Price.new(x))
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @flow_tracking_number_url = HttpClient::Preconditions.assert_class('flow_tracking_number_url', opts.delete(:flow_tracking_number_url), String)
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @commercial_invoice = (x = opts.delete(:commercial_invoice); x.nil? ? nil : HttpClient::Preconditions.assert_class('commercial_invoice', x, String))
            @zpl = (x = opts.delete(:zpl); x.nil? ? nil : HttpClient::Preconditions.assert_class('zpl', x, String))
            @pdf = (x = opts.delete(:pdf); x.nil? ? nil : HttpClient::Preconditions.assert_class('pdf', x, String))
            @png = (x = opts.delete(:png); x.nil? ? nil : HttpClient::Preconditions.assert_class('png', x, String))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LabelOrderSummary) ? x : ::Io::Flow::V0::Models::LabelOrderSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :direction => direction.value,
              :attributes => attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :carrier_tracking_number_url => carrier_tracking_number_url,
              :cost => cost.to_hash,
              :destination => destination.to_hash,
              :flow_tracking_number => flow_tracking_number,
              :flow_tracking_number_url => flow_tracking_number_url,
              :origin => origin.to_hash,
              :service => service.to_hash,
              :window => window.to_hash,
              :commercial_invoice => commercial_invoice,
              :zpl => zpl,
              :pdf => pdf,
              :png => png,
              :order => order.nil? ? nil : order.to_hash
            }
          end

        end

        class ShippingLabelForm

          attr_reader :destination, :origin, :package, :attributes, :delivered_duty, :direction, :order_number, :service

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:destination, :origin, :package], 'ShippingLabelForm')
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @delivered_duty = (x = opts.delete(:delivered_duty); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DeliveredDuty) ? x : ::Io::Flow::V0::Models::DeliveredDuty.apply(x)))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Direction) ? x : ::Io::Flow::V0::Models::Direction.apply(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @service = (x = opts.delete(:service); x.nil? ? nil : HttpClient::Preconditions.assert_class('service', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :destination => destination.to_hash,
              :origin => origin.to_hash,
              :package => package.to_hash,
              :attributes => attributes.nil? ? nil : attributes,
              :delivered_duty => delivered_duty.nil? ? nil : delivered_duty.value,
              :direction => direction.nil? ? nil : direction.value,
              :order_number => order_number,
              :service => service
            }
          end

        end

        # Describes a package to be shipped, including dimensions and items included
        class ShippingLabelPackage

          attr_reader :dimensions, :items

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:dimensions, :items], 'ShippingLabelPackage')
            @dimensions = (x = opts.delete(:dimensions); x.is_a?(::Io::Flow::V0::Models::Dimension) ? x : ::Io::Flow::V0::Models::Dimension.new(x))
            @items = HttpClient::Preconditions.assert_class('items', opts.delete(:items), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LineItemForm) ? x : ::Io::Flow::V0::Models::LineItemForm.new(x)) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelPackage.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :dimensions => dimensions.to_hash,
              :items => items.map { |o| o.to_hash }
            }
          end

        end

        class ShippingLabelVersion

          attr_reader :id, :timestamp, :type, :shipping_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_label], 'ShippingLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_label = (x = opts.delete(:shipping_label); x.is_a?(::Io::Flow::V0::Models::ShippingLabel) ? x : ::Io::Flow::V0::Models::ShippingLabel.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_label => shipping_label.to_hash
            }
          end

        end

        # Represents information about a client-facilitated shipment where the shipping
        # label and fulfillment was not handled by Flow. For merchant-of-record and
        # tracking purposes, clients doing their own shipping will need to notify Flow
        # of shipped packages.
        class ShippingNotification

          attr_reader :id, :key, :attributes, :carrier_tracking_number, :destination, :flow_tracking_number, :origin, :package, :service, :window, :order

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :carrier_tracking_number, :destination, :flow_tracking_number, :origin, :package, :service, :window], 'ShippingNotification')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @attributes = HttpClient::Preconditions.assert_class('attributes', (x = opts.delete(:attributes); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @origin = (x = opts.delete(:origin); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @service = (x = opts.delete(:service); x.is_a?(::Io::Flow::V0::Models::ServiceSummary) ? x : ::Io::Flow::V0::Models::ServiceSummary.new(x))
            @window = (x = opts.delete(:window); x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x))
            @order = (x = opts.delete(:order); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LabelOrderSummary) ? x : ::Io::Flow::V0::Models::LabelOrderSummary.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingNotification.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :attributes => attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :destination => destination.to_hash,
              :flow_tracking_number => flow_tracking_number,
              :origin => origin.to_hash,
              :package => package.to_hash,
              :service => service.to_hash,
              :window => window.to_hash,
              :order => order.nil? ? nil : order.to_hash
            }
          end

        end

        # Form for information about a client-facilitated shipment where the shipping
        # label and fulfillment was not handled by Flow. For merchant-of-record and
        # tracking purposes, clients doing their own shipping will need to notify Flow
        # of shipped packages.
        class ShippingNotificationForm

          attr_reader :key, :attributes, :carrier_tracking_number, :destination, :order_number, :package, :service, :origin

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:carrier_tracking_number, :destination, :order_number, :package, :service], 'ShippingNotificationForm')
            @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @destination = (x = opts.delete(:destination); x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x))
            @order_number = HttpClient::Preconditions.assert_class('order_number', opts.delete(:order_number), String)
            @package = (x = opts.delete(:package); x.is_a?(::Io::Flow::V0::Models::ShippingLabelPackage) ? x : ::Io::Flow::V0::Models::ShippingLabelPackage.new(x))
            @service = HttpClient::Preconditions.assert_class('service', opts.delete(:service), String)
            @origin = (x = opts.delete(:origin); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ShippingAddress) ? x : ::Io::Flow::V0::Models::ShippingAddress.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingNotificationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :attributes => attributes.nil? ? nil : attributes,
              :carrier_tracking_number => carrier_tracking_number,
              :destination => destination.to_hash,
              :order_number => order_number,
              :package => package.to_hash,
              :service => service,
              :origin => origin.nil? ? nil : origin.to_hash
            }
          end

        end

        class ShippingNotificationVersion

          attr_reader :id, :timestamp, :type, :shipping_notification

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :shipping_notification], 'ShippingNotificationVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @shipping_notification = (x = opts.delete(:shipping_notification); x.is_a?(::Io::Flow::V0::Models::ShippingNotification) ? x : ::Io::Flow::V0::Models::ShippingNotification.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShippingNotificationVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :shipping_notification => shipping_notification.to_hash
            }
          end

        end

        class ShopifySession < Session

          attr_reader :id, :organization, :environment, :attributes, :ip, :local, :shop, :cart, :experiments

          def initialize(incoming={})
            super(:discriminator => Session::Types::SHOPIFY_SESSION)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :organization, :environment, :attributes, :shop, :cart], 'ShopifySession')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @environment = (x = opts.delete(:environment); x.is_a?(::Io::Flow::V0::Models::Environment) ? x : ::Io::Flow::V0::Models::Environment.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @ip = (x = opts.delete(:ip); x.nil? ? nil : HttpClient::Preconditions.assert_class('ip', x, String))
            @local = (x = opts.delete(:local); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::LocalSession) ? x : ::Io::Flow::V0::Models::LocalSession.new(x)))
            @shop = HttpClient::Preconditions.assert_class('shop', opts.delete(:shop), String)
            @cart = (x = opts.delete(:cart); x.is_a?(::Io::Flow::V0::Models::CartReference) ? x : ::Io::Flow::V0::Models::CartReference.new(x))
            @experiments = HttpClient::Preconditions.assert_class('experiments', (x = opts.delete(:experiments); x.nil? ? {} : x), Hash).inject({}) { |h, d| h[d[0]] = (x = d[1]; x.is_a?(::Io::Flow::V0::Models::ExperimentStatus) ? x : ::Io::Flow::V0::Models::ExperimentStatus.new(x)); h }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            ShopifySession.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :organization => organization,
              :environment => environment.value,
              :attributes => attributes,
              :ip => ip,
              :local => local.nil? ? nil : local.to_hash,
              :shop => shop,
              :cart => cart.to_hash,
              :experiments => experiments.inject({}) { |hash, o| hash[o[0]] = o[1].nil? ? nil : o[1].to_hash; hash }
            }
          end

        end

        class SnapshotDeleted < Event

          attr_reader :event_id, :timestamp, :snapshot_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SNAPSHOT_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :snapshot_id], 'SnapshotDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @snapshot_id = HttpClient::Preconditions.assert_class('snapshot_id', opts.delete(:snapshot_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SnapshotDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :snapshot_id => snapshot_id
            }
          end

        end

        class SnapshotUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :snapshot_id, :available, :center_key, :item_number, :quantity

          def initialize(incoming={})
            super(:discriminator => Event::Types::SNAPSHOT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :snapshot_id, :available, :center_key, :item_number, :quantity], 'SnapshotUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @snapshot_id = HttpClient::Preconditions.assert_class('snapshot_id', opts.delete(:snapshot_id), String)
            @available = HttpClient::Preconditions.assert_class('available', opts.delete(:available), Integer)
            @center_key = HttpClient::Preconditions.assert_class('center_key', opts.delete(:center_key), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @quantity = HttpClient::Preconditions.assert_class('quantity', opts.delete(:quantity), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SnapshotUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :snapshot_id => snapshot_id,
              :available => available,
              :center_key => center_key,
              :item_number => item_number,
              :quantity => quantity
            }
          end

        end

        # Exports product level data for import into solidus
        class SolidusProductExportType < ExportType

          attr_reader :numbers, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::SOLIDUS_PRODUCT_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SolidusProductExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :sort => sort
            }
          end

        end

        # Exports variant level data for import into solidus
        class SolidusVariantExportType < ExportType

          attr_reader :numbers, :sort

          def initialize(incoming={})
            super(:discriminator => ExportType::Types::SOLIDUS_VARIANT_EXPORT_TYPE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @numbers = (x = opts.delete(:numbers); x.nil? ? nil : HttpClient::Preconditions.assert_class('numbers', x, Array).map { |v| HttpClient::Preconditions.assert_class('numbers', v, String) })
            @sort = (x = opts.delete(:sort); x.nil? ? nil : HttpClient::Preconditions.assert_class('sort', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SolidusVariantExportType.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :numbers => numbers.nil? ? nil : numbers,
              :sort => sort
            }
          end

        end

        # A configuration with custom query to select a subset of master catalog items
        # for a localized experience
        class Subcatalog < ExpandableSubcatalog

          attr_reader :id, :catalog, :settings

          def initialize(incoming={})
            super(:discriminator => ExpandableSubcatalog::Types::SUBCATALOG)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :catalog, :settings], 'Subcatalog')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::Catalog) ? x : ::Io::Flow::V0::Models::Catalog.new(x))
            @settings = (x = opts.delete(:settings); x.is_a?(::Io::Flow::V0::Models::SubcatalogSettings) ? x : ::Io::Flow::V0::Models::SubcatalogSettings.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Subcatalog.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :catalog => catalog.to_hash,
              :settings => settings.to_hash
            }
          end

        end

        class SubcatalogDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog, :subcatalog_id], 'SubcatalogDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogForm

          attr_reader :settings

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @settings = (x = opts.delete(:settings); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogSettingsForm) ? x : ::Io::Flow::V0::Models::SubcatalogSettingsForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :settings => settings.nil? ? nil : settings.to_hash
            }
          end

        end

        class SubcatalogFunction

          attr_reader :id, :item_function, :q, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item_function, :q, :position], 'SubcatalogFunction')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item_function = (x = opts.delete(:item_function); x.is_a?(::Io::Flow::V0::Models::ItemFunction) ? x : ::Io::Flow::V0::Models::ItemFunction.new(x))
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunction.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item_function => item_function.to_hash,
              :q => q,
              :position => position
            }
          end

        end

        class SubcatalogFunctionForm

          attr_reader :item_function_id, :q, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:item_function_id], 'SubcatalogFunctionForm')
            @item_function_id = HttpClient::Preconditions.assert_class('item_function_id', opts.delete(:item_function_id), String)
            @q = (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String))
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunctionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :item_function_id => item_function_id,
              :q => q,
              :position => position
            }
          end

        end

        class SubcatalogFunctionVersion

          attr_reader :id, :timestamp, :type, :subcatalog_function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog_function], 'SubcatalogFunctionVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog_function = (x = opts.delete(:subcatalog_function); x.is_a?(::Io::Flow::V0::Models::SubcatalogFunction) ? x : ::Io::Flow::V0::Models::SubcatalogFunction.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogFunctionVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog_function => subcatalog_function.to_hash
            }
          end

        end

        # Represents information specific to an item in a given subcatalog
        class SubcatalogItem

          attr_reader :id, :item, :status, :item_function

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :item, :status], 'SubcatalogItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @item = (x = opts.delete(:item); x.is_a?(::Io::Flow::V0::Models::Item) ? x : ::Io::Flow::V0::Models::Item.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::SubcatalogItemStatus) ? x : ::Io::Flow::V0::Models::SubcatalogItemStatus.apply(x))
            @item_function = (x = opts.delete(:item_function); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::ExpandableItemFunction) ? x : ::Io::Flow::V0::Models::ExpandableItemFunction.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :item => item.to_hash,
              :status => status.value,
              :item_function => item_function.nil? ? nil : item_function.to_hash
            }
          end

        end

        class SubcatalogItemDeleted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id], 'SubcatalogItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id, :status, :function_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :number, :catalog, :subcatalog_id, :status], 'SubcatalogItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @number = HttpClient::Preconditions.assert_class('number', opts.delete(:number), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
            @function_id = (x = opts.delete(:function_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('function_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :number => number,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id,
              :status => status,
              :function_id => function_id
            }
          end

        end

        class SubcatalogItemVersion

          attr_reader :id, :timestamp, :type, :subcatalog_item

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog_item], 'SubcatalogItemVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog_item = (x = opts.delete(:subcatalog_item); x.is_a?(::Io::Flow::V0::Models::SubcatalogItem) ? x : ::Io::Flow::V0::Models::SubcatalogItem.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogItemVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog_item => subcatalog_item.to_hash
            }
          end

        end

        class SubcatalogReference < ExpandableSubcatalog

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableSubcatalog::Types::SUBCATALOG_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'SubcatalogReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class SubcatalogSettings

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = (x = opts.delete(:update_policy); x.nil? ? "auto" : x); x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.value
            }
          end

        end

        class SubcatalogSettingsForm

          attr_reader :update_policy

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @update_policy = (x = opts.delete(:update_policy); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::UpdatePolicy) ? x : ::Io::Flow::V0::Models::UpdatePolicy.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogSettingsForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :update_policy => update_policy.nil? ? nil : update_policy.value
            }
          end

        end

        # Statistics related to the items in this subcatalog, including item count,
        # number of distinct categories, etc.
        class SubcatalogStatistics

          attr_reader :excluded, :included, :restricted, :queue, :catalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:excluded, :included, :restricted, :queue, :catalog], 'SubcatalogStatistics')
            @excluded = (x = opts.delete(:excluded); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @included = (x = opts.delete(:included); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @restricted = (x = opts.delete(:restricted); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @queue = (x = opts.delete(:queue); x.is_a?(::Io::Flow::V0::Models::ItemStatistics) ? x : ::Io::Flow::V0::Models::ItemStatistics.new(x))
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogStatistics) ? x : ::Io::Flow::V0::Models::CatalogStatistics.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogStatistics.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :excluded => excluded.to_hash,
              :included => included.to_hash,
              :restricted => restricted.to_hash,
              :queue => queue.to_hash,
              :catalog => catalog.to_hash
            }
          end

        end

        class SubcatalogUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :catalog, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::SUBCATALOG_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :catalog, :subcatalog_id], 'SubcatalogUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @catalog = HttpClient::Preconditions.assert_class('catalog', opts.delete(:catalog), String)
            @subcatalog_id = HttpClient::Preconditions.assert_class('subcatalog_id', opts.delete(:subcatalog_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :catalog => catalog,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class SubcatalogVersion

          attr_reader :id, :timestamp, :type, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :subcatalog], 'SubcatalogVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.is_a?(::Io::Flow::V0::Models::Subcatalog) ? x : ::Io::Flow::V0::Models::Subcatalog.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            SubcatalogVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :subcatalog => subcatalog.to_hash
            }
          end

        end

        class Suggestion

          attr_reader :label, :count

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:label, :count], 'Suggestion')
            @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
            @count = HttpClient::Preconditions.assert_class('count', opts.delete(:count), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Suggestion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :label => label,
              :count => count
            }
          end

        end

        class Targeting

          attr_reader :id, :key, :queries, :catalog, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :queries, :catalog], 'Targeting')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @queries = HttpClient::Preconditions.assert_class('queries', opts.delete(:queries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TargetingQuery) ? x : ::Io::Flow::V0::Models::TargetingQuery.new(x)) }
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogReference) ? x : ::Io::Flow::V0::Models::CatalogReference.new(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Targeting.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :queries => queries.map { |o| o.to_hash },
              :catalog => catalog.to_hash,
              :subcatalog => subcatalog.nil? ? nil : subcatalog.to_hash
            }
          end

        end

        class TargetingForm

          attr_reader :key, :queries, :subcatalog_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:key, :queries], 'TargetingForm')
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @queries = HttpClient::Preconditions.assert_class('queries', opts.delete(:queries), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TargetingQueryForm) ? x : ::Io::Flow::V0::Models::TargetingQueryForm.new(x)) }
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :key => key,
              :queries => queries.map { |o| o.to_hash },
              :subcatalog_id => subcatalog_id
            }
          end

        end

        # Represents catalog items where a targeteing query is applicable
        class TargetingItem

          attr_reader :id, :targeting, :item_number, :query

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :targeting, :item_number, :query], 'TargetingItem')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @targeting = (x = opts.delete(:targeting); x.is_a?(::Io::Flow::V0::Models::TargetingSummary) ? x : ::Io::Flow::V0::Models::TargetingSummary.new(x))
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @query = (x = opts.delete(:query); x.is_a?(::Io::Flow::V0::Models::TargetingQuery) ? x : ::Io::Flow::V0::Models::TargetingQuery.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItem.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :targeting => targeting.to_hash,
              :item_number => item_number,
              :query => query.to_hash
            }
          end

        end

        class TargetingItemDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'TargetingItemDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # Indiciates that a given item has been targeted by the query q producing an
        # outcome. The item number is unique within its targeting_id.
        class TargetingItemUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :targeting_id, :item_number, :q, :outcome_id, :catalog_id, :key, :subcatalog_id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TARGETING_ITEM_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :targeting_id, :item_number, :q, :outcome_id, :catalog_id, :key], 'TargetingItemUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @targeting_id = HttpClient::Preconditions.assert_class('targeting_id', opts.delete(:targeting_id), String)
            @item_number = HttpClient::Preconditions.assert_class('item_number', opts.delete(:item_number), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
            @catalog_id = HttpClient::Preconditions.assert_class('catalog_id', opts.delete(:catalog_id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @subcatalog_id = (x = opts.delete(:subcatalog_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('subcatalog_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingItemUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :targeting_id => targeting_id,
              :item_number => item_number,
              :q => q,
              :outcome_id => outcome_id,
              :catalog_id => catalog_id,
              :key => key,
              :subcatalog_id => subcatalog_id
            }
          end

        end

        class TargetingQuery

          attr_reader :id, :q, :outcome_id, :position

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :q, :outcome_id, :position], 'TargetingQuery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingQuery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :q => q,
              :outcome_id => outcome_id,
              :position => position
            }
          end

        end

        class TargetingQueryForm

          attr_reader :q, :outcome_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:q, :outcome_id], 'TargetingQueryForm')
            @q = HttpClient::Preconditions.assert_class('q', opts.delete(:q), String)
            @outcome_id = HttpClient::Preconditions.assert_class('outcome_id', opts.delete(:outcome_id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingQueryForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :q => q,
              :outcome_id => outcome_id
            }
          end

        end

        class TargetingSummary

          attr_reader :id, :key, :catalog, :subcatalog

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :key, :catalog], 'TargetingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            @catalog = (x = opts.delete(:catalog); x.is_a?(::Io::Flow::V0::Models::CatalogReference) ? x : ::Io::Flow::V0::Models::CatalogReference.new(x))
            @subcatalog = (x = opts.delete(:subcatalog); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::SubcatalogReference) ? x : ::Io::Flow::V0::Models::SubcatalogReference.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :key => key,
              :catalog => catalog.to_hash,
              :subcatalog => subcatalog.nil? ? nil : subcatalog.to_hash
            }
          end

        end

        class TargetingVersion

          attr_reader :id, :timestamp, :type, :targeting

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :targeting], 'TargetingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @targeting = (x = opts.delete(:targeting); x.is_a?(::Io::Flow::V0::Models::Targeting) ? x : ::Io::Flow::V0::Models::Targeting.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TargetingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :targeting => targeting.to_hash
            }
          end

        end

        # Represents a simple model of taxes that apply to a given item / destination.
        class Tax

          attr_reader :name, :rate, :components, :deminimis

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :rate, :components], 'Tax')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rate = HttpClient::Preconditions.assert_class('rate', HttpClient::Helper.to_big_decimal(opts.delete(:rate)), BigDecimal)
            @components = HttpClient::Preconditions.assert_class('components', opts.delete(:components), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::LevyComponent) ? x : ::Io::Flow::V0::Models::LevyComponent.apply(x)) }
            @deminimis = (x = opts.delete(:deminimis); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::Deminimis) ? x : ::Io::Flow::V0::Models::Deminimis.from_json(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tax.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :rate => rate,
              :components => components.map { |o| o.value },
              :deminimis => deminimis.nil? ? nil : deminimis.to_hash
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class Tier

          attr_reader :id, :direction, :experience, :integration, :name, :rules, :services, :strategy, :visibility, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'Tier')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @direction = (x = (x = opts.delete(:direction); x.nil? ? "outbound" : x); x.is_a?(::Io::Flow::V0::Models::TierDirection) ? x : ::Io::Flow::V0::Models::TierDirection.apply(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Service) ? x : ::Io::Flow::V0::Models::Service.new(x)) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tier.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :direction => direction.value,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services.map { |o| o.to_hash },
              :strategy => strategy.value,
              :visibility => visibility.value,
              :description => description
            }
          end

        end

        # Grouping of shipping tiers by experience to provide logical default
        # functionality.
        class TierDefault

          attr_reader :id, :default_tier, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :default_tier, :experience], 'TierDefault')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @default_tier = (x = opts.delete(:default_tier); x.is_a?(::Io::Flow::V0::Models::TierReference) ? x : ::Io::Flow::V0::Models::TierReference.new(x))
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefault.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :default_tier => default_tier.to_hash,
              :experience => experience.to_hash
            }
          end

        end

        # Form to set the defualt tier for a given experience
        class TierDefaultForm

          attr_reader :default_tier, :currency, :experience

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:default_tier, :currency, :experience], 'TierDefaultForm')
            @default_tier = HttpClient::Preconditions.assert_class('default_tier', opts.delete(:default_tier), String)
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefaultForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :default_tier => default_tier,
              :currency => currency,
              :experience => experience
            }
          end

        end

        class TierDefaultVersion

          attr_reader :id, :timestamp, :type, :tier_default

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier_default], 'TierDefaultVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier_default = (x = opts.delete(:tier_default); x.is_a?(::Io::Flow::V0::Models::TierDefault) ? x : ::Io::Flow::V0::Models::TierDefault.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDefaultVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier_default => tier_default.to_hash
            }
          end

        end

        class TierDeleted < Event

          attr_reader :event_id, :timestamp, :id

          def initialize(incoming={})
            super(:discriminator => Event::Types::TIER_DELETED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :id], 'TierDeleted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierDeleted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :id => id
            }
          end

        end

        # Service shipping tier available in this tier gorup. e.g. Standard tier,
        # Express tier, Economy tier
        class TierForm

          attr_reader :currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility, :description, :direction

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:currency, :experience, :integration, :name, :rules, :services, :strategy, :visibility], 'TierForm')
            @currency = HttpClient::Preconditions.assert_class('currency', opts.delete(:currency), String)
            @experience = HttpClient::Preconditions.assert_class('experience', opts.delete(:experience), String)
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TierRuleForm) ? x : ::Io::Flow::V0::Models::TierRuleForm.new(x)) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @direction = (x = opts.delete(:direction); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TierDirection) ? x : ::Io::Flow::V0::Models::TierDirection.apply(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :currency => currency,
              :experience => experience,
              :integration => integration.value,
              :name => name,
              :rules => rules.map { |o| o.to_hash },
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value,
              :description => description,
              :direction => direction.nil? ? nil : direction.value
            }
          end

        end

        class TierReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TierReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # System to filter incoming quote for a shipment request based on a query and
        # output corresponding outcomes.
        class TierRule

          attr_reader :id, :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :position, :query, :outcome], 'TierRule')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @position = HttpClient::Preconditions.assert_class('position', opts.delete(:position), Integer)
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcome) ? x : ::Io::Flow::V0::Models::TierRuleOutcome.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRule.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleForm

          attr_reader :position, :query, :outcome

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:query, :outcome], 'TierRuleForm')
            @position = (x = opts.delete(:position); x.nil? ? nil : HttpClient::Preconditions.assert_class('position', x, Integer))
            @query = HttpClient::Preconditions.assert_class('query', opts.delete(:query), String)
            @outcome = (x = opts.delete(:outcome); x.is_a?(::Io::Flow::V0::Models::TierRuleOutcomeForm) ? x : ::Io::Flow::V0::Models::TierRuleOutcomeForm.from_json(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :position => position,
              :query => query,
              :outcome => outcome.to_hash
            }
          end

        end

        class TierRuleVersion

          attr_reader :id, :timestamp, :type, :tier_rule

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier_rule], 'TierRuleVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier_rule = (x = opts.delete(:tier_rule); x.is_a?(::Io::Flow::V0::Models::TierRule) ? x : ::Io::Flow::V0::Models::TierRule.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierRuleVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier_rule => tier_rule.to_hash
            }
          end

        end

        class TierSummary

          attr_reader :id, :experience, :integration, :name, :services, :strategy, :visibility

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :experience, :integration, :name, :services, :strategy, :visibility], 'TierSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience = (x = opts.delete(:experience); x.is_a?(::Io::Flow::V0::Models::FulfillmentExperienceReference) ? x : ::Io::Flow::V0::Models::FulfillmentExperienceReference.new(x))
            @integration = (x = opts.delete(:integration); x.is_a?(::Io::Flow::V0::Models::ShipmentIntegrationType) ? x : ::Io::Flow::V0::Models::ShipmentIntegrationType.apply(x))
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', v, String) }
            @strategy = (x = opts.delete(:strategy); x.is_a?(::Io::Flow::V0::Models::TierStrategy) ? x : ::Io::Flow::V0::Models::TierStrategy.apply(x))
            @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Flow::V0::Models::Visibility) ? x : ::Io::Flow::V0::Models::Visibility.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :experience => experience.to_hash,
              :integration => integration.value,
              :name => name,
              :services => services,
              :strategy => strategy.value,
              :visibility => visibility.value
            }
          end

        end

        class TierUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :id, :experience_key, :integration, :name, :rules, :services, :strategy, :visibility, :description

          def initialize(incoming={})
            super(:discriminator => Event::Types::TIER_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :id, :experience_key, :integration, :name, :rules, :services, :strategy, :visibility], 'TierUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @experience_key = HttpClient::Preconditions.assert_class('experience_key', opts.delete(:experience_key), String)
            @integration = HttpClient::Preconditions.assert_class('integration', opts.delete(:integration), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @rules = HttpClient::Preconditions.assert_class('rules', opts.delete(:rules), Array).map { |v| HttpClient::Preconditions.assert_class('rules', HttpClient::Helper.to_object(v), Hash) }
            @services = HttpClient::Preconditions.assert_class('services', opts.delete(:services), Array).map { |v| HttpClient::Preconditions.assert_class('services', HttpClient::Helper.to_object(v), Hash) }
            @strategy = HttpClient::Preconditions.assert_class('strategy', opts.delete(:strategy), String)
            @visibility = HttpClient::Preconditions.assert_class('visibility', opts.delete(:visibility), String)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :id => id,
              :experience_key => experience_key,
              :integration => integration,
              :name => name,
              :rules => rules,
              :services => services,
              :strategy => strategy,
              :visibility => visibility,
              :description => description
            }
          end

        end

        class TierVersion

          attr_reader :id, :timestamp, :type, :tier

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tier], 'TierVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tier = (x = opts.delete(:tier); x.is_a?(::Io::Flow::V0::Models::TierSummary) ? x : ::Io::Flow::V0::Models::TierSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TierVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tier => tier.to_hash
            }
          end

        end

        # Time zone data is provided by the public IANA time zone database. See
        # http://www.iana.org/time-zones
        class Timezone

          attr_reader :name, :description, :offset

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:name, :description, :offset], 'Timezone')
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            @offset = HttpClient::Preconditions.assert_class('offset', opts.delete(:offset), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Timezone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :name => name,
              :description => description,
              :offset => offset
            }
          end

        end

        # Used to authenticate a given token.
        class TokenAuthenticationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenAuthenticationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenAuthenticationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        class TokenPartnerReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'TokenPartnerReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenPartnerReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        # Model used to report whether or not a given token is valid
        class TokenValidation

          attr_reader :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:status], 'TokenValidation')
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenValidation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status
            }
          end

        end

        # Defines the payload of a request to validate a token, with primary goal of
        # preventing the token from being included in an HTTP GET.
        class TokenValidationForm

          attr_reader :token

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:token], 'TokenValidationForm')
            @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TokenValidationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :token => token
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class Tracking

          attr_reader :id, :labels, :status, :attributes, :window, :order_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :labels, :status, :attributes], 'Tracking')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @labels = HttpClient::Preconditions.assert_class('labels', opts.delete(:labels), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TrackingLabel) ? x : ::Io::Flow::V0::Models::TrackingLabel.new(x)) }
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @attributes = HttpClient::Preconditions.assert_class('attributes', opts.delete(:attributes), Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h }
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Tracking.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :labels => labels.map { |o| o.to_hash },
              :status => status.value,
              :attributes => attributes,
              :window => window.nil? ? nil : window.to_hash,
              :order_number => order_number
            }
          end

        end

        class TrackingEvent

          attr_reader :id, :address, :status, :timestamp, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :address, :status, :timestamp], 'TrackingEvent')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @address = (x = opts.delete(:address); x.is_a?(::Io::Flow::V0::Models::Address) ? x : ::Io::Flow::V0::Models::Address.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEvent.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :address => address.to_hash,
              :status => status.value,
              :timestamp => timestamp,
              :description => description
            }
          end

        end

        class TrackingEventForm

          attr_reader :tracking_label_id, :timestamp, :status, :description, :address

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_label_id, :timestamp, :status], 'TrackingEventForm')
            @tracking_label_id = HttpClient::Preconditions.assert_class('tracking_label_id', opts.delete(:tracking_label_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @address = (x = opts.delete(:address); x.nil? ? nil : HttpClient::Preconditions.assert_class('address', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_label_id => tracking_label_id,
              :timestamp => timestamp,
              :status => status.value,
              :description => description,
              :address => address
            }
          end

        end

        class TrackingEventSummary

          attr_reader :id, :status, :timestamp

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status, :timestamp], 'TrackingEventSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :timestamp => timestamp
            }
          end

        end

        class TrackingEventVersion

          attr_reader :id, :timestamp, :type, :tracking_event

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking_event], 'TrackingEventVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking_event = (x = opts.delete(:tracking_event); x.is_a?(::Io::Flow::V0::Models::TrackingEventSummary) ? x : ::Io::Flow::V0::Models::TrackingEventSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingEventVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking_event => tracking_event.to_hash
            }
          end

        end

        # Top level tracking information which contains labels. In cases where shipments
        # are re-labeled, you will see multiple labels for each tracking allowing simple
        # access to see where a shipment is - with which carrier and with the local
        # tracking number
        class TrackingForm

          attr_reader :status, :order_number, :attributes, :window

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @status = (x = opts.delete(:status); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x)))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
            @attributes = (x = opts.delete(:attributes); x.nil? ? nil : HttpClient::Preconditions.assert_class('attributes', x, Hash).inject({}) { |h, d| h[d[0]] = HttpClient::Preconditions.assert_class('attributes', d[1], String); h })
            @window = (x = opts.delete(:window); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::DatetimeRange) ? x : ::Io::Flow::V0::Models::DatetimeRange.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :status => status.nil? ? nil : status.value,
              :order_number => order_number,
              :attributes => attributes.nil? ? nil : attributes,
              :window => window.nil? ? nil : window.to_hash
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class TrackingLabel

          attr_reader :id, :carrier, :carrier_tracking_number, :events, :status, :timestamp, :delivery_estimate, :description

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :carrier, :carrier_tracking_number, :events, :status, :timestamp], 'TrackingLabel')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::TrackingEvent) ? x : ::Io::Flow::V0::Models::TrackingEvent.new(x)) }
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabel.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :carrier => carrier,
              :carrier_tracking_number => carrier_tracking_number,
              :events => events.map { |o| o.to_hash },
              :status => status.value,
              :timestamp => timestamp,
              :delivery_estimate => delivery_estimate,
              :description => description
            }
          end

        end

        class TrackingLabelEventUpserted < Event

          attr_reader :event_id, :timestamp, :organization, :address, :carrier, :carrier_timestamp, :carrier_tracking_number, :flow_tracking_number, :status, :delivery_estimate, :description, :order_number

          def initialize(incoming={})
            super(:discriminator => Event::Types::TRACKING_LABEL_EVENT_UPSERTED)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:event_id, :timestamp, :organization, :address, :carrier, :carrier_timestamp, :carrier_tracking_number, :flow_tracking_number, :status], 'TrackingLabelEventUpserted')
            @event_id = HttpClient::Preconditions.assert_class('event_id', opts.delete(:event_id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @organization = HttpClient::Preconditions.assert_class('organization', opts.delete(:organization), String)
            @address = HttpClient::Preconditions.assert_class('address', HttpClient::Helper.to_object(opts.delete(:address)), Hash)
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_timestamp = HttpClient::Preconditions.assert_class('carrier_timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:carrier_timestamp)), DateTime)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @flow_tracking_number = HttpClient::Preconditions.assert_class('flow_tracking_number', opts.delete(:flow_tracking_number), String)
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelEventUpserted.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :event_id => event_id,
              :timestamp => timestamp,
              :organization => organization,
              :address => address,
              :carrier => carrier,
              :carrier_timestamp => carrier_timestamp,
              :carrier_tracking_number => carrier_tracking_number,
              :flow_tracking_number => flow_tracking_number,
              :status => status,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :order_number => order_number
            }
          end

        end

        # Represents a specific label being tracked as part of the tracking bucket
        class TrackingLabelForm

          attr_reader :tracking_id, :status, :carrier, :carrier_tracking_number, :delivery_estimate, :description, :timestamp, :parent_id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:tracking_id, :carrier, :carrier_tracking_number], 'TrackingLabelForm')
            @tracking_id = HttpClient::Preconditions.assert_class('tracking_id', opts.delete(:tracking_id), String)
            @status = (x = (x = opts.delete(:status); x.nil? ? "pending" : x); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @carrier_tracking_number = HttpClient::Preconditions.assert_class('carrier_tracking_number', opts.delete(:carrier_tracking_number), String)
            @delivery_estimate = (x = opts.delete(:delivery_estimate); x.nil? ? nil : HttpClient::Preconditions.assert_class('delivery_estimate', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            @timestamp = (x = opts.delete(:timestamp); x.nil? ? nil : HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @parent_id = (x = opts.delete(:parent_id); x.nil? ? nil : HttpClient::Preconditions.assert_class('parent_id', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :tracking_id => tracking_id,
              :status => status.value,
              :carrier => carrier,
              :carrier_tracking_number => carrier_tracking_number,
              :delivery_estimate => delivery_estimate,
              :description => description,
              :timestamp => timestamp,
              :parent_id => parent_id
            }
          end

        end

        class TrackingLabelSummary

          attr_reader :id, :tracking, :status, :carrier, :tracking_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :tracking, :status, :carrier, :tracking_number], 'TrackingLabelSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @carrier = HttpClient::Preconditions.assert_class('carrier', opts.delete(:carrier), String)
            @tracking_number = HttpClient::Preconditions.assert_class('tracking_number', opts.delete(:tracking_number), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :tracking => tracking.to_hash,
              :status => status.value,
              :carrier => carrier,
              :tracking_number => tracking_number
            }
          end

        end

        class TrackingLabelVersion

          attr_reader :id, :timestamp, :type, :tracking_label

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking_label], 'TrackingLabelVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking_label = (x = opts.delete(:tracking_label); x.is_a?(::Io::Flow::V0::Models::TrackingLabelSummary) ? x : ::Io::Flow::V0::Models::TrackingLabelSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingLabelVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking_label => tracking_label.to_hash
            }
          end

        end

        class TrackingSummary

          attr_reader :id, :status, :order_number

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :status], 'TrackingSummary')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::TrackingStatus) ? x : ::Io::Flow::V0::Models::TrackingStatus.apply(x))
            @order_number = (x = opts.delete(:order_number); x.nil? ? nil : HttpClient::Preconditions.assert_class('order_number', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :status => status.value,
              :order_number => order_number
            }
          end

        end

        class TrackingVersion

          attr_reader :id, :timestamp, :type, :tracking

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :tracking], 'TrackingVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @tracking = (x = opts.delete(:tracking); x.is_a?(::Io::Flow::V0::Models::TrackingSummary) ? x : ::Io::Flow::V0::Models::TrackingSummary.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            TrackingVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :tracking => tracking.to_hash
            }
          end

        end

        # Provides the ability to upload a file to a URL (an expiring s3 url, usually
        # valid for 1 week)
        class Upload

          attr_reader :id, :name, :url, :expiration

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name, :url, :expiration], 'Upload')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @expiration = HttpClient::Preconditions.assert_class('expiration', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expiration)), DateTime)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Upload.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :name => name,
              :url => url,
              :expiration => expiration
            }
          end

        end

        # Represents a single user in the system
        class User < ExpandableUser

          attr_reader :id, :email, :name, :status

          def initialize(incoming={})
            super(:discriminator => ExpandableUser::Types::USER)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :name], 'User')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.is_a?(::Io::Flow::V0::Models::Name) ? x : ::Io::Flow::V0::Models::Name.new(x))
            @status = (x = (x = opts.delete(:status); x.nil? ? "active" : x); x.is_a?(::Io::Flow::V0::Models::UserStatus) ? x : ::Io::Flow::V0::Models::UserStatus.apply(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            User.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id,
              :email => email,
              :name => name.to_hash,
              :status => status.value
            }
          end

        end

        class UserForm

          attr_reader :email, :password, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @password = (x = opts.delete(:password); x.nil? ? nil : HttpClient::Preconditions.assert_class('password', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :password => password,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserPutForm

          attr_reader :email, :name

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @email = (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String))
            @name = (x = opts.delete(:name); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::NameForm) ? x : ::Io::Flow::V0::Models::NameForm.new(x)))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserPutForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :email => email,
              :name => name.nil? ? nil : name.to_hash
            }
          end

        end

        class UserReference < ExpandableUser

          attr_reader :id

          def initialize(incoming={})
            super(:discriminator => ExpandableUser::Types::USER_REFERENCE)
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'UserReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserReference.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def subtype_to_hash
            {
              :id => id
            }
          end

        end

        class UserVersion

          attr_reader :id, :timestamp, :type, :user

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :timestamp, :type, :user], 'UserVersion')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @timestamp = HttpClient::Preconditions.assert_class('timestamp', HttpClient::Helper.to_date_time_iso8601(opts.delete(:timestamp)), DateTime)
            @type = (x = opts.delete(:type); x.is_a?(::Io::Flow::V0::Models::ChangeType) ? x : ::Io::Flow::V0::Models::ChangeType.apply(x))
            @user = (x = opts.delete(:user); x.is_a?(::Io::Flow::V0::Models::User) ? x : ::Io::Flow::V0::Models::User.new(x))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            UserVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :timestamp => timestamp,
              :type => type.value,
              :user => user.to_hash
            }
          end

        end

        class Webhook

          attr_reader :id, :url, :events

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :url, :events], 'Webhook')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| HttpClient::Preconditions.assert_class('events', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Webhook.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :url => url,
              :events => events
            }
          end

        end

        # A webhook delivery represents an event that matched a webhook's event types.
        # Each delivery will be attempted one or more times subject to the settings of
        # your webhook.
        class WebhookDelivery

          attr_reader :id, :webhook, :status, :created_at, :latest, :next_attempt_at

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :webhook, :status, :created_at], 'WebhookDelivery')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @webhook = (x = opts.delete(:webhook); x.is_a?(::Io::Flow::V0::Models::WebhookReference) ? x : ::Io::Flow::V0::Models::WebhookReference.new(x))
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::WebhookStatus) ? x : ::Io::Flow::V0::Models::WebhookStatus.apply(x))
            @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
            @latest = (x = opts.delete(:latest); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::WebhookRequest) ? x : ::Io::Flow::V0::Models::WebhookRequest.new(x)))
            @next_attempt_at = (x = opts.delete(:next_attempt_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('next_attempt_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookDelivery.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :webhook => webhook.to_hash,
              :status => status.value,
              :created_at => created_at,
              :latest => latest.nil? ? nil : latest.to_hash,
              :next_attempt_at => next_attempt_at
            }
          end

        end

        class WebhookForm

          attr_reader :url, :events

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:url, :events], 'WebhookForm')
            @url = HttpClient::Preconditions.assert_class('url', opts.delete(:url), String)
            @events = HttpClient::Preconditions.assert_class('events', opts.delete(:events), Array).map { |v| HttpClient::Preconditions.assert_class('events', v, String) }
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :url => url,
              :events => events
            }
          end

        end

        class WebhookReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'WebhookReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class WebhookRequest

          attr_reader :id, :headers, :method, :body, :status, :started_at, :completed_at, :duration_ms, :response, :error

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :headers, :method, :body, :status], 'WebhookRequest')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Header) ? x : ::Io::Flow::V0::Models::Header.new(x)) }
            @method = (x = opts.delete(:method); x.is_a?(::Io::Flow::V0::Models::Method) ? x : ::Io::Flow::V0::Models::Method.apply(x))
            @body = HttpClient::Preconditions.assert_class('body', opts.delete(:body), String)
            @status = (x = opts.delete(:status); x.is_a?(::Io::Flow::V0::Models::WebhookStatus) ? x : ::Io::Flow::V0::Models::WebhookStatus.apply(x))
            @started_at = (x = opts.delete(:started_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('started_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @completed_at = (x = opts.delete(:completed_at); x.nil? ? nil : HttpClient::Preconditions.assert_class('completed_at', HttpClient::Helper.to_date_time_iso8601(x), DateTime))
            @duration_ms = (x = opts.delete(:duration_ms); x.nil? ? nil : HttpClient::Preconditions.assert_class('duration_ms', x, Integer))
            @response = (x = opts.delete(:response); x.nil? ? nil : (x = x; x.is_a?(::Io::Flow::V0::Models::WebhookResponse) ? x : ::Io::Flow::V0::Models::WebhookResponse.new(x)))
            @error = (x = opts.delete(:error); x.nil? ? nil : HttpClient::Preconditions.assert_class('error', x, String))
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :headers => headers.map { |o| o.to_hash },
              :method => method.value,
              :body => body,
              :status => status.value,
              :started_at => started_at,
              :completed_at => completed_at,
              :duration_ms => duration_ms,
              :response => response.nil? ? nil : response.to_hash,
              :error => error
            }
          end

        end

        class WebhookRequestReference

          attr_reader :id

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id], 'WebhookRequestReference')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookRequestReference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id
            }
          end

        end

        class WebhookResponse

          attr_reader :id, :request, :headers, :body, :body_url, :status

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:id, :request, :headers, :body, :status], 'WebhookResponse')
            @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
            @request = (x = opts.delete(:request); x.is_a?(::Io::Flow::V0::Models::WebhookRequestReference) ? x : ::Io::Flow::V0::Models::WebhookRequestReference.new(x))
            @headers = HttpClient::Preconditions.assert_class('headers', opts.delete(:headers), Array).map { |v| (x = v; x.is_a?(::Io::Flow::V0::Models::Header) ? x : ::Io::Flow::V0::Models::Header.new(x)) }
            @body = HttpClient::Preconditions.assert_class('body', opts.delete(:body), String)
            @body_url = (x = opts.delete(:body_url); x.nil? ? nil : HttpClient::Preconditions.assert_class('body_url', x, String))
            @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookResponse.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :id => id,
              :request => request.to_hash,
              :headers => headers.map { |o| o.to_hash },
              :body => body,
              :body_url => body_url,
              :status => status
            }
          end

        end

        # Sets organization level settings to determine things like how many retries on
        # delivery, how long we wait, etc. By default, we will attempt delivery up to 6
        # times, using exponential backoff with a see of 1 minute (60k ms) - which means
        # that we will retry over the course of approximately an hour before giving up.
        class WebhookSettings

          attr_reader :secret, :retry_max_attempts, :retry_sleep_ms, :sleep_ms

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @secret = (x = opts.delete(:secret); x.nil? ? nil : HttpClient::Preconditions.assert_class('secret', x, String))
            @retry_max_attempts = HttpClient::Preconditions.assert_class('retry_max_attempts', (x = opts.delete(:retry_max_attempts); x.nil? ? 6 : x), Integer)
            @retry_sleep_ms = HttpClient::Preconditions.assert_class('retry_sleep_ms', (x = opts.delete(:retry_sleep_ms); x.nil? ? 60000 : x), Integer)
            @sleep_ms = HttpClient::Preconditions.assert_class('sleep_ms', (x = opts.delete(:sleep_ms); x.nil? ? 0 : x), Integer)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            WebhookSettings.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :secret => secret,
              :retry_max_attempts => retry_max_attempts,
              :retry_sleep_ms => retry_sleep_ms,
              :sleep_ms => sleep_ms
            }
          end

        end

        class Zone

          attr_reader :province, :country, :region

          def initialize(incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            HttpClient::Preconditions.require_keys(opts, [:region], 'Zone')
            @province = (x = opts.delete(:province); x.nil? ? nil : HttpClient::Preconditions.assert_class('province', x, String))
            @country = (x = opts.delete(:country); x.nil? ? nil : HttpClient::Preconditions.assert_class('country', x, String))
            @region = HttpClient::Preconditions.assert_class('region', opts.delete(:region), String)
          end

          def to_json
            JSON.dump(to_hash)
          end

          def copy(incoming={})
            Zone.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
          end

          def to_hash
            {
              :province => province,
              :country => country,
              :region => region
            }
          end

        end

      end

      # ===== END OF SERVICE DEFINITION =====
      module HttpClient

        class HttpHandler

          # Returns a client instance to use
          #
          # @param base_uri The base URI for this API
          # @param path the Requested full http path (including any query strings)
          def instance(base_uri, path)
            raise "Override in subclass"
          end

        end

        class HttpHandlerInstance

          # Executes a request. The provided request object will be an
          # instance of Net::HTTP (e.g. Net::HTTP::Get)
          def execute(request)
            raise "Override in subclass"
          end

        end

        class DefaultHttpHandler < HttpHandler

          def instance(base_uri, path)
            DefaultHttpHandlerInstance.new(base_uri)
          end

        end

        class DefaultHttpHandlerInstance < HttpHandlerInstance

          attr_reader :client

          def initialize(base_uri)
            @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
            @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
            if @base_uri.scheme == "https"
              configure_ssl
            end
          end

          def execute(request)
            response = begin
                         @client.request(request)
                       rescue SocketError => e
                         raise Exception.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                       end

            case response
            when Net::HTTPSuccess
              response.body
            else
              body = response.body rescue nil
              raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
            end
          end

          def full_uri(path)
            File.join(@base_uri.to_s, path)
          end

          # Called to configure SSL if the base uri requires it
          def configure_ssl
            @client.use_ssl = true
            @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
            @client.cert_store = OpenSSL::X509::Store.new
            @client.cert_store.set_default_paths
          end

        end

        class Request

          attr_reader :path

          def initialize(http_handler, base_uri, path)
            @http_handler = http_handler
            @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
            @path = Preconditions.assert_class('path', path, String)
            @params = nil
            @body = nil
            @auth = nil
            @headers = {}
            @header_keys_lower_case = []
          end

          def with_header(name, value)
            Preconditions.check_not_blank('name', name, "Header name is required")
            Preconditions.check_not_blank('value', value, "Header value is required")
            Preconditions.check_state(!@headers.has_key?(name),
                                      "Duplicate header named[%s]" % name)
            @headers[name] = value
            @header_keys_lower_case << name.downcase
            self
          end

          def with_auth(auth)
            Preconditions.assert_class('auth', auth, HttpClient::Authorization)
            Preconditions.check_state(@auth.nil?, "auth previously set")

            if auth.scheme.name == AuthScheme::BASIC.name
              @auth = auth
            else
              raise "Auth Scheme[#{auth.scheme.name}] not supported"
            end
            self
          end

          def with_query(params)
            Preconditions.assert_class('params', params, Hash)
            Preconditions.check_state(@params.nil?, "Already have query parameters")
            @params = params
            self
          end

          # Wrapper to set Content-Type header to application/json and set
          # the provided json document as the body
          def with_json(json)
            @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
            with_body(json)
          end

          def with_body(body)
            Preconditions.check_not_blank('body', body)
            @body = body
            self
          end

          def get(&block)
            do_request(Net::HTTP::Get, &block)
          end

          def delete(&block)
            do_request(Net::HTTP::Delete, &block)
          end

          def options(&block)
            do_request(Net::HTTP::Options, &block)
          end

          def post(&block)
            do_request(Net::HTTP::Post, &block)
          end

          def put(&block)
            do_request(Net::HTTP::Put, &block)
          end

          class PATCH < Net::HTTP::Put
            METHOD = "PATCH"
          end

          def patch(&block)
            do_request(PATCH, &block)
          end

          def do_request(klass)
            Preconditions.assert_class('klass', klass, Class)

            uri = path.dup
            if q = to_query(@params)
              uri += "?%s" % q
            end

            request = klass.send(:new, uri)

            curl = ['curl']
            if klass != Net::HTTP::Get
              curl << "-X%s" % klass.name.split("::").last.upcase
            end

            if @body
              # DEBUG path = "/tmp/rest_client.tmp"
              # DEBUG File.open(path, "w") { |os| os << @body.to_s }
              # DEBUG curl << "-d@%s" % path
              request.body = @body
            end

            if @auth
              curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
              Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                        "Cannot specify both an Authorization header and an auth instance")
              user_pass = "%s:%s" % [@auth.username, @auth.password]
              encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
              request.add_field("Authorization", "Basic %s" % encoded)
            end

            @headers.each { |key, value|
              curl <<  "-H \"%s: %s\"" % [key, value]
              request.add_field(key, value)
            }

            curl << "'%s%s'" % [@base_uri, path]
            # DEBUG puts curl.join(" ")

            raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
            response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

            if block_given?
              yield response
            else
              response
            end
          end

          private
          def to_query(params={})
            parts = (params || {}).map { |k,v|
              if v.is_a?(Enumerable)
                v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
              else
                "%s=%s" % [k, CGI.escape(v.to_s)]
              end
            }
            parts.empty? ? nil : parts.join("&")
          end

        end

        class ServerError < StandardError

          attr_reader :code, :details, :body, :uri

          def initialize(code, details, incoming={})
            opts = HttpClient::Helper.symbolize_keys(incoming)
            @code = HttpClient::Preconditions.assert_class('code', code, Integer)
            @details = HttpClient::Preconditions.assert_class('details', details, String)
            @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
            @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
            super(self.message)
          end

          def message
            m = "%s %s" % [@code, @details]
            if @body
              m << ": %s" % @body
            end
            m
          end

          def body_json
            @body ? JSON.parse(@body) : nil
          end

        end

        class PreconditionException < Exception

          attr_reader :message

          def initialize(message)
            super(message)
            @message = message
          end

        end

        module Preconditions

          def Preconditions.check_argument(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_argument failed")
            end
            nil
          end

          def Preconditions.check_state(expression, error_message=nil)
            if !expression
              raise PreconditionException.new(error_message || "check_state failed")
            end
            nil
          end

          def Preconditions.check_not_nil(field_name, reference, error_message=nil)
            if reference.nil?
              raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
            end
            reference
          end

          def Preconditions.check_not_blank(field_name, reference, error_message=nil)
            if reference.to_s.strip == ""
              raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
            end
            reference
          end

          # Throws an error if opts is not empty. Useful when parsing
          # arguments to a function
          def Preconditions.assert_empty_opts(opts)
            if !opts.empty?
              raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
            end
          end

          # Requires that the provided hash has the specified keys.
          # @param fields A list of symbols
          def Preconditions.require_keys(hash, fields, error_prefix=nil)
            missing = fields.select { |f| !hash.has_key?(f) }
            if !missing.empty?
              msg = "Missing required fields: " + missing.join(", ")
              raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
            end
          end

          # Asserts that value is not nill and is_?(klass). Returns
          # value. Common use is
          #
          # amount = Preconditions.assert_class('amount', amount, BigDecimal)
          def Preconditions.assert_class(field_name, value, klass)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('klass', klass)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
            Preconditions.check_state(value.is_a?(klass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_class_or_nil(field_name, value, klass)
            if !value.nil?
              Preconditions.assert_class(field_name, value, klass)
            end
          end

          def Preconditions.assert_boolean(field_name, value)
            Preconditions.check_not_nil('field_name', field_name)
            Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
            Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                      "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
            value
          end

          def Preconditions.assert_boolean_or_nil(field_name, value)
            if !value.nil?
              Preconditions.assert_boolean(field_name, value)
            end
          end

          def Preconditions.assert_collection_of_class(field_name, values, klass)
            Preconditions.assert_class(field_name, values, Array)
            values.each { |v| Preconditions.assert_class(field_name, v, klass) }
          end

          def Preconditions.assert_hash_of_class(field_name, hash, klass)
            Preconditions.assert_class(field_name, hash, Hash)
            values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
          end

        end

        class AuthScheme

          attr_reader :name

          def initialize(name)
            @name = HttpClient::Preconditions.check_not_blank('name', name)
          end

          BASIC = AuthScheme.new("basic") unless defined?(BASIC)

        end

        class Authorization

          attr_reader :scheme, :username, :password

          def initialize(scheme, username, opts={})
            @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
            @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
            @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
            HttpClient::Preconditions.assert_empty_opts(opts)
          end

          def Authorization.basic(username, password=nil)
            Authorization.new(AuthScheme::BASIC, username, :password => password)
          end

        end

        module Helper

          def Helper.symbolize_keys(hash)
            Preconditions.assert_class('hash', hash, Hash)
            new_hash = {}
            hash.each { |k, v|
              new_hash[k.to_sym] = v
            }
            new_hash
          end

          def Helper.to_big_decimal(value)
            value ? BigDecimal.new(value.to_s) : nil
          end

          def Helper.to_object(value)
            value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
          end

          def Helper.to_uuid(value)
            Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                      "Invalid guid[%s]" % value)
            value
          end

          def Helper.to_date_iso8601(value)
            if value.is_a?(Date)
              value
            elsif value
              Date.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.to_date_time_iso8601(value)
            if value.is_a?(DateTime)
              value
            elsif value
              DateTime.parse(value.to_s)
            else
              nil
            end
          end

          def Helper.date_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%d')
          end

          def Helper.date_time_iso8601_to_string(value)
            value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
          end

          TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
          FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

          def Helper.to_boolean(field_name, value)
            string = value.to_s.strip.downcase
            if TRUE_STRINGS.include?(string)
              true
            elsif FALSE_STRINGS.include?(string)
              false
            elsif string != ""
              raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
            else
              nil
            end
          end

        end

      end
    end
  end
end